type Mask = Mask5;
type MaskSep = Mask5Sep;

fn bilateral_filter_mask(x: int, y: int, acc: Acc, mask: Mask, sigma_d: int, c_r: float,
                         bh_lower: fn(int, int, fn(f32)) -> int, bh_upper: fn(int, int, fn(f32)) -> int
                        ) -> float {
    let mut k = 0.0f;
    let mut p = 0.0f;

    for yf in iterate(-2*sigma_d, 2*sigma_d+1) {
        for xf in iterate(-2*sigma_d, 2*sigma_d+1) {
            let diff = get_pixel(acc, x + xf, y + yf, bh_lower, bh_upper) - pixel_at(acc, acc.roi.o_x + acc.rox, acc.roi.o_y + acc.roy + y);

            let c = mask.data(xf + 2*sigma_d)(yf + 2*sigma_d);
            let s = expf(-c_r * diff*diff);

            k += c * s;
            p += c * s * get_pixel(acc, x + xf, y + yf, bh_lower, bh_upper);
        }
    }

    p/k
}

extern 
fn thorin_bilateral(arr_data: &[float], out_data: &[float], width: int, height: int) -> () {
    let sigma_r = 5.0f;
    let sigma_d = 1;
    let c_d     = 1.0f / (2.0f * (sigma_d*sigma_d as float));
    let c_r     = 1.0f / (2.0f * sigma_r*sigma_r);
    let arr     = Img { data : arr_data, width : width, height : height, stride : width };
    let out     = Img { data : out_data, width : width, height : height, stride : width };

    let lower = clamp_lower;
    let upper = clamp_upper;

    let mask    = Mask {
        data : [[0.018316f, 0.082085f, 0.135335f, 0.082085f, 0.018316f],
                [0.082085f, 0.367879f, 0.606531f, 0.367879f, 0.082085f],
                [0.135335f, 0.606531f, 1.000000f, 0.606531f, 0.135335f],
                [0.082085f, 0.367879f, 0.606531f, 0.367879f, 0.082085f],
                [0.018316f, 0.082085f, 0.135335f, 0.082085f, 0.018316f]],
        size_x : 5, size_y : 5
    };

    for x, y, mut out_acc, arr_acc, mask in @iteration(out, arr, mask) {
        out_acc.img.data((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = bilateral_filter_mask(x, y, arr_acc, mask, sigma_d, c_r, lower, upper);
    }
}

