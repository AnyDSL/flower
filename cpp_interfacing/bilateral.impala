struct Mask {
    data : [[float * 5] * 5],
    size_x : int,
    size_y : int,
}
struct MaskSep {
    data : [float * 5],
    size : int,
}

fn bilateral_filter_mask(mask : Mask, acc : Acc, sigma_d : int, c_r : float, mut x : int, mut y : int) -> float {
    let mut k = 0.0f;
    let mut p = 0.0f;

    x = x + acc.o_x;
    y = y + acc.o_y;

    for yf in iterate(-2*sigma_d, 2*sigma_d+1) {
        for xf in iterate(-2*sigma_d, 2*sigma_d+1) {
            let mut idx_x = x + xf;
            let mut idx_y = y + yf;

            // 0 --- 1 --- 2
            // 3 --- 4 --- 5
            // 6 --- 7 --- 8

            // left
            if acc.region == 0 { idx_x = clamp_lower(idx_x, 0); }
            if acc.region == 3 { idx_x = clamp_lower(idx_x, 0); }
            if acc.region == 6 { idx_x = clamp_lower(idx_x, 0); }

            // right
            if acc.region == 2 { idx_x = clamp_upper(idx_x, acc.img.width); }
            if acc.region == 5 { idx_x = clamp_upper(idx_x, acc.img.width); }
            if acc.region == 8 { idx_x = clamp_upper(idx_x, acc.img.width); }

            // top
            if acc.region == 0 { idx_y = clamp_lower(idx_y, 0); }
            if acc.region == 1 { idx_y = clamp_lower(idx_y, 0); }
            if acc.region == 2 { idx_y = clamp_lower(idx_y, 0); }

            // bottom
            if acc.region == 6 { idx_y = clamp_upper(idx_y, acc.img.height); }
            if acc.region == 7 { idx_y = clamp_upper(idx_y, acc.img.height); }
            if acc.region == 8 { idx_y = clamp_upper(idx_y, acc.img.height); }

            // all in
            if acc.region == 10 {
                idx_x = clamp_lower(idx_x, 0);
                idx_x = clamp_upper(idx_x, acc.img.width);
                idx_y = clamp_upper(idx_y, acc.img.height);
                idx_y = clamp_lower(idx_y, 0);
            }


            let diff = acc.img.data(idx_y * acc.img.width + idx_x) - acc.img.data(y * acc.img.width + x);

            let s = expf(-c_r * diff*diff) * mask.data(xf + 2*sigma_d)(yf + 2*sigma_d);

            k += s;
            p += s * acc.img.data(idx_y * acc.img.width + idx_x);
        }
    }

    p/k
}

extern 
fn thorin_bilateral(arr_data : &[float], out_data : &[float], width : int, height : int) -> () {
    let sigma_r = 5.0f;
    let sigma_d = 1;
    let c_d     = 1.0f / (2.0f * (sigma_d*sigma_d as float));
    let c_r     = 1.0f / (2.0f * sigma_r*sigma_r);
    let arr     = Img { data : arr_data, width : width, height : height };
    let out     = Img { data : out_data, width : width, height : height };
    let mask    = Mask {
        data : [[0.018316f, 0.082085f, 0.135335f, 0.082085f, 0.018316f],
                [0.082085f, 0.367879f, 0.606531f, 0.367879f, 0.082085f],
                [0.135335f, 0.606531f, 1.000000f, 0.606531f, 0.135335f],
                [0.082085f, 0.367879f, 0.606531f, 0.367879f, 0.082085f],
                [0.018316f, 0.082085f, 0.135335f, 0.082085f, 0.018316f]],
        size_x : 5, size_y : 5
    };

    for x, y, mask, arr_acc, mut out_acc in @iteration(mask, arr, out) {
        out_acc.img.data((out_acc.o_y + y)*out_acc.img.width + out_acc.o_x + x) = bilateral_filter_mask(mask, arr_acc, sigma_d, c_r, x, y);
    }
}

