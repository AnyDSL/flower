struct Mask {
    data : [[float * 3] * 3],
    size_x : int,
    size_y : int,
}
struct MaskSep {
    data : [float * 3],
    size : int,
}

fn apply_stencil(stencil : Mask, acc : Acc, x : int, y : int) -> float {
    let mut sum = 0.0f;
    let half_range_y = stencil.size_y / 2;
    let half_range_x = stencil.size_x / 2;

    for j in iterate(-half_range_y, half_range_y+1) {
        for i in iterate(-half_range_x, half_range_x+1) {
            let stencil_val = stencil.data(j + half_range_y)(i + half_range_x);
            if stencil_val != 0.0f {
                let mut idx_x = acc.o_x + x + i;
                let mut idx_y = acc.o_y + y + j;

                // 0 --- 1 --- 2
                // 3 --- 4 --- 5
                // 6 --- 7 --- 8

                // left
                if acc.region == 0 { idx_x = clamp_lower(idx_x, 0); }
                if acc.region == 3 { idx_x = clamp_lower(idx_x, 0); }
                if acc.region == 6 { idx_x = clamp_lower(idx_x, 0); }

                // right
                if acc.region == 2 { idx_x = clamp_upper(idx_x, acc.img.width); }
                if acc.region == 5 { idx_x = clamp_upper(idx_x, acc.img.width); }
                if acc.region == 8 { idx_x = clamp_upper(idx_x, acc.img.width); }

                // top
                if acc.region == 0 { idx_y = clamp_lower(idx_y, 0); }
                if acc.region == 1 { idx_y = clamp_lower(idx_y, 0); }
                if acc.region == 2 { idx_y = clamp_lower(idx_y, 0); }

                // bottom
                if acc.region == 6 { idx_y = clamp_upper(idx_y, acc.img.height); }
                if acc.region == 7 { idx_y = clamp_upper(idx_y, acc.img.height); }
                if acc.region == 8 { idx_y = clamp_upper(idx_y, acc.img.height); }

                // all in
                if acc.region == 10 {
                    idx_x = clamp_lower(idx_x, 0);
                    idx_x = clamp_upper(idx_x, acc.img.width);
                    idx_y = clamp_upper(idx_y, acc.img.height);
                    idx_y = clamp_lower(idx_y, 0);
                }

                sum += acc.img.data(idx_y * acc.img.width + idx_x) * stencil_val;
            } else {
                // additional logic for empty stencil value
            }
        }
    }

    sum
}

fn main() -> int {
    let width  = 2048;
    let height = 2048;
    let a      = 0.2f;
    let b      = 1.0f - 4.0f * a;
    let arr    = Img { data : ~[width*height:float], width : width, height : height };
    let out    = Img { data : ~[width*height:float], width : width, height : height };
    init_rand(arr.data, width, height);
    init_zero(out.data, width, height);

    let stencil = Mask {
        data : [[0.0f, b, 0.0f],
                [   b, a, b   ],
                [0.0f, b, 0.0f]],
        size_x : 3, size_y : 3
    };

    // SS
    for x, y, stencil, arr_acc, mut out_acc in @iteration(stencil, arr, out) {
        out_acc.img.data((out_acc.o_y + y)*out_acc.img.width + out_acc.o_x + x) = apply_stencil(stencil, arr_acc, x, y);
    }

    //// SS + BH
    //for x, y, stencil, arr_acc, mut out_acc in @iteration_bounds(stencil, arr, out) {
    //    out_acc.img.data((out_acc.o_y + y)*out_acc.img.width + out_acc.o_x + x) = apply_stencil(stencil, arr_acc, x, y);
    //}

    //// SS + SM
    //for x, y, stencil, arr_acc, mut out_acc in @iteration_advanced(stencil, arr, out) {
    //    out_acc.img.data((out_acc.o_y + y)*out_acc.img.width + out_acc.o_x + x) = apply_stencil(stencil, arr_acc, x, y);
    //}


    let mut passed = 0;

    for y in range(0, out.height) {
        for x in range(0, out.width) {
            let acc = Acc { img : arr, o_x : 0, o_y : 0, region : 10 };
            let ref = @apply_stencil(stencil, acc, x, y);
            let mut diff = ref - out.data(y*width + x);
            if diff < 0.0f  { diff = -diff; }
            if diff > 0.01f { passed = 42; }
        }
    }

    passed
}
