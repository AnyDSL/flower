/*
 * Harris Corner
 *
 * A Combined Corner and Edge Detector
 * Chris Harris and Mike Stephens - Alvey Vision Conference, 1988
 *
 */

extern
fn harris_corner_pipelined(img_data: &[pixel_t], out_data: &mut[pixel_t]) -> () {
    let width  = 1024;
    let height = 1024;
    
    let input  = Img { buf : Buffer { device : 0, data : bitcast[&[i8]](img_data) }, width : width, height : height, stride : width };
    let harris = create_img(width, height, alloc_cpu);
    //let dx     = create_img(width, height, alloc_cpu);
    //let dy     = create_img(width, height, alloc_cpu);
    //let dxx    = create_img(width, height, alloc_cpu);
    //let dxy    = create_img(width, height, alloc_cpu);
    //let dyy    = create_img(width, height, alloc_cpu);
    //let gxx    = create_img(width, height, alloc_cpu);
    //let gxy    = create_img(width, height, alloc_cpu);
    //let gyy    = create_img(width, height, alloc_cpu);
    //         -- ix -|-- ixx -- sxx -
    //       /         \              \
    // in --            > ixy -- sxy --> hc -- out
    //       \         /              /
    //         -- iy -|-- iyy -- syy -
    static mut dx_c  : channel;
    static mut dx_c0 : channel;
    static mut dx_c1 : channel;
    static mut dy_c  : channel;
    static mut dy_c0 : channel;
    static mut dy_c1 : channel;
    static mut dxx_c : channel;
    static mut dxy_c : channel;
    static mut dyy_c : channel;
    static mut gxx_c : channel;
    static mut gxy_c : channel;
    static mut gyy_c : channel;
    let dx  = create_virtual_img(width, height, &mut dx_c );
    let dx0 = create_virtual_img(width, height, &mut dx_c0);
    let dx1 = create_virtual_img(width, height, &mut dx_c1);
    let dy  = create_virtual_img(width, height, &mut dy_c );
    let dy0 = create_virtual_img(width, height, &mut dy_c0);
    let dy1 = create_virtual_img(width, height, &mut dy_c1);
    let dxx = create_virtual_img(width, height, &mut dxx_c);
    let dxy = create_virtual_img(width, height, &mut dxy_c);
    let dyy = create_virtual_img(width, height, &mut dyy_c);
    let gxx = create_virtual_img(width, height, &mut gxx_c);
    let gxy = create_virtual_img(width, height, &mut gxy_c);
    let gyy = create_virtual_img(width, height, &mut gyy_c);

    // compute the first derivative using the Sobel operator
    let mdx = get_mask3(sobel_mask3_x);
    let mdy = get_mask3(sobel_mask3_y);

    let lower = clamp_lower;
    let upper = clamp_upper;
    let iteration_fun = iteration;

    for math, x, y, out, arr, mask in iteration_img2virt(math, dx, input, mdx, lower, upper) {
        out.write(x, y, apply_stencil(x, y, arr, mask));
    }
    for math, x, y, out, arr, mask in iteration_img2virt(math, dy, input, mdy, lower, upper) {
        out.write(x, y, apply_stencil(x, y, arr, mask));
    }
  
    // Replicate virtual images for multiple reads
    split_virtual_image(math, dx0, dx1, dx);
    split_virtual_image(math, dy0, dy1, dy);

    // compute dxx, dyy, dxy
    let dx0_dev = get_device_copy_virtual(dx0);
    let dx1_dev = get_device_copy_virtual(dx1);
    let dy0_dev = get_device_copy_virtual(dy0);
    let dy1_dev = get_device_copy_virtual(dy1);
    for math, x, y, out in iteration_point_2virt(math, dxx) {
        let dx_acc = get_acc_virtual(dx0_dev, set_pixel_fn_virtual(dx0_dev), get_pixel_fn_virtual(dx0_dev));
        let dx = dx_acc.read(x, y);
        out.write(x, y, dx * dx);
    }
    for math, x, y, out in iteration_point_2virt(math, dyy) {
        let dy_acc = get_acc_virtual(dy0_dev, set_pixel_fn_virtual(dy0_dev), get_pixel_fn_virtual(dy0_dev));
        let dy = dy_acc.read(x, y);
        out.write(x, y, dy * dy);
    }
    for math, x, y, out in iteration_point_2virt(math, dxy) {
        let dx_acc = get_acc_virtual(dx1_dev, set_pixel_fn_virtual(dx1_dev), get_pixel_fn_virtual(dx1_dev));
        let dy_acc = get_acc_virtual(dy1_dev, set_pixel_fn_virtual(dy1_dev), get_pixel_fn_virtual(dy1_dev));
        let dx = dx_acc.read(x, y);
        let dy = dy_acc.read(x, y);
        out.write(x, y, dx * dy);
    }
    release_device_copy_virtual(dx0_dev);
    release_device_copy_virtual(dx1_dev);
    release_device_copy_virtual(dy0_dev);
    release_device_copy_virtual(dy1_dev);


    // compute gxx, gyy, gxy using Gaussian blur
    let mg = get_mask3(gauss_mask3);

    for math, x, y, out, arr, mask in iteration_virt2virt(math, gxx, dxx, mg, lower, upper) {
        out.write(x, y, apply_stencil(x, y, arr, mask));
    }
    for math, x, y, out, arr, mask in iteration_virt2virt(math, gyy, dyy, mg, lower, upper) {
        out.write(x, y, apply_stencil(x, y, arr, mask));
    }
    for math, x, y, out, arr, mask in iteration_virt2virt(math, gxy, dxy, mg, lower, upper) {
        out.write(x, y, apply_stencil(x, y, arr, mask));
    }


    // compute score for Harris corner
    let gxx_dev = get_device_copy_virtual(gxx);
    let gyy_dev = get_device_copy_virtual(gyy);
    let gxy_dev = get_device_copy_virtual(gxy);
    for math, x, y, out in iteration_point_2img(math, harris) {
        let gxx_acc = get_acc_virtual(gxx_dev, set_pixel_fn_virtual(gxx_dev), get_pixel_fn_virtual(gxx_dev));
        let gyy_acc = get_acc_virtual(gyy_dev, set_pixel_fn_virtual(gyy_dev), get_pixel_fn_virtual(gyy_dev));
        let gxy_acc = get_acc_virtual(gxy_dev, set_pixel_fn_virtual(gxy_dev), get_pixel_fn_virtual(gxy_dev));
        let xx = gxx_acc.read(x, y);
        let yy = gyy_acc.read(x, y);
        let xy = gxy_acc.read(x, y);
        let det   = xx * yy - xy * xy;
        let trace = xx + yy;
        out.write(x, y, det - k * trace * trace);
    }
    release_device_copy_virtual(gxx_dev);
    release_device_copy_virtual(gyy_dev);
    release_device_copy_virtual(gxy_dev);

    print_total_timing();

    // post-processing: mark corners
    for y in range(0, height) {
        for x in range(0, width) {
            let harris_acc = get_acc(harris, |idx, val| { bitcast[&mut[pixel_t]](harris.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](harris.buf.data)(idx));
            if harris_acc.read(x, y) > threshold {
                out_data(y*width + x) = markHigh 
            } else{
                out_data(y*width + x) = markLow 
            }
            //out_data(y*width + x) = harris_acc.read(x, y);
        }   
    }   

    //release(harris.buf);
    //release(dx.buf);
    //release(dy.buf);
    //release(dxx.buf);
    //release(dxy.buf);
    //release(dyy.buf);
    //release(gxx.buf);
    //release(gxy.buf);
    //release(gyy.buf);
}
