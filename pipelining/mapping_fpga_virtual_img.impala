// ---------------------------------------------------------------------------
// Support for virtual images
// ---------------------------------------------------------------------------
// pipe support
type pipe = channel;

struct VirtualImg {
    buf    : &mut channel,
    width  : i32,
    height : i32,
    stride : i32,
}

fn @create_virtual_img(width: i32, height: i32, buf: &mut channel) -> VirtualImg {
    let stride = round_up(width, get_alignment());
    VirtualImg { buf : buf, width : width,  height : height, stride : stride }
}

// ---------------------------- streaming --------------------------------------
fn @get_stream_from_virtual_img(img: VirtualImg, pFactor: int) -> stream_in_img {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { value = read_channel(img.buf); }
    fn @read(idx: int) -> pixel_t { value }
    let in_s = stream_in { update : update, read : read, pFactor : pFactor};
    stream_in_img { stream_in: in_s, width: img.width, stride: img.stride, height: img.height }
}

fn @set_stream_from_virtual_img(img: VirtualImg, pFactor: int) -> stream_out_img {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { write_channel(img.buf, value); }
    fn @write(idx: int, din: pixel_t) -> () { value = din; }
    let out_s = stream_out { update : update, write : write, pFactor : pFactor};
    stream_out_img { stream_out: out_s, width: img.width, stride: img.stride, height: img.height }
}

// --------------------- memory copy functions --------------------------------
fn @get_device_copy_virtual(img: VirtualImg) -> VirtualImg { img }
fn @get_host_copy_virtual(img_dev: VirtualImg, img: VirtualImg) -> () {}
fn @release_device_copy_virtual(img: VirtualImg) -> () {}

// --------------------- accessor: mapping dependent functions ----------------
// Virtual images
// Todo: think about the cases where channel streaming is not suitable
fn @get_acc_virtual(img: VirtualImg, set_pixel_fn_virtual: fn(i32, pixel_t) -> (), get_pixel_fn_virtual: fn(i32) -> pixel_t) -> Acc {
    Acc { read:  @|x, y|    get_pixel_fn_virtual(0),
          write: @|x, y, v| set_pixel_fn_virtual(0, v)
      }
}

// images
fn @get_pixel_fn_virtual(img: VirtualImg) -> fn(i32) -> pixel_t  {|idx| read_channel(img.buf) }
fn @set_pixel_fn_virtual(img: VirtualImg) -> fn(i32, pixel_t) -> () {|idx, val|  write_channel(img.buf, val) }

//  ------------------- Stencil Processing ----------------------
fn @iteration_img2virt(math: Intrinsics, out: VirtualImg, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out_dev = get_device_copy_virtual(out);

    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let coarsening_fun = FetchAndCalc;

            let in_s  = get_stream_from_global_img(arr_dev, pFactor);
            let out_s = set_stream_from_virtual_img(out_dev, pFactor);
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, mask, bh_lower, bh_upper, body);
        }
    }
    get_host_copy_virtual(out_dev, out);
}

fn @iteration_virt2virt(math: Intrinsics, out: VirtualImg, arr: VirtualImg, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy_virtual(arr);
    let out_dev = get_device_copy_virtual(out);

    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let coarsening_fun = FetchAndCalc;

            let in_s  = get_stream_from_virtual_img(arr_dev, pFactor);
            let out_s = set_stream_from_virtual_img(out_dev, pFactor);
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, mask, bh_lower, bh_upper, body);
        }
    }
    get_host_copy_virtual(out_dev, out);
}

fn @iteration_virt2img(math: Intrinsics, out: Img, arr: VirtualImg, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy_virtual(arr);
    let out_dev = get_device_copy(out);

    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let coarsening_fun = FetchAndCalc;

            let in_s  = get_stream_from_virtual_img(arr_dev, pFactor);
            let out_s = set_stream_from_global_img(out_dev, pFactor);
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, mask, bh_lower, bh_upper, body);
        }
    }
    get_host_copy(out_dev, out);
}

// -------------------------- point operators ----------------------------------
fn @iteration_point_2img(math: Intrinsics, out: Img, body: fn(Intrinsics, i32, i32, Acc) -> ()) -> () {
    iteration_point(math, out, body)
}

fn @iteration_point_2virt(math: Intrinsics, out: VirtualImg, body: fn(Intrinsics, i32, i32, Acc) -> ()) -> () {
    let acc = accelerator(device_id);
    let out_dev = get_device_copy_virtual(out);

    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = set_stream_from_virtual_img(out, pFactor);
            iter_point_body(pFactor, out_s, body);
        }
    }
    get_host_copy_virtual(out_dev, out);
}


fn @split_virtual_image(math: Intrinsics, arr: VirtualImg, pipe0: &mut pipe, pipe1: &mut pipe) -> (VirtualImg, VirtualImg) {
    let acc = accelerator(device_id);
    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let image_size = arr.height * arr.stride;

            for y in range(0, image_size) {
                let data = read_channel(arr.buf);
                write_channel(pipe0, data);
                write_channel(pipe1, data);
            }
        }
    }
    let out0 = create_virtual_img(arr.width, arr.height, pipe0);
    let out1 = create_virtual_img(arr.width, arr.height, pipe1);
    (out0, out1)
}

