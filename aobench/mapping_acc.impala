extern "C" {
    fn magic_plane_id(Plane) -> Plane;
    fn magic_spheres_id([Sphere * 3]) -> [Sphere * 3];
    fn drand48() -> f64;
}

// MWC64X Random Number Generator
// http://cas.ee.ic.ac.uk/people/dt10/research/rngs-gpu-mwc64x.html
fn rnd_u32(state: u64) -> (u32, u64) {
    let hi = state >> 32u64;
    let lo = state & 0xFFFFFFFFu64;
    ((lo as u32) ^ (hi as u32), lo * 4294883355u64 + hi)
}

fn rnd_f64(state: u64) -> (f64, u64) {
    let r = rnd_u32(state);
    let k = 1.0 / (0xFFFFFFFFu64 as f64);
    ((r(0) as f64) * k, r(1))
}

fn iteration(out: &[u8], width: int, height: int,
             body: fn(int, int, &[u8], fn() -> f64) -> ()
            ) -> () {
    let grid   = (width, height, 1);
    let block  = (32, 4, 1);

    // initialize seed on the CPU using drand48()
    let mut seed = ~[width * height: f64];
    for i in $range(0, width * height) {
        seed(i) = drand48();
    }

    let seed_gpu = mmap_f64(seed, acc_dev(), acc_mem(), 0, width * height);
    let out = mmap_u8(out, acc_dev(), acc_mem(), 0, width * height * 3);

    for benchmark_acc() {
        acc(acc_dev(), grid, block, || @{
            let mut state = seed_gpu(acc_gidy()*width + acc_gidx()) as u64;
            fn rand() -> f64 {
                let r = rnd_f64(state);
                state = r(1);
                r(0)
            }
            body(acc_gidx(), acc_gidy(), out, rand);
        });
    }

    munmap_u8(out);
}

