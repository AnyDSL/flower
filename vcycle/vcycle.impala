type Mask = Mask3;
type MaskSep = Mask3Sep;

// Dirichlet boundary handling -> 0
fn get_pixel(acc : Acc, x : int, y : int) -> float {
    if x + acc.rox <  acc.roi.o_x ||
       x + acc.rox >= acc.roi.o_x + acc.roi.width ||
       y + acc.roy <  acc.roi.o_y ||
       y + acc.roy >= acc.roi.o_y + acc.roi.height {
        0.0f
    } else {
        acc.img.data((acc.roi.o_y + acc.roy + y)*acc.img.stride + acc.roi.o_x + acc.rox + x)
    }
}
fn set_pixel(mut acc : Acc, x : int, y : int, val : float) -> () {
    acc.img.data((acc.roi.o_y + acc.roy + y)*acc.img.stride + acc.roi.o_x + acc.rox + x) = val
}

fn apply_stencil(mask : Mask, acc : Acc, x : int, y : int) -> float {
    let mut sum = 0.0f;
    let half_range_y = mask.size_y / 2;
    let half_range_x = mask.size_x / 2;

    for j in iterate(-half_range_y, half_range_y+1) {
        for i in iterate(-half_range_x, half_range_x+1) {
            let stencil_val = mask.data(j + half_range_y)(i + half_range_x);
            if stencil_val != 0.0f {
                let mut idx_x = acc.roi.o_x + acc.rox + x + i;
                let mut idx_y = acc.roi.o_y + acc.roy + y + j;

                // 0 --- 1 --- 2
                // 3 --- 4 --- 5
                // 6 --- 7 --- 8

                // left
                if acc.region == 0 { idx_x = mirror_lower(idx_x, acc.roi.o_x); }
                if acc.region == 3 { idx_x = mirror_lower(idx_x, acc.roi.o_x); }
                if acc.region == 6 { idx_x = mirror_lower(idx_x, acc.roi.o_x); }

                // right
                if acc.region == 2 { idx_x = mirror_upper(idx_x, acc.roi.o_x + acc.roi.width); }
                if acc.region == 5 { idx_x = mirror_upper(idx_x, acc.roi.o_x + acc.roi.width); }
                if acc.region == 8 { idx_x = mirror_upper(idx_x, acc.roi.o_x + acc.roi.width); }

                // top
                if acc.region == 0 { idx_y = mirror_lower(idx_y, acc.roi.o_y); }
                if acc.region == 1 { idx_y = mirror_lower(idx_y, acc.roi.o_y); }
                if acc.region == 2 { idx_y = mirror_lower(idx_y, acc.roi.o_y); }

                // bottom
                if acc.region == 6 { idx_y = mirror_upper(idx_y, acc.roi.o_y + acc.roi.height); }
                if acc.region == 7 { idx_y = mirror_upper(idx_y, acc.roi.o_y + acc.roi.height); }
                if acc.region == 8 { idx_y = mirror_upper(idx_y, acc.roi.o_y + acc.roi.height); }

                // all in
                if acc.region == 10 {
                    idx_x = mirror_lower(idx_x, acc.roi.o_x);
                    idx_x = mirror_upper(idx_x, acc.roi.o_x + acc.roi.width);
                    idx_y = mirror_upper(idx_y, acc.roi.o_y + acc.roi.height);
                    idx_y = mirror_lower(idx_y, acc.roi.o_y);
                }

                sum += acc.img.data(idx_y * acc.img.stride + idx_x) * stencil_val;
            } else {
                // additional logic for empty stencil value
            }
        }
    }

    sum
}


// Deriv 2D
fn deriv2D(RHS: Img, img: Img) -> () {
    let mask = Mask {
        data : [[0.0f,  1.0f, 0.0f],
                [1.0f, -4.0f, 1.0f],
                [0.0f,  1.0f, 0.0f]],
        size_x : 3, size_y : 3
    };
    for x, y, rhs_acc, img_acc, mask in @iteration(RHS, img, mask) {
        let val = apply_stencil(mask, img_acc, x, y);
        set_pixel(rhs_acc, x, y, val);
    }
}


// Jacobi
static omega = 0.8f;
static jacobi_mask = Mask {
    data : [[0.00f, 0.25f, 0.00f],
            [0.25f, 0.00f, 0.25f],
            [0.00f, 0.25f, 0.00f]],
    size_x : 3, size_y : 3
};
fn jacobi_solver(x: int, y: int, Sol: Acc, Tmp: Acc, RHS: Acc, mask: Mask) -> () {
    let val = (1.0f - omega) * get_pixel(Tmp, x, y) +
              0.25f * omega  * get_pixel(RHS, x, y) +
              apply_stencil(mask, Tmp, x, y);
    set_pixel(Sol, x, y, val);
}

fn jacobi(Sol: Img, Tmp: Img, RHS: Img, omega: float) -> () {
    for x, y, sol_acc, tmp_acc, mask in @iteration(Sol, Tmp, jacobi_mask) {
        // TODO: RHS is not mapped in iteration
        let rhs_acc = get_acc(RHS, 10);
        let val = (1.0f - omega) * get_pixel(tmp_acc, x, y) +
                  0.25f * omega  * get_pixel(rhs_acc, x, y) +
                  apply_stencil(mask, tmp_acc, x, y);
        set_pixel(sol_acc, x, y, val);
    }
}


// Residual
static residual_mask = Mask {
    data : [[0.0f,  1.0f, 0.0f],
            [1.0f, -4.0f, 1.0f],
            [0.0f,  1.0f, 0.0f]],
    size_x : 3, size_y : 3
};
fn residual_fun(x: int, y: int, Res: Acc, Sol: Acc, RHS: Acc, mask: Mask) -> () {
    let val = get_pixel(RHS, x, y) + apply_stencil(mask, Sol, x, y);
    set_pixel(Res, x, y, val);
}

fn residual(Res: Img, Sol: Img, RHS: Img) -> () {
    for x, y, res_acc, sol_acc, mask in @iteration(Res, Sol, residual_mask) {
        // TODO: RHS is not mapped in iteration
        let rhs_acc = get_acc(RHS, 10);
        let val = get_pixel(rhs_acc, x, y) +
                  apply_stencil(mask, sol_acc, x, y);
        set_pixel(res_acc, x, y, val);
    }
}


// Restrict: arr = size x size; out = size/2 x size/2; fine -> coarse
// coarse = Stencil * fine;
static restrict_mask = Mask {
    data : [[0.25f, 0.50f, 0.25f],
            [0.50f, 1.00f, 0.50f],
            [0.25f, 0.50f, 0.25f]],
    size_x : 3, size_y : 3
};
fn restrict_fun(x: int, y: int, RHS: Acc, Res: Acc, mask: Mask) -> () {
    let val = get_pixel(Res, 2*x,   2*y  ) +
              get_pixel(Res, 2*x+1, 2*y  ) +
              get_pixel(Res, 2*x,   2*y+1) +
              get_pixel(Res, 2*x+1, 2*y+1);
    set_pixel(RHS, x, y, val);
}

fn restrict(RHS: Img, Res: Img) -> () {
    for x, y, rhs_acc, res_acc, mask in @iteration(RHS, Res, restrict_mask) {
        let val = get_pixel(res_acc, 2*x,   2*y  ) +
                  get_pixel(res_acc, 2*x+1, 2*y  ) +
                  get_pixel(res_acc, 2*x,   2*y+1) +
                  get_pixel(res_acc, 2*x+1, 2*y+1);
        set_pixel(rhs_acc, x, y, val);
    }
}


// Interpolate: arr = size/2 x size/2; out = size x size; coarse -> fine
// fine += Stencil * coarse:
static interpolate_mask = Mask {
    data : [[0.25f, 0.50f, 0.25f],
            [0.50f, 1.00f, 0.50f],
            [0.25f, 0.50f, 0.25f]],
    size_x : 3, size_y : 3
};
fn interpolate_fun(x: int, y: int, SolF: Acc, SolC: Acc, mask: Mask) -> () {
    let value = get_pixel(SolC, x, y);
    set_pixel(SolF, 2*x  , 2*y  , get_pixel(SolF, 2*x  , 2*y  ) + value);
    set_pixel(SolF, 2*x+1, 2*y  , get_pixel(SolF, 2*x+1, 2*y  ) + value);
    set_pixel(SolF, 2*x  , 2*y+1, get_pixel(SolF, 2*x  , 2*y+1) + value);
    set_pixel(SolF, 2*x+1, 2*y+1, get_pixel(SolF, 2*x+1, 2*y+1) + value);
}

fn interpolate(SolF: Img, SolC: Img) -> () {
    // use iteration space of SolC, compute 4x elements
    for x, y, solc_acc, solf_acc, mask in @iteration(SolC, SolF, interpolate_mask) {
        let value = get_pixel(solc_acc, x, y);
        set_pixel(solf_acc, 2*x  , 2*y  , get_pixel(solf_acc, 2*x  , 2*y  ) + value);
        set_pixel(solf_acc, 2*x+1, 2*y  , get_pixel(solf_acc, 2*x+1, 2*y  ) + value);
        set_pixel(solf_acc, 2*x  , 2*y+1, get_pixel(solf_acc, 2*x  , 2*y+1) + value);
        set_pixel(solf_acc, 2*x+1, 2*y+1, get_pixel(solf_acc, 2*x+1, 2*y+1) + value);
    }
}


// L2 norm
fn l2norm(img : Img) -> float {
    // TODO: runs only on the CPU atm
    let mut l2sum = 0.0f;
    for y in $iterate(0, img.height) {
        for x in $iterate(0, img.width) {
            let value = img.data(y * img.stride + x);
            l2sum += value*value;
        }
    }
    sqrtf(l2sum)/(img.width*img.height as float)
}


// normal V-Cycle, components are hard-coded
fn vcycle(RHS0 : Img, levels : int, vsteps : int, ssteps : int) -> Img {
    let width   = RHS0.width;
    let height  = RHS0.height;
    let mut RHS = ~[levels:Img];
    let mut Sol = ~[levels:Img];
    let mut Tmp = ~[levels:Img];
    let mut Res = ~[levels:Img];
    for level in range(0, levels) {
        fn init_img(level : int) -> Img {
            Img {
                data : ~[(width >> level) * (height >> level): float],
                width : width >> level,
                height : height >> level,
                stride : width >> level
            }
        }
        if level == 0 {
            RHS(level) = RHS0;
        } else {
            RHS(level) = init_img(level);
        }
        Sol(level) = init_img(level);
        Res(level) = init_img(level);
        Tmp(level) = init_img(level);
        $init_zero(Tmp(level).data, Tmp(level).stride, Tmp(level).height);
    }

    fn vcycle_intern(level : int) -> () {
        if level == levels-1 {
            for i in range(0, ssteps) {
                // smooth
                if i>0 { let tmp = Sol(level); Sol(level) = Tmp(level); Tmp(level) = tmp; }
                jacobi(Sol(level), Tmp(level), RHS(level), omega);
            }
        } else {
            // pre-smooth
            for i in range(0, ssteps) {
                if i>0 { let tmp = Sol(level); Sol(level) = Tmp(level); Tmp(level) = tmp; }
                jacobi(Sol(level), Tmp(level), RHS(level), omega);
            }

            residual(Res(level), Sol(level), RHS(level));
            restrict(RHS(level+1), Res(level));

            //if level == 0 { thorin_print_gflops(l2norm(Res(level))); }

            $init_zero(Tmp(level+1).data, Tmp(level+1).stride, Tmp(level+1).height);
            vcycle_intern(level+1);

            interpolate(Sol(level), Sol(level+1));

            // post-smooth
            for i in range(0, ssteps) {
                if i>0 { let tmp = Sol(level); Sol(level) = Tmp(level); Tmp(level) = tmp; }
                jacobi(Sol(level), Tmp(level), RHS(level), omega);
            }
        }
    }
    for i in range(0, vsteps) {
        vcycle_intern(0);
    }

    Sol(0)
}


// V-Cycle DSL: solver, etc. can be provided by the user
fn vcycle_dsl(RHS0 : Img, levels : int, vsteps : int, ssteps : int,
          solver : fn(int, int, Acc, Acc, Acc, Mask) -> (), solver_mask : Mask,
          residual : fn(int, int, Acc, Acc, Acc, Mask) -> (), residual_mask : Mask,
          restrict : fn(int, int, Acc, Acc, Mask) -> (), restrict_mask : Mask,
          interpolate : fn(int, int, Acc, Acc, Mask) -> (), interpolate_mask : Mask
         ) -> Img {
    let width   = RHS0.width;
    let height  = RHS0.height;
    let mut RHS = ~[levels:Img];
    let mut Sol = ~[levels:Img];
    let mut Tmp = ~[levels:Img];
    let mut Res = ~[levels:Img];
    for level in range(0, levels) {
        fn init_img(level : int) -> Img {
            Img {
                data : ~[(width >> level) * (height >> level): float],
                width : width >> level,
                height : height >> level,
                stride : width >> level
            }
        }
        if level == 0 {
            RHS(level) = RHS0;
        } else {
            RHS(level) = init_img(level);
        }
        Sol(level) = init_img(level);
        Res(level) = init_img(level);
        Tmp(level) = init_img(level);
        $init_zero(Tmp(level).data, Tmp(level).stride, Tmp(level).height);
    }

    fn vcycle_dsl_intern(level : int) -> () {
        let rhs_acc = get_acc(RHS(level), 4);
        if level == levels-1 {
            for i in range(0, ssteps) {
                // smooth
                if i>0 { let tmp = Sol(level); Sol(level) = Tmp(level); Tmp(level) = tmp; }
                for x, y, sol_acc, tmp_acc, mask in iteration(Sol(level), Tmp(level), solver_mask) {
                    solver(x, y, sol_acc, tmp_acc, rhs_acc, mask);
                }
            }
        } else {
            // pre-smooth
            for i in range(0, ssteps) {
                if i>0 { let tmp = Sol(level); Sol(level) = Tmp(level); Tmp(level) = tmp; }
                for x, y, sol_acc, tmp_acc, mask in iteration(Sol(level), Tmp(level), solver_mask) {
                    solver(x, y, sol_acc, tmp_acc, rhs_acc, mask);
                }
            }

            let merge = true;
            if merge == true {
                iteration_merge(RHS(level+1), Sol(level), RHS(level), residual, residual_mask, restrict, restrict_mask);
            } else {
                for x, y, res_acc, sol_acc, mask in iteration(Res(level), Sol(level), residual_mask) {
                    residual(x, y, res_acc, sol_acc, rhs_acc, mask);
                }

                for x, y, rhs_acc, res_acc, mask in iteration(RHS(level+1), Res(level), residual_mask) {
                    restrict(x, y, rhs_acc, res_acc, mask);
                }
            }

            //if level == 0 { thorin_print_gflops(l2norm(Res(level))); }

            $init_zero(Tmp(level+1).data, Tmp(level+1).stride, Tmp(level+1).height);
            vcycle_dsl_intern(level+1);

            // use iteration space of SolC, compute 4x elements
            for x, y, solc_acc, solf_acc, mask in iteration(Sol(level+1), Sol(level), interpolate_mask) {
                interpolate(x, y, solf_acc, solc_acc, mask);
            }

            // post-smooth
            for i in range(0, ssteps) {
                if i>0 { let tmp = Sol(level); Sol(level) = Tmp(level); Tmp(level) = tmp; }
                for x, y, sol_acc, tmp_acc, mask in iteration(Sol(level), Tmp(level), solver_mask) {
                    solver(x, y, sol_acc, tmp_acc, rhs_acc, mask);
                }
            }
        }
    }
    for i in range(0, vsteps) {
        vcycle_dsl_intern(0);
    }

    Sol(0)
}


extern
fn thorin_vcycle(img_data : &[float], out_data : &[float], width : int, height : int) -> () {
    let RHS     = Img { data : ~[width * height: float], width : width, height : height, stride : width };
    let mut img = Img { data : ~[width * height: float], width : width, height : height, stride : width };
    let mut out = Img { data : out_data , width : width, height : height, stride : width };

    for y in range(0, img.height) {
        for x in range(0, img.width) {
            img.data(y*img.stride + x) = img_data(y*img.width + x);
        }
    }

    @deriv2D(RHS, img);

    let levels = 3;
    let vsteps = 1;
    let ssteps = 2;

    //let result = @vcycle_dsl(RHS, levels, vsteps, ssteps, jacobi_solver, jacobi_mask, residual_fun, residual_mask, restrict_fun, restrict_mask, interpolate_fun, interpolate_mask);
    let result = @vcycle(RHS, levels, vsteps, ssteps);

    for y in range(0, out.height) {
        for x in range(0, out.width) {
            out.data(y*out.width + x) = result.data(y*result.stride + x);
        }
    }
}

