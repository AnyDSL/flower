fn iteration_merge(Sol : Img, Res : Img, RHSF : Img, RHSC : Img,
                   residual : fn(int, int, Mask, Acc, Acc, Acc) -> (), residual_mask : Mask, // RHS + sum(Sol) -> Res
                   restrict : fn(int, int, Mask, Acc, Acc) -> (), restrict_mask : Mask       // Res -> RHS(+1)
                  ) -> () {
    // allocate temporary array
    let tmp = Img { data : ~[Res.stride*(2+pad_y/2):float], width : Res.width, height : 2+pad_y/2, stride : Res.stride };
    $init_zero(tmp.data, tmp.stride, tmp.height);
    let tmp_acc  = get_acc(tmp, 4);

    for benchmark() {
        for y in $iterate_step(0, Res.height, 2) {
            for x in $inner_loop(0, Res.width) {
                // index space: cache line
                let rhsf_acc = Acc { img : RHSF, roi : RoI { o_x : 0, o_y : 0, width : RHSF.width, height : RHSF.height }, rox : 0, roy : y, region : 4 };
                let sol_acc  = Acc { img : Sol,  roi : RoI { o_x : 0, o_y : 0, width : Sol.width,  height : Sol.height },  rox : 0, roy : y, region : 4 };
                @residual(x, 0, residual_mask, sol_acc, tmp_acc, rhsf_acc);
                @residual(x, 1, residual_mask, sol_acc, tmp_acc, rhsf_acc);
            }
            for x in $iterate(0, RHSC.width) {
                // index space: cache line
                let out_acc = Acc { img : RHSC, roi : RoI { o_x : 0, o_y : 0, width : RHSC.width, height : RHSC.height}, rox : 0, roy : y/2, region : 4 };
                @restrict(x, 0, restrict_mask, tmp_acc, out_acc);
            }
        }
    }
}
