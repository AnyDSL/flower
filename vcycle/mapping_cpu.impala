fn iteration_merge(RHSC: Img, Sol: Img, RHSF: Img,
                   residual: fn(i32, i32, Acc, Acc, Acc, Mask) -> (), residual_mask: Mask, // RHS + sum(Sol) -> Res
                   restrict: fn(i32, i32, Acc, Acc, Mask) -> (), restrict_mask: Mask       // Res -> RHS(+1)
                  ) -> () {
    let unroll = 1;
    let step   = 2; // restrict by 2x
    let bhy = round_up(residual_mask.size_y / 2, step * unroll);
    let bhx = round_up(residual_mask.size_x / 2, get_vector_length());

    // allocate temporary array
    let tmp = get_img(alloc_host(Sol.stride * step * unroll * 4), Sol.stride, step * unroll);
    $init_zero(tmp.buf.data as &[f32], tmp.stride, tmp.height);

    let Bounds2DCol = [
        (0               , bhy),
        (bhy             , Sol.height - bhy),
        (Sol.height - bhy, Sol.height)
    ];

    let Bounds2DRow = [
        (0              , bhx),
        (bhx            , Sol.width - bhx),
        (Sol.width - bhx, Sol.width)
    ];

    for benchmark_cpu() {
        for iter_col in @range(0, 3) {
            let bounds_col = Bounds2DCol(iter_col);
            //let outer_col  = if iter_col == 1 { outer_loop_step } else { range_step };
            // gets slower when computed in parallel
            let tmp_acc    = get_acc(tmp, 4 /* no bh */);
            for y in $range_step(bounds_col(0), bounds_col(1), step * unroll) @{
                // residual: index space == cache line
                for iter_row in range(0, 3) {
                    let bounds_row = Bounds2DRow(iter_row);
                    let inner_row  = if iter_row == 1 { inner_loop } else { range };
                    for yi in range(0, step * unroll) {
                        for x in $inner_row(bounds_row(0), bounds_row(1)) @{
                            let region   = Region2D(3 * iter_col + iter_row);
                            let rhsf_acc = Acc { img : RHSF, roi : RoI { o_x : 0, o_y : 0, width : RHSF.width, height : RHSF.height }, rox : 0, roy : y, region : region };
                            let sol_acc  = Acc { img : Sol,  roi : RoI { o_x : 0, o_y : 0, width : Sol.width,  height : Sol.height },  rox : 0, roy : y, region : region };
                            residual(x, yi, tmp_acc, sol_acc, rhsf_acc, residual_mask);
                        }
                    }
                }
                // restrict: index space == cache line
                for yi in range(0, unroll) {
                    let rhsc_acc = Acc { img : RHSC, roi : RoI { o_x : 0, o_y : 0, width : RHSC.width, height : RHSC.height }, rox : 0, roy : y/step + yi, region : 4 /* no bh */ };
                    for x in $range(0, RHSC.width) @{
                        restrict(x, yi, rhsc_acc, tmp_acc, restrict_mask);
                    }
                }
            }
        }
    }

    release(tmp.buf);
}
