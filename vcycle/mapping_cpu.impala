fn iteration_merge(RHSC: Img, Sol: Img, RHSF: Img,
                   residual: fn(int, int, Acc, Acc, Acc, Mask) -> (), residual_mask: Mask, // RHS + sum(Sol) -> Res
                   restrict: fn(int, int, Acc, Acc, Mask) -> (), restrict_mask: Mask       // Res -> RHS(+1)
                  ) -> () {
    // allocate temporary array
    let tmp = Img { data : ~[Sol.stride*2:float], width : Sol.width, height : 2, stride : Sol.stride };
    $init_zero(tmp.data, tmp.stride, tmp.height);

    // compute the number of vector strides for boundary handling
    let step_size = 2;
    let bhy = round_up(residual_mask.size_y / 2, step_size);
    let bhx = round_up(residual_mask.size_x / 2, get_vector_length());

    // (minx, maxx, miny, maxy)
    let width  = Sol.width;
    let height = Sol.height;
    let Bounds2D = [
        (0          , bhx        , 0           , bhy),
        (bhx        , width - bhx, 0           , bhy),
        (width - bhx, width      , 0           , bhy),

        (0          , bhx        , bhy         , height - bhy),
        (bhx        , width - bhx, bhy         , height - bhy),
        (width - bhx, width      , bhy         , height - bhy),

        (0          , bhx        , height - bhy, height),
        (bhx        , width - bhx, height - bhy, height),
        (width - bhx, width      , height - bhy, height)
    ];

    for benchmark() {
        for iter in @range(0, 9) {
            let bounds  = Bounds2D(iter);
            let region  = Region2D(iter);
            let tmp_acc = get_acc(tmp, 4 /* no bh */);

            for y in $range_step(bounds(2), bounds(3), step_size) @{
                // residual: index space == cache line
                let rhsf_acc = Acc { img : RHSF, roi : RoI { o_x : 0, o_y : 0, width : RHSF.width, height : RHSF.height }, rox : 0, roy : y,   region : region };
                let sol_acc  = Acc { img : Sol,  roi : RoI { o_x : 0, o_y : 0, width : Sol.width,  height : Sol.height },  rox : 0, roy : y,   region : region };
                for x in $inner_loop(bounds(0), bounds(1)) @{
                    residual(x, 0, tmp_acc, sol_acc, rhsf_acc, residual_mask);
                    residual(x, 1, tmp_acc, sol_acc, rhsf_acc, residual_mask);
                }
                // restrict: index space == cache line
                let rhsc_acc = Acc { img : RHSC, roi : RoI { o_x : 0, o_y : 0, width : RHSC.width, height : RHSC.height }, rox : 0, roy : y/2, region : 4 /* no bh */ };
                for x in $range(0, RHSC.width) @{
                    restrict(x, 0, rhsc_acc, tmp_acc, restrict_mask);
                }
            }
        }
    }
}
