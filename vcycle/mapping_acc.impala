fn iteration_merge(RHSC: Img, Sol: Img, RHSF: Img,
                   bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32,
                   residual: fn(i32, i32, Acc, Acc, Acc, Mask) -> (), residual_mask: Mask, // RHS + sum(Sol) -> Res
                   restrict: fn(i32, i32, Acc, Acc, Mask) -> (), restrict_mask: Mask       // Res -> RHS(+1)
                  ) -> () {
    let sol_gpu  = get_img(acc_alloc(acc_dev(), Sol.stride  * Sol.height  * 4), Sol.width,  Sol.height);
    let rhsf_gpu = get_img(acc_alloc(acc_dev(), RHSF.stride * RHSF.height * 4), RHSF.width, RHSF.height);
    let rhsc_gpu = get_img(acc_alloc(acc_dev(), RHSC.stride * RHSC.height * 4), RHSC.width, RHSC.height);
    copy(RHSF.buf, rhsf_gpu.buf, rhsf_gpu.width * rhsf_gpu.height * 4);
    copy(Sol.buf,  sol_gpu.buf,  sol_gpu.width  * sol_gpu.height  * 4);

    let step  = 2; // restrict by 2x
    let grid  = (Sol.width, Sol.height, 1);
    let block = (64, step, 1);

    for benchmark_acc() {
        with acc(acc_dev(), grid, block) @{
            let tid_x = acc_tidx();
            let tid_y = acc_tidy();
            let gid_y = acc_gidy();

            let spm_stride = block(0);
            let spm_height = block(1);
            let spm = reserve_shared_f32(spm_stride * spm_height);

            // residual: index space == block
            let tmp_acc  = get_write_acc_shared(spm, spm_stride, spm_height);
            let rhsf_acc = get_read_acc_offset(rhsf_gpu, acc_bdimx() * acc_bidx(), acc_bdimy() * acc_bidy(), 4 /* no bh */, nobh_center, nobh_center);
            let sol_acc  = get_read_acc_offset(sol_gpu,  acc_bdimx() * acc_bidx(), acc_bdimy() * acc_bidy(), 10  /* all */, bh_lower, bh_upper);
            residual(tid_x, tid_y, tmp_acc, sol_acc, rhsf_acc, residual_mask);

            acc_barrier();

            // restrict: index space == block
            if tid_x < block(0) / step && gid_y % step == 0 @{
                let tmp_acc = get_read_acc_shared(spm, spm_stride, spm_height);
                let rhs_acc = get_write_acc_offset(rhsc_gpu, acc_bdimx() * acc_bidx()/step, acc_bdimy() * acc_bidy()/step);
                restrict(tid_x, tid_y, rhs_acc, tmp_acc, restrict_mask);
            }
        }
    }

    copy(rhsc_gpu.buf, RHSC.buf, rhsc_gpu.width * rhsc_gpu.height * 4);
    release(sol_gpu.buf);
    release(rhsf_gpu.buf);
    release(rhsc_gpu.buf);
}
