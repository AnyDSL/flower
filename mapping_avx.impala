fn iteration(width : int, height : int,
             arr : &[float], out : &[float],
             body : fn(int, int, &[float], &[float]) -> ()
            ) -> () {
    let L = 8;
    getMicroTime();
    for y in $iterate(0, height) {
        vectorized(width, L, || -> () {
            let x = wfv_get_tid();
            body(x, y, arr, out);
        });
    }
    getMicroTime();
}

fn iteration_bounds(width : int, height : int, ksize : int,
                    arr : &[float], out : &[float],
                    body : fn(int, int, &[float], &[float], int) -> ()
                   ) -> () {
    let L = 8;

    // compute the number of vector strides for boundary handling
    let bhy = ksize / 2;
    let bhx = if ((ksize/2) % L==0) {
                (ksize/2) / L
              } else {
                (ksize/2) / L + L
              };

    // (minx, maxx, miny, maxy)
    let Bounds2D = [
        (0          , bhx        , 0           , bhy),
        (bhx        , width - bhx, 0           , bhy),
        (width - bhx, width      , 0           , bhy),

        (0          , bhx        , bhy         , height - bhy),
        (bhx        , width - bhx, bhy         , height - bhy),
        (width - bhx, width      , bhy         , height - bhy),

        (0          , bhx        , height - bhy, height),
        (bhx        , width - bhx, height - bhy, height),
        (width - bhx, width      , height - bhy, height)
    ];

    getMicroTime();
    for region in iterate(0, 9) {
        let bounds = Bounds2D(region);
        let dim = (bounds(1) - bounds(0), bounds(3) - bounds(2), 1);

        for y in $iterate(bounds(2), bounds(3)) {
            vectorized(bounds(1)-bounds(0), L, || -> () {
                let x = wfv_get_tid();
                body(x, y, arr, out, region);
            });
        }
    }
    getMicroTime();
}

fn iteration_sep(width : int, height : int,
                 arr : &[float], out : &[float],
                 body : fn(int, int, &[float], &[float], bool) -> ()
                ) -> () {
    // allocate temporary array
    let mut tmp = ~[width*height:float];
    init_zero(tmp, $width, $height);

    getMicroTime();
    for y in $iterate(0, height) {
        for x in $iterate(0, width) {
            let is_row = false;
            body(x, y, arr, tmp, is_row);
        }
    }

    for y in $iterate(0, height) {
        for x in $iterate(0, width) {
            let is_row = true;
            body(x, y, tmp, out, is_row);
        }
    }
    getMicroTime();
}

fn iteration_sep_advanced(width : int, height : int,
                          arr : &[float], out : &[float],
                          body_col : fn(int, int, &[float], &[float]) -> (),
                          body_row : fn(int, int, &[float], &[float]) -> ()
                         ) -> () {
    let mut tmp = ~[width*1:float];

    getMicroTime();
    for y in $iterate(0, height) {
        for x in $iterate(0, width) {
            body_col(x, y, arr, tmp);
        }
        for x in $iterate(0, width) {
            body_row(x, y, tmp, out);
        }
    }
    getMicroTime();
}
