// odd-even merge sort works only for power of two
fn oddeven_merge_sort(length: int, mut arr: [float * 4]) -> () {
    fn compare_and_swap(i: int, j: int) -> () {
        //thorin_print_int(i); thorin_print_string(", ");
        //thorin_print_int(j); thorin_print_string("\n");
        if arr(i) > arr(j) {
            let tmp = arr(i);
            arr(i) = arr(j);
            arr(j) = tmp;
        }
    }

    fn oddeven_merge(lo: int, n: int, r: int) -> () {
        let m = r * 2;
        if m < n {
            oddeven_merge(lo, n, m);        // even subsequence
            oddeven_merge(lo + r, n, m);    // odd subsequence
            for i in range_step(lo + r, lo + n - r, m) {
                compare_and_swap(i, i + r);
            }
        } else {
            compare_and_swap(lo, lo + r);
        }
    }

    fn oddeven_merge_sort_range(lo: int, n: int) -> () {
        if n > 1 {
            let m = n / 2;
            oddeven_merge_sort_range(lo, m);
            oddeven_merge_sort_range(lo + m, m);
            oddeven_merge(lo, n, 1);
        }
    }

    oddeven_merge_sort_range(0, length);
}

extern
fn test_main(input: &[float]) -> float {
    let length = 4;

    fn median() -> float {
        let mut arr: [float * 4];
        for i in range(0, length) {
            arr(i) = input(i);
        }

        oddeven_merge_sort(length, arr);
        print_total_timing();

        // return median
        arr((length - 1) / 2)
    }
    @median()
}
