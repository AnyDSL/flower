type Mask = Mask5;
type MaskSep = Mask5Sep;

fn apply_stencil(x: i32, y: i32, acc: Acc, mask: Mask,
                 bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32
                ) -> f32 {
    let mut sum = 0.0f;
    let half_range_y = mask.size_y / 2;
    let half_range_x = mask.size_x / 2;

    for j in range(-half_range_y, half_range_y+1) {
        for i in range(-half_range_x, half_range_x+1) {
            let stencil_val = mask.data(j + half_range_y)(i + half_range_x);
            if stencil_val != 0.0f {
                sum += get_pixel(acc, x + i, y + j, bh_lower, bh_upper) * stencil_val;
            } else {
                // additional logic for empty stencil value
            }
        }
    }

    sum
}
fn apply_stencil_sep(x: i32, y: i32, acc: Acc, mask: MaskSep, row: bool,
                     bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32
                    ) -> f32 {
    let mut sum = 0.0f;
    let half_range = mask.size / 2;
    for i in range(-half_range, half_range+1) {
        let stencil_val = mask.data(i + half_range);
        if stencil_val != 0.0f {
            if row {
                sum += get_pixel(acc, x + i, y, bh_lower, bh_upper) * stencil_val;
            } else {
                sum += get_pixel(acc, x, y + i, bh_lower, bh_upper) * stencil_val;
            }
        } else {
            // additional logic for empty stencil value
        }
    }

    sum
}


fn main() -> i32 {
    let width  = 4096;
    let height = 4096;
    let arr    = Img { buf : alloc_host(width * height * 4), width : width, height : height, stride : width };
    let out    = Img { buf : alloc_host(width * height * 4), width : width, height : height, stride : width };
    init_rand(arr.buf.data as &[f32], arr.stride, out.height);
    init_zero(out.buf.data as &[f32], out.stride, out.height);

    let mask_sep = MaskSep {
        data : [ 0.070766f, 0.244460f, 0.369546f, 0.244460f, 0.070766f ],
        size : 5
    };

    let mask = Mask {
        data : [[ 0.005008f, 0.017300f, 0.026151f, 0.017300f, 0.005008f ],
                [ 0.017300f, 0.059761f, 0.090339f, 0.059761f, 0.017300f ],
                [ 0.026151f, 0.090339f, 0.136565f, 0.090339f, 0.026151f ],
                [ 0.017300f, 0.059761f, 0.090339f, 0.059761f, 0.017300f ],
                [ 0.005008f, 0.017300f, 0.026151f, 0.017300f, 0.005008f ]],
        size_x : 5, size_y : 5
    };

    //let lower = wrap_const_fun(const_lower, 0.0f);
    //let upper = wrap_const_fun(const_upper, 0.0f);
    let lower = clamp_lower;
    let upper = clamp_upper;

    let sep = true;

    if sep {
        let iteration_sep_fun = iteration_sep;          // SEP + SS
        //let iteration_sep_fun = iteration_sep_bounds;   // SEP + SS + BH
        //let iteration_sep_fun = iteration_sep_advanced; // SEP + SS + SM

        for x, y, mut out_acc, arr_acc, mask, is_row in @iteration_sep_fun(out, arr, mask_sep, mask_sep) {
            (out_acc.img.buf.data as &[f32])((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = apply_stencil_sep(x, y, arr_acc, mask, is_row, lower, upper);
        }
    } else {
        let iteration_fun = iteration;                  // SS
        //let iteration_fun = iteration_bounds;           // SS + BH
        //let iteration_fun = iteration_advanced;         // SS + SM

        for x, y, mut out_acc, arr_acc, mask in @iteration_fun(out, arr, mask) {
            (out_acc.img.buf.data as &[f32])((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = apply_stencil(x, y, arr_acc, mask, lower, upper);
        }
    }
    print_total_timing();

    fn reference() -> i32 {
        let mut passed = 0;
        let arr_acc = get_acc(arr, 10);
        for y in $range(0, out.height) {
            for x in $range(0, out.width) @{
                let ref = apply_stencil(x, y, arr_acc, mask, lower, upper);
                let mut diff = ref - (out.buf.data as &[f32])(y*out.stride + x);
                if diff < 0.0f  { diff = -diff; }
                if diff > 0.01f { passed = 42; }
            }
        }
        passed
    }

    let result = @reference();

    release(arr.buf);
    release(out.buf);

    result
}
