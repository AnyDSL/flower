type Mask = Mask5;
type MaskSep = Mask5Sep;

fn get_pixel_(acc: Acc, x: int, y: int,
              bh_lower: fn(int, int, fn(f32)) -> int, bh_upper: fn(int, int, fn(f32)) -> int
             ) -> float {
    let mut idx_x = acc.roi.o_x + acc.rox + x;
    let mut idx_y = acc.roi.o_y + acc.roy + y;

    // 0 --- 1 --- 2
    // 3 --- 4 --- 5
    // 6 --- 7 --- 8
    // left
    if acc.region == 0 { idx_x = bh_lower(idx_x, acc.roi.o_x, return); }
    if acc.region == 3 { idx_x = bh_lower(idx_x, acc.roi.o_x, return); }
    if acc.region == 6 { idx_x = bh_lower(idx_x, acc.roi.o_x, return); }

    // right
    if acc.region == 2 { idx_x = bh_upper(idx_x, acc.roi.o_x + acc.roi.width, return); }
    if acc.region == 5 { idx_x = bh_upper(idx_x, acc.roi.o_x + acc.roi.width, return); }
    if acc.region == 8 { idx_x = bh_upper(idx_x, acc.roi.o_x + acc.roi.width, return); }

    // top
    if acc.region == 0 { idx_y = bh_lower(idx_y, acc.roi.o_y, return); }
    if acc.region == 1 { idx_y = bh_lower(idx_y, acc.roi.o_y, return); }
    if acc.region == 2 { idx_y = bh_lower(idx_y, acc.roi.o_y, return); }

    // bottom
    if acc.region == 6 { idx_y = bh_upper(idx_y, acc.roi.o_y + acc.roi.height, return); }
    if acc.region == 7 { idx_y = bh_upper(idx_y, acc.roi.o_y + acc.roi.height, return); }
    if acc.region == 8 { idx_y = bh_upper(idx_y, acc.roi.o_y + acc.roi.height, return); }

    // all in
    if acc.region == 10 {
        idx_x = bh_lower(idx_x, acc.roi.o_x, return);
        idx_x = bh_upper(idx_x, acc.roi.o_x + acc.roi.width, return);
        idx_y = bh_upper(idx_y, acc.roi.o_y + acc.roi.height, return);
        idx_y = bh_lower(idx_y, acc.roi.o_y, return);
    }
    acc.img.data((acc.roi.o_y + acc.roy + y)*acc.img.stride + acc.roi.o_x + acc.rox + x)
}
fn get_pixel(acc: Acc, x: int, y: int,
             bh_lower: fn(int, int) -> int, bh_upper: fn(int, int) -> int
            ) -> float {
    get_pixel_(acc, x, y, |i, j, _| bh_lower(i, j), |i, j, _| bh_upper(i, j))
}

fn apply_stencil(x: int, y: int, acc: Acc, mask: Mask) -> float {
    let mut sum = 0.0f;
    let half_range_y = mask.size_y / 2;
    let half_range_x = mask.size_x / 2;

    /*
    fn c_lower(idx: int, lower: int) -> int { const_lower(idx, lower, 0.0f, return) }
    fn c_upper(idx: int, upper: int) -> int { const_lower(idx, upper, 0.0f, return) }
    */

    for j in iterate(-half_range_y, half_range_y+1) {
        for i in iterate(-half_range_x, half_range_x+1) {
            let stencil_val = mask.data(j + half_range_y)(i + half_range_x);
            if stencil_val != 0.0f {
                sum += get_pixel(acc, x + i, y + j, clamp_lower, clamp_upper) * stencil_val;
            } else {
                // additional logic for empty stencil value
            }
        }
    }

    sum
}
fn apply_stencil_sep(x: int, y: int, acc: Acc, mask: MaskSep, row: bool) -> float {
    let mut sum = 0.0f;
    let half_range = mask.size / 2;
    for i in iterate(-half_range, half_range+1) {
        let stencil_val = mask.data(i + half_range);
        if row {
            sum += get_pixel(acc, x + i, y, clamp_lower, clamp_upper) * stencil_val;
        } else {
            sum += get_pixel(acc, x, y + i, clamp_lower, clamp_upper) * stencil_val;
        }
    }

    sum
}


fn main() -> int {
    let width  = 4096;
    let height = 4096;
    let arr    = Img { data : ~[width*height:float], width : width, height : height, stride : width };
    let out    = Img { data : ~[width*height:float], width : width, height : height, stride : width };
    init_rand(arr.data, arr.stride, out.height);
    init_zero(out.data, out.stride, out.height);

    let mask_sep = MaskSep {
        data : [ 0.070766f, 0.244460f, 0.369546f, 0.244460f, 0.070766f ],
        size : 5
    };

    let mask = Mask {
        data : [[ 0.005008f, 0.017300f, 0.026151f, 0.017300f, 0.005008f ],
                [ 0.017300f, 0.059761f, 0.090339f, 0.059761f, 0.017300f ],
                [ 0.026151f, 0.090339f, 0.136565f, 0.090339f, 0.026151f ],
                [ 0.017300f, 0.059761f, 0.090339f, 0.059761f, 0.017300f ],
                [ 0.005008f, 0.017300f, 0.026151f, 0.017300f, 0.005008f ]],
        size_x : 5, size_y : 5
    };


    //// SS
    //for x, y, mut out_acc, arr_acc, mask in @iteration(out, arr, mask) {
    //    out_acc.img.data((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = apply_stencil(x, y, arr_acc, mask);
    //}

    //// SS + BH
    //for x, y, mut out_acc, arr_acc, mask in @iteration_bounds(out, arr, mask) {
    //    out_acc.img.data((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = apply_stencil(x, y, arr_acc, mask);
    //}

    //// SS + SM
    //for x, y, mut out_acc, arr_acc, mask in @iteration_advanced(out, arr, mask) {
    //    out_acc.img.data((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = apply_stencil(x, y, arr_acc, mask);
    //}


    //// SEP + SS
    //for x, y, mut out_acc, arr_acc, mask, is_row in @iteration_sep(out, arr, mask_sep) {
    //    out_acc.img.data((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = apply_stencil_sep(x, y, arr_acc, mask, is_row);
    //}

    // SEP + SS + BH
    for x, y, mut out_acc, arr_acc, mask, is_row in @iteration_sep_bounds(out, arr, mask_sep) {
        out_acc.img.data((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = apply_stencil_sep(x, y, arr_acc, mask, is_row);
    }

    //// SEP + SS + SM
    //for x, y, mut out_acc, arr_acc, mask, is_row in @iteration_sep_advanced(out, arr, mask_sep) {
    //    out_acc.img.data((out_acc.roi.o_y + out_acc.roy + y)*out_acc.img.stride + out_acc.roi.o_x + out_acc.rox + x) = apply_stencil_sep(x, y, arr_acc, mask, is_row);
    //}


    fn reference() -> int {
        let mut passed = 0;
        let arr_acc = get_acc(arr, 10);
        for y in $iterate(0, out.height) {
            for x in $iterate(0, out.width) {
                let ref = @apply_stencil(x, y, arr_acc, mask);
                let mut diff = ref - out.data(y*out.stride + x);
                if diff < 0.0f  { diff = -diff; }
                if diff > 0.01f { passed = 42; }
            }
        }
        passed
    }
    @reference()
}
