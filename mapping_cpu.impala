fn iteration(width : int, height : int,
             arr : &[float], out : &[float],
             body : fn(int, int, &[float], &[float]) -> ()
            ) -> () {
    getMicroTime();
    for y in $iterate(0, height) {
        for x in $iterate(0, width) {
            body(x, y, arr, out);
        }
    }
    getMicroTime();
}

fn iteration_bounds(width : int, height : int, ksize : int,
                    arr : &[float], out : &[float],
                    body : fn(int, int, &[float], &[float], int) -> ()
                   ) -> () {
    let bbh = ksize / 2;
    // (minx, maxx, miny, maxy)
    let Bounds2D = [
        (0          , bbh        , 0         , bbh),
        (bbh        , width - bbh, 0         , bbh),
        (width - bbh, width      , 0         , bbh),

        (0          , bbh        , height - bbh, height),
        (bbh        , width - bbh, height - bbh, height),
        (width - bbh, width      , height - bbh, height),

        (0          , bbh        , bbh         , height - bbh),
        (width - bbh, width      , bbh         , height - bbh),
        (bbh        , width - bbh, bbh         , height - bbh)
    ];

    for region in iterate(0, 9) {
        let bounds = Bounds2D[region];
        for y in $iterate(bounds(2), bounds(3)) {
            for x in $iterate(bounds(0), bounds(1)) {
                body(x, y, arr, out, region);
            }
        }
    }
}

fn iteration_sep(width : int, height : int,
                 arr : &[float], out : &[float],
                 body_col : fn(int, int, &[float], &[float]) -> (),
                 body_row : fn(int, int, &[float], &[float]) -> ()
                ) -> () {
    // allocate temporary array
    let mut tmp = ~[width*height:float];
    init_zero(tmp, $width, $height);

    getMicroTime();
    for y in $iterate(0, height) {
        for x in $iterate(0, width) {
            body_col(x, y, arr, tmp);
        }
    }

    for y in $iterate(0, height) {
        for x in $iterate(0, width) {
            body_row(x, y, tmp, out);
        }
    }
    getMicroTime();
}

fn iteration_sep_bounds(width : int, height : int, ksize : int,
                        arr : &[float], out : &[float],
                        body_col : fn(int, int, &[float], &[float], int) -> (),
                        body_row : fn(int, int, &[float], &[float], int) -> ()
                       ) -> () {
    // allocate temporary array
    let mut tmp = ~[width*height:float];
    init_zero(tmp, $width, $height);

    let bbh = ksize / 2;

    let Bounds2DCol = [
        (0           , bbh),
        (bbh         , height - bbh),
        (height - bbh, height)
    ];

    let Bounds2DRow = [
        (0          , bbh),
        (bbh        , width - bbh),
        (width - bbh, width)
    ];

    getMicroTime();
    for region in iterate(0, 3) {
        let bounds = Bounds2DCol[region];
        for y in $iterate(bounds(0), bounds(1)) {
            for x in $iterate(0, width) {
                body_col(x, y, arr, tmp, region);
            }
        }
    }

    for region in iterate(0, 3) {
        let bounds = Bounds2DRow[region];
        for y in $iterate(0, height) {
            for x in $iterate(bounds(0), bounds(1)) {
                body_row(x, y, tmp, arr, region);
            }
        }
    }
    getMicroTime();
}


fn iteration_sep_advanced(width : int, height : int,
                          arr : &[float], out : &[float],
                          body_col : fn(int, int, &[float], &[float]) -> (),
                          body_row : fn(int, int, &[float], &[float]) -> ()
                         ) -> () {
    let mut tmp = ~[width*1:float];

    getMicroTime();
    for y in $iterate(0, height) {
        for x in $iterate(0, width) {
            body_col(x, y, arr, tmp);
        }
        for x in $iterate(0, width) {
            body_row(x, y, tmp, out);
        }
    }
    getMicroTime();
}

fn iteration_sep_bounds_advanced(width : int, height : int, ksize : int,
                                 arr : &[float], out : &[float],
                                 body_col : fn(int, int, &[float], &[float], int) -> (),
                                 body_row : fn(int, int, &[float], &[float], int) -> ()
                               ) -> () {
    let bbh = ksize / 2;

    let Bounds2DCol = [
        (0           , bbh),
        (bbh         , height - bbh),
        (height - bbh, height)
    ];

    let Bounds2DRow = [
        (0          , bbh),
        (bbh        , width - bbh),
        (width - bbh, width)
    ];

    getMicroTime();
    let mut tmp = ~[width*1:float];

    for region_col in iterate(0, 3) {
        let bounds_col = Bounds2DCol[region_col];
        for y in $iterate(bounds_col(0), bounds_col(1)) {
            for region_row in iterate(0, 3) {
                let bounds_row = Bounds2DRow[region_row];
                for x in $iterate(bounds_row(0), bounds_row(1)) {
                    body_col(x, y, arr, tmp, region_col);
                }
            }
            for region_row in iterate(0, 3) {
                let bounds_row = Bounds2DRow[region_row];
                for x in $iterate(bounds_row(0), bounds_row(1)) {
                    body_row(x, y, tmp, out, region_row);
                }
            }
        }
    }
    getMicroTime();
}
