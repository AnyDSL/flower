fn iteration(mask : Mask, arr : Img, out : Img,
             body : fn(int, int, Mask, Acc, Acc) -> ()
            ) -> () {
    let arr_acc = Acc { img : arr, o_x : 0, o_y : 0, width : arr.width, height : arr.height, region : 10 };
    let out_acc = Acc { img : out, o_x : 0, o_y : 0, width : out.width, height : out.height, region : 10 };

    let mut times = ~[7:i64];
    for i in @range(0, 7) {
    let start = thorin_get_micro_time();
    for y in $iterate(0, out.height) {
        for x in $inner_loop(0, out.width) {
            @body(x, y, mask, arr_acc, out_acc);
        }
    }
    times(i) = thorin_get_micro_time()-start;
    }
    sort(7, times);
    thorin_print_micro_time(times(3));
}

fn iteration_bounds(mask : Mask, arr : Img, out : Img,
                    body : fn(int, int, Mask, Acc, Acc) -> ()
                   ) -> () {
    // compute the number of vector strides for boundary handling
    let bhy = mask.size_y / 2;
    let bhx = @round_up(mask.size_x / 2, get_vector_length());

    // (minx, maxx, miny, maxy)
    let Bounds2D = [
        (0              , bhx            , 0               , bhy),
        (bhx            , out.width - bhx, 0               , bhy),
        (out.width - bhx, out.width      , 0               , bhy),

        (0              , bhx            , bhy             , out.height - bhy),
        (bhx            , out.width - bhx, bhy             , out.height - bhy),
        (out.width - bhx, out.width      , bhy             , out.height - bhy),

        (0              , bhx            , out.height - bhy, out.height),
        (bhx            , out.width - bhx, out.height - bhy, out.height),
        (out.width - bhx, out.width      , out.height - bhy, out.height)
    ];

    let start = thorin_get_micro_time();
    for region in @iterate(0, 9) {
        let bounds = Bounds2D(region);
        let arr_acc = Acc { img : arr, o_x : 0, o_y : 0, width : arr.width, height : arr.height, region : region };
        let out_acc = Acc { img : out, o_x : 0, o_y : 0, width : out.width, height : out.height, region : region };

        for y in $iterate(bounds(2), bounds(3)) {
            for x in $inner_loop(bounds(0), bounds(1)) {
                @body(x, y, mask, arr_acc, out_acc);
            }
        }
    }
    thorin_print_micro_time(thorin_get_micro_time()-start);
}

fn iteration_advanced(mask : Mask, arr : Img, out : Img,
                      body : fn(int, int, Mask, Acc, Acc) -> ()
                     ) -> () {
    // TODO: blocked loop
    @iteration_bounds(mask, arr, out, body)
}

fn iteration_sep(mask: MaskSep, arr : Img, out : Img,
                 body : fn(int, int, MaskSep, Acc, Acc, bool) -> ()
                ) -> () {
    // allocate temporary array
    let tmp = Img { data : ~[out.width*out.height:float], width : out.width, height : out.height, stride : out.width };
    init_zero(tmp.data, $tmp.stride, $tmp.height);
    let arr_acc = Acc { img : arr, o_x : 0, o_y : 0, width : arr.width, height : arr.height, region : 10 };
    let out_acc = Acc { img : out, o_x : 0, o_y : 0, width : out.width, height : out.height, region : 10 };
    let tmp_acc = Acc { img : tmp, o_x : 0, o_y : 0, width : tmp.width, height : tmp.height, region : 10 };

    let start = thorin_get_micro_time();
    for y in $iterate(0, out.height) {
        for x in $inner_loop(0, out.width) {
            let is_row = false;
            @body(x, y, mask, arr_acc, tmp_acc, is_row);
        }
    }

    for y in $iterate(0, out.height) {
        for x in $inner_loop(0, out.width) {
            let is_row = true;
            @body(x, y, mask, tmp_acc, out_acc, is_row);
        }
    }
    thorin_print_micro_time(thorin_get_micro_time()-start);
}

fn iteration_sep_bounds(mask : MaskSep, arr : Img, out : Img,
                        body : fn(int, int, MaskSep, Acc, Acc, bool) -> ()
                       ) -> () {
    // allocate temporary array
    let tmp = Img { data : ~[out.width*out.height:float], width : out.width, height : out.height, stride : out.width };
    init_zero(tmp.data, $tmp.stride, $tmp.height);

    let bhy = mask.size / 2;
    let bhx = @round_up(mask.size / 2, get_vector_length());

    let Bounds2DCol = [
        (0               , bhy),
        (bhy             , out.height - bhy),
        (out.height - bhy, out.height)
    ];

    let Bounds2DRow = [
        (0              , bhx),
        (bhx            , out.width - bhx),
        (out.width - bhx, out.width)
    ];

    let start = thorin_get_micro_time();
    for region in @iterate(0, 3) {
        let bounds = Bounds2DCol(region);
        let arr_acc = Acc { img : arr, o_x : 0, o_y : 0, width : arr.width, height : arr.height, region : region };
        let tmp_acc = Acc { img : tmp, o_x : 0, o_y : 0, width : tmp.width, height : tmp.height, region : region };
        for y in $iterate(bounds(0), bounds(1)) {
            for x in $inner_loop(0, out.width) {
                let is_row = false;
                @body(x, y, mask, arr_acc, tmp_acc, is_row);
            }
        }
    }

    for region in @iterate(0, 3) {
        let bounds = Bounds2DRow(region);
        let tmp_acc = Acc { img : tmp, o_x : 0, o_y : 0, width : tmp.width, height : tmp.height, region : region };
        let out_acc = Acc { img : out, o_x : 0, o_y : 0, width : out.width, height : out.height, region : region };
        for y in $iterate(0, out.height) {
            for x in $inner_loop(bounds(0), bounds(1)) {
                let is_row = true;
                @body(x, y, mask, tmp_acc, out_acc, is_row);
            }
        }
    }
    thorin_print_micro_time(thorin_get_micro_time()-start);
}

fn iteration_sep_advanced(mask : MaskSep, arr : Img, out : Img,
                          body : fn(int, int, MaskSep, Acc, Acc, bool) -> ()
                         ) -> () {
    let bhy = mask.size / 2;
    let bhx = @round_up(mask.size / 2, get_vector_length());

    let Bounds2DCol = [
        (0               , bhy),
        (bhy             , out.height - bhy),
        (out.height - bhy, out.height)
    ];

    let Bounds2DRow = [
        (0              , bhx),
        (bhx            , out.width - bhx),
        (out.width - bhx, out.width)
    ];

    // allocate temporary array
    let tmp = Img { data : ~[out.width:float], width : out.width, height : 1, stride : out.width };
    init_zero(tmp.data, $tmp.stride, $tmp.height);

    let start = thorin_get_micro_time();
    for region_col in @iterate(0, 3) {
        let bounds_col = Bounds2DCol(region_col);
        for y in $iterate(bounds_col(0), bounds_col(1)) {
            for x in $inner_loop(0, tmp.width) {
                let is_row = false;
                // index space: cache line
                let arr_acc = Acc { img : arr, o_x : 0, o_y : y, width : arr.width, height : arr.height, region : region_col};
                let tmp_acc = Acc { img : tmp, o_x : 0, o_y : 0, width : tmp.width, height : tmp.height, region : region_col};
                @body(x, 0, mask, arr_acc, tmp_acc, is_row);
            }
            for region_row in @iterate(0, 3) {
                let bounds_row = Bounds2DRow(region_row);
                for x in $inner_loop(bounds_row(0), bounds_row(1)) {
                    let is_row = true;
                    // index space: cache line
                    let tmp_acc = Acc { img : tmp, o_x : 0, o_y : 0, width : tmp.width, height : tmp.height, region : region_row };
                    let out_acc = Acc { img : out, o_x : 0, o_y : y, width : out.width, height : out.height, region : region_row };
                    @body(x, 0, mask, tmp_acc, out_acc, is_row);
                }
            }
        }
    }
    thorin_print_micro_time(thorin_get_micro_time()-start);
}
