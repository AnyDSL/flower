extern "thorin" {
    fn mmap_f32(&[f32], int, int, int, int) -> &[f32];
    fn munmap_f32(&[f32]) -> ();
    fn spir(int, (int, int, int), (int, int, int), fn() -> ()) -> ();
}
extern "device" {
    fn _Z13get_global_idj(i32) -> i64;
}
fn acc_gidx() -> int    { _Z13get_global_idj(0) as int }
fn acc_gidy() -> int    { _Z13get_global_idj(1) as int }

fn range(lower: int, upper: int, yield: fn(int, fn())) -> () {
    if lower < upper {
        yield(lower);
        range(lower+1, upper, yield, return)
    }
}

fn iteration(width: int, height: int,
             body: fn(int, int) -> ()
            ) -> () {
    let grid  = (width, height, 1);
    let block = (128, 1, 1);
    let dev = 1;
    spir(dev, grid, block, || -> () {
        let gid_x = acc_gidx();
        let gid_y = acc_gidy();

        body(gid_x, gid_y);
    });
}

fn write(mut out: &[float], src: &[float], i: int) -> () {
    out(i) = src(i);
}

fn main() -> int {
    let width  = 2048;
    let height = 2048;
    let arr    = ~[width*height:float];
    let out    = ~[width*height:float];

    let mapped = mmap_f32(arr, 1, 1, 0, width * height);

    for x, y in @iteration(width, height) {
        write(out, mapped, y*width + x);
    }

    munmap_f32(mapped);

    thorin_release(arr as &i8);
    thorin_release(out as &i8);

    0
}

