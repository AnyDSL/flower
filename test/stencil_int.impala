// DSL implementation

fn range(a : int, b : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        range(a+1, b, yield);
    }
}

fn apply_bh(mut index : int,
            bh_lower : fn(int, int) -> int, bh_upper : fn(int, int) -> int,
            lb : int, ub : int) -> int {
    if index < lb   { index = bh_lower(index, lb); }
    if index >= ub  { index = bh_upper(index, ub); }
    index
}

fn apply_stencil(N : int, arr : &[float], mut out : &[float], stencil : [float * 3],
                 bh_lower : fn(int, int) -> int, bh_upper : fn(int, int) -> int) -> () {
    let lb = [0, 1, N - 1];
    let ub = [1, N - 1, N];
    for region in @range(0, 3) {
        let current_lb : int = lb(region);
        let current_ub : int = ub(region);
        for index in range(lb(region), ub(region)) {
            // apply stencil to pixel
            let mut sum : float = 0.0f;
            for j in @range(-1, 2) {
                let adapted_j : int = apply_bh(index + j, bh_lower, bh_upper,
                                               current_lb, current_ub);
                sum += stencil(j + 1) * arr(adapted_j);
            }
            out(index) = sum as float;
        }
    }
}


// DSL code

fn bh_clamp_lower(mut index : int, lower : int) -> int {
    if index < lower { lower } else { index }
}

fn bh_clamp_upper(mut index : int, upper : int) -> int {
    if index >= upper { upper - 1 } else { index }
}

fn main() -> &[float] {
    let width   = 2048;
    let height  = 2048;
    let a       = 0.2f;
    let b       = 1.0f - 4.0f * a;
    let num_it  = 100;
    let mut arr = ~[width*height:float];
    let mut out = ~[width*height:float];
    let stencil = [b, a, b];

    for iter in range(0, num_it) {
        @apply_stencil(width, arr, out, stencil, bh_clamp_lower, bh_clamp_upper);

        let mut tmp = arr;
        arr = out;
        out = tmp;
    }

    out
}
