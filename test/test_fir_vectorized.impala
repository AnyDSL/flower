fn @aie_pipeline(body: fn (i32) -> ()) = @|lower: i32, upper: i32| thorin_pipeline(0, lower, upper, body);

fn read_channel_v8[T](ch: &mut channel[T]) -> T {
    cgra_window_readincr_v[T](8, ch)
}

fn sliding_mul_i32(lane_size: u32, fir_taps: u32, coeff:i32, data:i32, data_start:u32) -> u64 {
    // 32b x 32b
    // ret acc80 (u64)
    let coeff_step = 1;
    let data_step_xy = 1;
    let coeff_start = 1:u32;

    cgra_sliding_mul_xy_ops_mul[i32, i32](lane_size, fir_taps, coeff_step, data_step_xy, coeff, coeff_start, data, data_start)
}

fn sliding_mul_8x8_i32(coeff:i32, data:i32, data_start:u32) = sliding_mul_i32(8, 8, coeff:i32, data:i32, data_start:u32);

static static_mask = [0, 1, 2, 3, 4, 5, 6, 7];

fn @read[T](buf: MEM, i: i32) -> T { bitcast[&addrspace(1)[T]](buf)(i)}
fn @write(buf: &mut [i32], i: i32, v: i32) -> () { bitcast[&mut addrspace(1)[i32]](buf)(i) = v }

static mut ch1 : channel[i32];
static mut ch2 : channel[i32];


struct CGRA_CONFIG {
    device: i32 = 0,
    runtime_ratio: f32 = 1,
    location: (i32, i32) = (-10, -10),
    vector_size: i32 = 16
}

struct MEM {
    mem: &mut[i32]
}

#[export]
fn main() -> () {
    let device = 0;
    let ptr_in = alloc(runtime_device(2, device), sizeof[i32]() * 4:i64).data as &mut [i32];
    let ptr_out = alloc(runtime_device(2, device), sizeof[i32]() * 4:i64).data as &mut [i32];

    let aa = MEM{mem = alloc(runtime_device(2, device), sizeof[i32]() * 4:i64).data as &mut [i32]};

    hls(device, || {
        write_channel[i32](&mut ch1, read[i32](aa, 0));
    });

    let config_k1 = CGRA_CONFIG{device = 0, runtime_ratio = 0.5, location = (-1, -1)};
    cgra_window(config_k1.device, config_k1.runtime_ratio, config_k1.location, config_k1.vector_size, || {
        let shared_mask = reserve_shared[i32](8);
        let lane_size = config_k1.vector_size as u32;
        let data = cgra_zeros[i32](lane_size);
        let coeff = cgra_load_v[i32](8, &static_mask(0));
        let mut acc : u64;

        // loop_iter = (NUM_SAMPLES/AIE_MUL_LANES)/NUM_MUL_LOOP
        for _i in aie_pipeline(0, 30) {

            // Read 8 samples and insert them in the second part of the data vector
            //let data_1 = read_channel( &mut ch1);
            let data_1 = cgra_window_readincr_v(8, &mut ch1);
            cgra_insert(data, 1, data_1);		// 0...0 | d0..d7

            ///Run multiply operation
            acc = sliding_mul_8x8_i32(coeff, data, 1);

            //Output 8 samples
            let res_vector_1 = cgra_shift_round_saturate[i32](8, acc, 0);
            write_channel(&mut ch2, res_vector_1);


            // Read 8 samples and insert then in the first part of the data vector
            let data_2 = cgra_window_readincr_v(8, &mut ch1);
            cgra_insert(data, 0, data_2);		// d8...d15 | d0..d7

            ///Run multiply operation
            acc = sliding_mul_8x8_i32(coeff, data, 9);

            //Output 8 samples
            let res_vector_2 = cgra_shift_round_saturate[i32](8, acc, 0);
            write_channel(&mut ch2, res_vector_2);
        }
    });

    hls(device,|| {
        write(ptr_out, 0, read_channel(&mut ch2));
    });

}
