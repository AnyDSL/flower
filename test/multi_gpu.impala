fn iteration_multi(width : int, height : int,
                   arr : &[float], out : &[float],
                   body : fn(int, int, &[float], &[float]) -> ()
                  ) -> () {
    let grid  = (width, height/2, 1);
    let block = (128, 1, 1);

    let dev_gpu = 1;
    let map_arr_CPU = mmap(arr, dev_gpu, acc_mem(), 0,                width * height/2);
    let map_out_CPU = mmap(out, dev_gpu, acc_mem(), 0,                width * height/2);

    acc(dev_gpu, grid, block, || -> () {
        let gid_x = acc_gidx();
        let gid_y = acc_gidy();

        body(gid_x, gid_y, map_arr_CPU, map_out_CPU);
    });

    let dev_cpu = 0;
    let map_arr_GPU = mmap(arr, dev_cpu, acc_mem(), width * height/2, width * height/2);
    let map_out_GPU = mmap(out, dev_cpu, acc_mem(), width * height/2, width * height/2);

    acc(dev_cpu, grid, block, || -> () {
        let gid_x = acc_gidx();
        let gid_y = acc_gidy();

        body(gid_x, gid_y, map_arr_GPU, map_out_GPU);
    });

    munmap(map_arr_CPU);
    munmap(map_out_CPU);
    munmap(map_arr_GPU);
    munmap(map_out_GPU);
}

fn main() -> int {
    let width  = 4096;
    let height = 4096;
    let arr    = ~[width*height:float];
    let out    = ~[width*height:float];
    init_rand(arr, width, height);
    init_zero(out, width, height);

    for x, y, arr, mut out in @iteration_multi(width, height, arr, out) {
        out(x + y*width) = arr(x + y*width);
    }

    let mut passed = 0;

    for y in range(0, height) {
        for x in range(0, width) {
            if out(x + y*width) != arr(x + y*width) { passed++; }
        }
    }

    passed
}

