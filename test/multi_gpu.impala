fn iteration_multi(width: i32, height: i32, tbytes: i32, out: Buffer, arr: Buffer,
                   body: fn(i32, i32, &[f32], &[f32]) -> ()
                  ) -> () {
    let num_dev  = 2;
    let ids_buf  = alloc_host(num_dev * 4);
    let mut ids  = ids_buf.data as &[i32];
    let size_gpu = width * height / num_dev * tbytes;

    for dev in range(0, num_dev) {
        let offset = dev * size_gpu;
        let grid  = (width, height / num_dev, 1);
        let block = (128, 1, 1);

        ids(dev) = spawn(|| -> () @{
            let arr_gpu = alloc_cuda(dev, size_gpu);
            let out_gpu = alloc_cuda(dev, size_gpu);
            copy_offset(arr, offset, arr_gpu, 0, size_gpu);

            acc(dev, grid, block, || @{
                body(acc_gidx(), acc_gidy(), out_gpu.data as &[f32], arr_gpu.data as &[f32]);
            });

            copy_offset(out_gpu, 0, out, offset, size_gpu);
            release(out_gpu);
            release(arr_gpu);
        });
    }

    for dev in range(0, num_dev) {
        sync(ids(dev));
    }
}

fn main() -> int {
    let width   = 4096;
    let height  = 4096;
    let tbytes  = 4;
    let arr_buf = alloc_host(width * height * tbytes);
    let out_buf = alloc_host(width * height * tbytes);
    let arr = arr_buf.data as &[f32];
    let out = out_buf.data as &[f32];
    init_rand(arr, width, height);
    init_zero(out, width, height);

    for x, y, mut out, arr in @iteration_multi(width, height, tbytes, out_buf, arr_buf) {
        out(y*width + x) = arr(y*width + x);
    }

    let mut passed = 0;
    for i in range(0, width*height) {
        if out(i) != arr(i) { passed++; }
    }
    if passed >= 256 { passed = 255; }

    release(arr_buf);
    release(out_buf);

    passed
}
