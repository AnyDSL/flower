fn iteration_multi(width: int, height: int,
                   out: &[float], arr: &[float],
                   body: fn(int, int, &[float], &[float]) -> ()
                  ) -> () {
    let mut ids : [int * 2];
    let mut map_arr : [&[f32] * 2];
    let mut map_out : [&[f32] * 2];

    for dev in @range(0, 2) {
        let height_dev = height / 2;
        let mem_size_dev = width * height_dev;
        let offset = dev * mem_size_dev;
        let grid  = (width, height_dev, 1);
        let block = (128, 1, 1);

        map_arr(dev) = mmap_f32(arr, dev, acc_tex(), offset, mem_size_dev);
        map_out(dev) = mmap_f32(out, dev, acc_mem(), offset, mem_size_dev);

        ids(dev) = spawn(|| -> () @{
            acc(dev, grid, block, || @{
                body(acc_gidx(), acc_gidy(), map_out(dev), map_arr(dev));
            });
        });
    }

    for dev in range(0, 2) {
        sync(ids(dev));
        munmap_f32(map_arr(dev));
        munmap_f32(map_out(dev));
    }
}

fn main() -> int {
    let width  = 4096;
    let height = 4096;
    let arr    = ~[width*height:float];
    let out    = ~[width*height:float];
    init_rand(arr, width, height);
    init_zero(out, width, height);

    for x, y, arr, mut out in @iteration_multi(width, height, out, arr) {
        out(x + y*width) = arr(x + y*width);
    }

    let mut passed = 0;

    for y in range(0, height) {
        for x in range(0, width) {
            if out(x + y*width) != arr(x + y*width) { passed++; }
        }
    }

    release(arr as &i8);
    release(out as &i8);

    passed
}

