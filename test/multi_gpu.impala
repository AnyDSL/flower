fn iteration_multi(width: i32, height: i32, tbytes: i32, out: &[f32], arr: &[f32],
                   body: fn(i32, i32, &[f32], &[f32]) -> ()
                  ) -> () {
    let mut ids: [i32 * 2];
    let mut arr_gpu: [&[f32] * 2];
    let mut out_gpu: [&[f32] * 2];
    let size_gpu = width * height / 2 * tbytes;
    for dev in @range(0, 2) {
        let offset = dev * size_gpu;
        arr_gpu(dev) = alloc_cuda(dev, size_gpu) as &[f32];
        out_gpu(dev) = alloc_cuda(dev, size_gpu) as &[f32];
        copy_offset(arr as &[i8], offset as i64, arr_gpu(dev) as &[i8], 0i64, size_gpu);
    }


    for dev in @range(0, 2) {
        let grid  = (width, height / 2, 1);
        let block = (128, 1, 1);

        ids(dev) = spawn(|| -> () @{
            acc(dev, grid, block, || @{
                body(acc_gidx(), acc_gidy(), out_gpu(dev), arr_gpu(dev));
            });
        });
    }

    for dev in @range(0, 2) {
        let offset = dev * size_gpu;
        sync(ids(dev));
        copy_offset(out_gpu(dev) as &[i8], 0i64, out as &[i8], offset as i64, size_gpu);
        release(out_gpu(dev) as &[i8]);
        release(arr_gpu(dev) as &[i8]);
    }
}

fn main() -> int {
    let width  = 4096;
    let height = 4096;
    let tbytes = 4;
    let arr    = alloc_host(width * height * tbytes) as &[f32];
    let out    = alloc_host(width * height * tbytes) as &[f32];
    init_rand(arr, width, height);
    init_zero(out, width, height);

    for x, y, arr, mut out in @iteration_multi(width, height, tbytes, out, arr) {
        out(y*width + x) = arr(y*width + x);
    }

    let mut passed = 0;

    for y in range(0, height) {
        for x in range(0, width) {
            if out(x + y*width) != arr(x + y*width) { passed++; }
        }
    }

    release(arr as &[i8]);
    release(out as &[i8]);

    passed
}
