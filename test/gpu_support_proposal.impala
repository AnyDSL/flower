// synchronization ...
fn iteration_mapped(width : int, height : int, img : &[float], body : fn(int, int, &[float]) -> ()) -> () {
    let grid  = (width, height/2, 1);
    let block = (32, 4, 1);

    // explicit verstion
    let cl_mem = mmap<CPU, Global>(img);
    let s1 = slice(cl_img, 0,                width * height/2);
    let s2 = slice(cl_img, width * height/2, width * height/2);
    let g1 = mmap<GPU1, Global>(s1);
    let g2 = mmap<GPU2, Global>(s2);

    // skip mmap to cl mem
    let s1 = slice(img, 0, 0,                width * height/2);
    let s2 = slice(img, 0, width * height/2, width * height/2);
    let g1 = mmap<GPU1, Global>(s1);
    let g2 = mmap<GPU2, Global>(s2);

    // skip slicing
    let g1 = mmap_region<GPU1, Global>(img, 0,                width * height/2);
    let g2 = mmap_region<GPU2, Global>(img, width * height/2, width * height/2);


    let g = [ g1, g2 ];
    let mut h = [int * 2];
    
    @iterate(0, 2+1, |i : int| -> () {
        h[i] = opencl(i+1, grid, block, || -> () {
            let tid_x = global_id(0);
            let tid_y = global_id(1);

            body(tid_x, tid_y, g[i]);
        });
    });

    synchronize(h[0]);
    synchronize(h[1]);
    synchronize(GPU1);
    synchronize(GPU2);
}



fn iteration(width : int, height : int, img : &[float], body : fn(int, int, &[float]) -> ()) -> () {
    // slice memory
    let cpu_slice1 = slice(img, 0,                width * height/2);
    let cpu_slice2 = slice(img, width * height/2, width * height/2);
    let gpu_img1 = mmap<GPU1>(cpu_slice1);
    let gpu_img2 = mmap<GPU2>(cpu_slice2);

    let grid  = (width/2, height, 1);
    let block = (32, 4, 1);

    let handle1 = async(|| -> () {
        nvvm(1, grid, block, || -> () {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body(tid_x, tid_y, gpu_img1);
        });
    });

    let handle2 = async(|| -> () {
        nvvm(1, grid, block, || -> () {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body(tid_x, tid_y, gpu_img2);
        });
    });

    let gpu_mems = [[float] * 2];
    gpu_mems[0] = gpu_img1;
    gpu_mems[1] = gpu_img2;
    let num_devices = 2;
    let handles = [float * 2];
    iterate(0, num_devices+1, |i : int| -> () {
        body(tid_x, tid_y + i * nvvm_read_ptx_sreg_ntid_y());
        handles[i] = async(|| -> () {
            nvvm(1, grid, block, || -> () {
                let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
                let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

                body(tid_x, tid_y, gpu_mems[i]);
            });
        });
    });

    // synchronize explicitly on handles
    synchronize(handle1);
    synchronize(handle2);
    // alternatively synchronize on GPU devices
    synchronize(GPU1);
    synchronize(GPU2);
}


fn iteration(width : int, height : int, img : &[float], body : fn(int, int, &[float], &[float]) -> ()) -> () {
    // slice memory
    let cpu_slice1 = slice(img, 0,                width * height/2);
    let cpu_slice2 = slice(img, width * height/2, width * height/2);
    let gpu_img1 = mmap<GPU1>(cpu_slice1);
    let gpu_img2 = mmap<GPU2>(cpu_slice2);

    let grid  = (width/2, height, 1);
    let block = (32, 4, 1);

    let handle1 = async(|| -> () {
        nvvm(1, grid, block, || -> () {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            let sm = sm_array(block[0], block[1]);
            let sm_x = nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let sm_y = nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            // GPU execution with dedicated scratchpad memory
            let offset_x = 0, offset_y = 0;
            sm = mmap<SM>(gpu_img1, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);
            // execution with scratchpad memory mapped to global memory
            sm = mmap<PROXY>(gpu_img1, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);

            body(tid_x, tid_y, gpu_img1, sm);
        });
    });

    let handle2 = async(|| -> () {
        nvvm(1, grid, block, || -> () {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            let sm = sm_array(block[0], block[1]);
            let sm_x = nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let sm_y = nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            // GPU execution with dedicated scratchpad memory
            let offset_x = 0, offset_y = 0;
            sm = mmap<SM>(gpu_img2, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);
            // execution with scratchpad memory mapped to global memory
            sm = mmap<PROXY>(gpu_img2, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);

            body(tid_x, tid_y, gpu_img2, sm);
        });
    });

    // synchronize explicitly on handles
    synchronize(handle1);
    synchronize(handle2);
    // alternatively synchronize on GPU devices
    synchronize(GPU1);
    synchronize(GPU2);
}


fn main() -> &[float] {
    let width   = 2048;
    let height  = 2048;
    let arr     = ~[width*height:float];
    let out     = ~[width*height:float];
    let stencil = [ 0.25f, 0.50f, 0.25f ];

    for x, y arr, out in iteration(width, height, arr, out) {
        out[y*width + x] = apply_stencil(arr, stencil, ...);
    }

    out
}

