extern "C" { fn sqrt(float) -> float; }

fn iteration(width : int, height : int,
             body : fn(int, int) -> ()
            ) -> () {
    for y in $range(0, height) {
        for x in $range(0, width) {
            body(x, y);
        }
    }
}

fn idx(x : int, y: int, width : int, height : int) -> int {
    x + y * width
}

fn main() -> &[float] {
    let width   = 1024;
    let height  = 1024;
    let ksize   = 3;
    let     arr = ~[width*height:float];
    let mut out = ~[width*height:float];


    // deriv 2D
    let mask = [
        [0.0f, 1.0f, 0.0f],
        [1.0f, 4.0f, 1.0f],
        [0.0f, 1.0f, 0.0f]];
    for x, y in iteration(width, height) {
        //let result = @convolve(arr, mask, 1.0f, ksize, x, y, width, height);
        let result = - (
            1.0f * arr(idx(x+0, y+1, width, height)) +
            1.0f * arr(idx(x-1, y+0, width, height)) +
           -4.0f * arr(idx(x  , y  , width, height)) +
            1.0f * arr(idx(x+1, y+0, width, height)) +
            1.0f * arr(idx(x+0, y-1, width, height)));
        out(idx(x, y, width, height)) = result;
    }


    // Jacobi
    let OMEGA = 0.8f;
    let RHS = ~[width*height:float];
    let Sol = ~[width*height:float];
    let jacobi_mask = [
        [0.00f, 0.25f, 0.00f],
        [0.25f, 0.00f, 0.25f],
        [0.00f, 0.25f, 0.00f]];
    for x, y in iteration(width, height) {
        //let result =
        //    (1.0f - OMEGA) * Sol[idx(x, y, width, height)] +
        //    0.25f * OMEGA  * RHS[idx(x, y, width, height)] +
        //    @convolve(Sol, jacobi_mask, 1.0f, ksize, x, y, width, height);
        let result =
            (1.0f - OMEGA) * Sol(idx(x, y, width, height)) +
            0.25f * OMEGA  * (
                Sol(idx(x+0, y+1, width, height)) +
                Sol(idx(x-1, y+0, width, height)) +
                RHS(idx(x  , y  , width, height)) +
                Sol(idx(x+1, y+0, width, height)) +
                Sol(idx(x+0, y-1, width, height))
            );
        out(idx(x, y, width, height)) = result;
    }


    // Residuum
    for x, y in iteration(width, height) {
        //let result =
        //    RHS[idx(x, y, width, height)] +
        //    @convolve(Sol, mask, 1.0f, ksize, x, y, width, height);
        let result =
                    RHS(idx(x,   y,   width, height)) +
             1.0f * Sol(idx(x+0, y+1, width, height)) +
             1.0f * Sol(idx(x-1, y+0, width, height)) +
            -4.0f * Sol(idx(x  , y  , width, height)) +
             1.0f * Sol(idx(x+1, y+0, width, height)) +
             1.0f * Sol(idx(x+0, y-1, width, height));
        out(idx(x, y, width, height)) = result;
    }


    // Restrict: arr = size x size; out = size/2 x size/2; fine -> coarse
    // coarse = Stencil * fine;
    let restrict_mask = [
        [0.25f, 0.50f, 0.25f],
        [0.50f, 1.00f, 0.50f],
        [0.25f, 0.50f, 0.25f]];
    for x, y in iteration(width, height) {
        let fx = 2*x;
        let fy = 2*y;
        let fwidth  = 2*width;
        let fheight = 2*height;

        //let result = @convolve(arr, restrict_mask, 1.0f, ksize, fx, fy, fwidth, fheight);
        let result =
            0.25f * arr(idx(fx-1, fy-1, fwidth, fheight));
            0.50f * arr(idx(fx+0, fy-1, fwidth, fheight));
            0.25f * arr(idx(fx+1, fy-1, fwidth, fheight));
            0.50f * arr(idx(fx-1, fy+0, fwidth, fheight));
                    arr(idx(fx  , fy  , fwidth, fheight));
            0.50f * arr(idx(fx+1, fy+0, fwidth, fheight));
            0.25f * arr(idx(fx-1, fy+1, fwidth, fheight));
            0.50f * arr(idx(fx+0, fy+1, fwidth, fheight));
            0.25f * arr(idx(fx+1, fy+1, fwidth, fheight));
        out(idx(x, y, width, height)) = result;
    }


    // L2 norm
    let mut l2sum = 0.0f;
    for x, y in iteration(width, height) {
        let value = arr(idx(x, y, width, height));
        l2sum += value*value;
    }
    //let l2norm = sqrt(l2sum)/(width*height);
    let l2norm = sqrt(l2sum)/(1024.0f*1024.0f);


    // Interpolate: arr = size/2 x size/2; out = size x size; coarse -> fine
    // fine += Stencil * coarse:
    // 0.25 0.50 0.25
    // 0.50 1.00 0.50
    // 0.25 0.50 0.25
    // FIXME: this will not run correctly on accelerators such as GPUs due to
    // their memory consistency model
    for x, y in iteration(width, height) {
        let cx = 2*x;
        let cy = 2*y;
        let cwidth  = 2*width;
        let cheight = 2*height;

        let v = arr(idx(x, y, width, height));
        out(idx(cx-1, cy-1, cwidth, cheight)) += 0.25f * v;
        out(idx(cx+0, cy-1, cwidth, cheight)) += 0.50f * v;
        out(idx(cx+1, cy-1, cwidth, cheight)) += 0.25f * v;
        out(idx(cx-1, cy+0, cwidth, cheight)) += 0.50f * v;
        out(idx(cx  , cy  , cwidth, cheight)) +=         v;
        out(idx(cx+1, cy+0, cwidth, cheight)) += 0.50f * v;
        out(idx(cx-1, cy+1, cwidth, cheight)) += 0.25f * v;
        out(idx(cx+0, cy+1, cwidth, cheight)) += 0.50f * v;
        out(idx(cx+1, cy+1, cwidth, cheight)) += 0.25f * v;
    }

    out
}

fn convolve(arr : &[float], mask : [[float * 3] * 3], omega : float, ksize : int, x : int, y : int, width : int, height : int) -> float {
    let mut sum = 0.0f;
    let ksize2 = ksize/2;

    // TODO:
    // - iterate over C const arrays
    // - consider only non-null values
    // - get value and index of current element
    // for (let cur not null in mask.values(), let idx in mask.index()) {
    //   sum += let * arr((x, y) + idx);
    // }
    for yf in range(-ksize2, ksize2) {
        for xf in range(-ksize2, ksize2) {
            let index = x + xf + (y + yf) * width;
            // TODO: propagate mask[imask] in case mask is a C const array
            sum += omega * mask(ksize2 + xf)(ksize2 + yf) * arr(index);
        }
    }

    sum
}

