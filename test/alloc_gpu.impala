fn range(lower: i32, upper: i32, body: fn(i32, fn())) -> () {
    if lower < upper {
        body(lower);
        range(lower+1, upper, body, return)
    }
}

fn iteration(width: i32, height: i32, body: fn(i32, i32) -> ()) -> () {
    let grid  = (width, height, 1);
    let block = (128, 1, 1);
    acc(acc_dev(), grid, block, || -> () @{
        body(acc_gidx(), acc_gidy());
    });
}

fn write(mut out: &[f32], src: &[f32], i: i32) -> () { out(i) = src(i) }

fn main() -> i32 {
    let width   = 2048;
    let height  = 2048;
    let tbytes  = 4;
    let arr     = alloc_host(width * height * tbytes);
    let out     = alloc_host(width * height * tbytes);
    let arr_gpu = alloc_cuda(acc_dev(), width * height * tbytes);
    let out_gpu = alloc_cuda(acc_dev(), width * height * tbytes);
    copy(arr, arr_gpu, width * height * tbytes);

    for x, y in @iteration(width, height) {
        write(out_gpu.data as &[f32], arr_gpu.data as &[f32], y*width + x);
    }

    copy(out_gpu, out, width * height * tbytes);
    release(out_gpu);
    release(arr_gpu);
    release(arr);
    release(out);

    0
}
