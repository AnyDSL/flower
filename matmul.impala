struct Mat {
    data : &[float],
    rows : int,
    cols : int
}

fn range_step(a : int, b : int, step : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        range_step(a + step, b, step, yield, return)
    }
}

fn get_step(lvl : int) -> int {
    if lvl == 0 {
        2048
    } else if lvl == 1 {
        256
    } else if lvl == 2 {
        1
    } else {
        0
    }
}

fn tiled_loop(upper : int, body : fn(int) -> ()) -> () {
    fn tile(cur_lvl : int, a : int, b : int) -> () {
        let step = get_step(cur_lvl);
        if step <= 0 {
            body(a)
        } else {
            for i in $range_step(a, b, step) {
                @tile(cur_lvl + 1, i, i + step);
            }
        }
    }
    tile(0, 0, upper);
}

fn index(M: Mat, x: int, y: int) -> int {
    M.cols * y + x
}

fn matmul(mut C: Mat, A: Mat, B: Mat) -> () {
    /*
    // initialize C with zeros
    for i in iterate(0, C.rows * C.cols) {
        C.data(i) = 0 as float;
    }
    */
    for i in $iterate(0, C.rows) {
        for k in $iterate(0, C.cols) {
            let mut sum = 0 as float;
            for j in $iterate(0, A.cols) {
                //C(index(C, i, k) += C(index(C, i, k) + A(index(A, i, j) * B(index(B, j, k);
                sum += A.data(index(A, i, j)) * B.data(index(B, j, k));
            }
            C.data(index(C, i, k)) = sum;
        }
    }
}

fn main(i: int) -> int {
    let l = 512;
    let m = 1024;
    let n = 2048;
    let A = Mat { data : ~[l*m:float], rows : l, cols : m }; // mxl
    let B = Mat { data : ~[m*n:float], rows : m, cols : n }; // nxm
    let C = Mat { data : ~[l*n:float], rows : l, cols : n }; // nxl

    getMicroTime();
    @matmul(C, A, B);
    getMicroTime();
    0
}
