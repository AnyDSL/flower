struct Mat {
    data : &[float],
    rows : int,
    cols : int
}

fn index(M: Mat, x: int, y: int) -> int {
    M.cols * y + x
}

fn matmul(mut C: Mat, A: Mat, B: Mat) -> () {
    for i in $iterate(0, C.rows) {
        for k in $iterate(0, C.cols) {
            let mut sum = 0 as float;
            for j in $iterate(0, A.cols) {
                //C(index(C, i, k) += C(index(C, i, k) + A(index(A, i, j) * B(index(B, j, k);
                sum += A.data(index(A, i, j)) * B.data(index(B, j, k));
            }
            C.data(index(C, i, k)) = sum;
        }
    }
}

fn main(i: int) -> int {
    let l     = 512;
    let m     = 1024;
    let n     = 2048;
    let A     = Mat { data : ~[l*m:float], rows : l, cols : m }; // mxl
    let B     = Mat { data : ~[m*n:float], rows : m, cols : n }; // nxm
    let mut C = Mat { data : ~[l*n:float], rows : l, cols : n }; // nxl
    /*
    // initialize C with zeros
    for i in iterate(0, C.rows * C.cols) {
        C.data(i) = 0 as float;
    }
    */

    getMicroTime();
    @matmul(C, A, B);
    getMicroTime();
    0
}
