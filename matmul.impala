struct Mat {
    data : &[float],
    rows : int,
    cols : int
}

fn matmul_golden(mut C: Mat, A: Mat, B: Mat) -> () {
    for i in $iterate(0, C.rows) {
        for k in $iterate(0, C.cols) {
            let mut sum = 0 as float;
            for j in $iterate(0, A.cols) {
                sum += A.data(index(A, j, i)) * B.data(index(B, k, j));
            }
            C.data(index(C, k, i)) = sum;
        }
    }
}

fn get_step(lvl : int) -> int {
    // 2048 -> 256 -> 1 -> 0
    if lvl == 0 {
        1024
    } else if lvl == 1 {
        1
    } else {
        0
    }
}

fn tiled_loop(upper : int, body : fn(int) -> ()) -> () {
    fn tile(cur_lvl : int, a : int, b : int) -> () {
        let step = get_step(cur_lvl);
        if step <= 0 {
            body(a)
        } else {
            for i in $range_step(a, b, step) {
                @tile(cur_lvl + 1, i, i + step);
            }
        }
    }
    tile(0, 0, upper);
}

fn index(M: Mat, x: int, y: int) -> int {
    M.cols * y + x
}

fn matmul_tiled(mut C: Mat, A: Mat, B: Mat) -> () {
    /*
    // initialize C with zeros
    for i in iterate(0, C.rows * C.cols) {
        C.data(i) = 0 as float;
    }
    */
    for i in $iterate(0, C.rows) {
        for k in $iterate(0, C.cols) {
            let mut sum = 0 as float;
            for j in @tiled_loop(A.cols) {
                //C(index(C, i, k) += C(index(C, i, k) + A(index(A, i, j) * B(index(B, j, k);
                sum += A.data(index(A, j, i)) * B.data(index(B, k, j));
            }
            C.data(index(C, k, i)) = sum;
        }
    }
}

fn main(i: int) -> int {
    let l = 512;
    let m = 1024;
    let n = 2048;
    let A = Mat { data : ~[l*m:float], rows : l, cols : m }; // mxl
    let B = Mat { data : ~[m*n:float], rows : m, cols : n }; // nxm
    let C = Mat { data : ~[l*n:float], rows : l, cols : n }; // nxl
    let R = Mat { data : ~[l*n:float], rows : l, cols : n }; // nxl

    let mut start = thorin_get_micro_time();
    @matmul_golden(R, A, B);
    let mut end = thorin_get_micro_time();
    thorin_print_micro_time(end-start);

    let nops = (2 as i64) * (l as i64) * (m as i64) * (n as i64);
    let mut gflops = (1.0e-9 * (nops as double)) / ((end - start) as double * 1.0e-6);
    thorin_print_gflops(gflops as float);

    start = thorin_get_micro_time();
    @matmul_tiled(C, A, B);
    end = thorin_get_micro_time();
    thorin_print_micro_time(end-start);

    gflops = (1.0e-9 * (nops as double)) / ((end - start) as double * 1.0e-6);
    thorin_print_gflops(gflops as float);

    0
}
