type Read = fn(i32, i32) -> i32;
type BinOp = fn(i32, i32) -> i32;

type ReadOp = fn(Read, i32, i32) -> i32;

type Region = (i32, i32);
type Border = fn(Region) -> Read;
type ImgBorder = fn(Img) -> Border;

type Loop = fn(i32, i32, fn(i32) -> ()) -> ();
type Loop_xy = fn(Border, i32, i32, i32, i32, fn(Read, i32, i32) -> ()) -> ();

struct Img {
    width  : i32,
    height : i32,
    data : &[i32]
};


// compute

fn @compute(input: Img, out: Img, border: ImgBorder, loop: Loop_xy, f: ReadOp) -> BinOp {
    let width  = out.width;
    let height = out.height;
    let data   = bitcast[&mut[i32]](out.data);

    for read, x, y in loop(border(input), 0, 0, width, height) @{
        data(y * width + x) = f(read, x, y);
    }
    |x, y| data(y * width + x)
}


// border handling

fn @access(img: Img, x: i32, y:  i32) -> i32 { img.data(y * img.width + x) }

fn @clip(v: i32, a: i32, b: i32) -> i32 { min(max(v, a), b) }

fn @is_within(region: Region, x: i32, y: i32, w: i32, h: i32) -> bool {
    let (rx, ry) = region;
    pe_info("region", region);
    let check = @|region, idx, upper| match region {
        0 => 0 <= idx,
        2 => idx < upper,
        _ => true
    };
    check(rx, x, w) && check(ry, y, h)
}

fn @border_img(border: fn(Img, i32, i32) -> i32) -> ImgBorder {
    @|img| @|region| @|x, y| if is_within(region, x, y, img.width, img.height) {
        access(img, x, y)
    } else {
        @@border(img, x, y)
    }
}

fn @border_const(v: i32) -> ImgBorder {
    border_img(@|_, _, _| v)
}

fn @border_clamp() -> ImgBorder {
    border_img(@|img, x, y| access(img, clip(x, 0, img.width-1), clip(y, 0, img.height-1)))
}

fn @border_mirror() -> ImgBorder {
    let mirror = @|x, w| if x < 0 { -x } else { if x >= w { w + w - x - 1 } else { x } };
    border_img(@|img, x, y| access(img, mirror(x, img.width), mirror(y, img.height)))
}


extern
fn run_halide(data: &mut[i32], width: i32, height: i32) -> () {
    let use_gpu = false;

    let img = Img { width : width, height : height, data : data };
    let out = Img { width : width, height : height, data : ~[width*height:i32] };

    let blur_x = @|read: Read, x: i32, y: i32| (read(x-1, y) + read(x, y) + read(x+1, y)) / 3;
    let blur_y = @|read: Read, x: i32, y: i32| (read(x, y-1) + read(x, y) + read(x, y+1)) / 3;

    let blur_simple = @|read: Read, x: i32, y: i32| blur_y(@|x: i32, y: i32| blur_x(read, x, y), x, y);

    //let schedule_cpu = combine_xy(range, range, (1, 1));
    //let schedule_cpu = combine_xy(vec(8), par(16), (1, 1));

    //let schedule_cpu = tile(256, 32, vec(8), par(0), (1, 1));
    //let schedule_cpu = tile(32, 16, vec(8), par(0), (1, 1));

    //let schedule_cpu = tile_tmp_x(256, 32, vec(8), par(0), blur_x, (1, 0), (0, 1));
    let schedule_cpu = tile_tmp_x(32, 16, vec(8), par(0), blur_x, (1, 0), (0, 1));

    //let schedule_cuda = tile_cuda(32, 4, (1, 1));
    let schedule_cuda = tile_cuda_tmp(32, 4, blur_x, (1, 0), (0, 1));

    //let border = border_const(0);
    //let border = border_mirror();
    let border = border_clamp();

    if use_cuda {
        let img_cuda = Img { width : width, height : height, data : alloc_cuda(cuda_dev, width * height * sizeof[i32]()).data as &[i32] };
        let out_cuda = Img { width : width, height : height, data : alloc_cuda(cuda_dev, width * height * sizeof[i32]()).data as &[i32] };
        runtime_copy(runtime_device(0, 0), img.data as &[i8], 0i64, runtime_device(1, cuda_dev), img_cuda.data as &[i8], 0i64, (width * height * sizeof[i32]()) as i64);

        with benchmark_cuda() {
            //compute(img_cuda, out_cuda, border, schedule_cuda, blur_simple);
            compute(img_cuda, out_cuda, border, schedule_cuda, blur_y);
        }

        runtime_copy(runtime_device(1, cuda_dev), out_cuda.data as &[i8], 0i64, runtime_device(0, 0), out.data as &[i8], 0i64, (width * height * sizeof[i32]()) as i64);
        runtime_release(runtime_device(1, cuda_dev), img_cuda.data as &[i8]);
        runtime_release(runtime_device(1, cuda_dev), out_cuda.data as &[i8]);
    } else {
        with benchmark_cpu() {
            //compute(img, out, border, schedule_cpu, blur_simple);
            compute(img, out, border, schedule_cpu, blur_y);
        }
    }
    print_total_timing();

    for y in range(0, height) {
        for x in range(0, width) {
            data(y * width + x) = out.data(y * width + x);
        }
    }
}
