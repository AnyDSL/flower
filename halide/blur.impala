type Loop = fn(i32, i32, fn(i32) -> ()) -> ();
type Loop_xy = fn(i32, i32, i32, i32, fn((i32, i32), i32, i32) -> ()) -> ();
type BinOp = fn(i32, i32) -> i32;
type RegOp = fn((i32, i32), i32, i32) -> i32;

struct Img {
    width: i32,
    height: i32,
    data: &[i32]
};

fn @access(img: Img, x: i32, y:  i32) -> i32 { img.data(y*img.height + x) }

fn @combine_xy(loop_x: Loop, loop_y: Loop, extent: (i32, i32)) -> Loop_xy {
    // TODO: specialize for regions
    |x, y, w, h, body|
        loop_y(y, h, |yy|
            loop_x(x, w, |xx|
                body((1, 1), xx, yy)))
}

fn @tile(x_step: i32, y_step: i32, loop_x: Loop, loop_y: Loop, extent: (i32, i32)) -> Loop_xy {
    |x_lower, y_lower, x_upper, y_upper, body: fn((i32, i32), i32, i32)->()| {
        let (x_extent, y_extent) = extent;

        let x_lower_aligned = round_up(x_lower + x_extent, x_step);
        let y_lower_aligned = round_up(y_lower + y_extent, y_step);
        let x_upper_aligned = round_down(x_upper - x_extent, x_step);
        let y_upper_aligned = round_down(y_upper - y_extent, y_step);

        let x_region = [[x_lower, x_lower_aligned], [x_lower_aligned, x_upper_aligned], [x_upper_aligned, x_upper]];
        let y_region = [[y_lower, y_lower_aligned], [y_lower_aligned, y_upper_aligned], [y_upper_aligned, y_upper]];

        for region_y in unroll(0, 3) @{
            for region_x in unroll(0, 3) @{
                let x_lower = x_region(region_x)(0);
                let y_lower = y_region(region_y)(0);
                let x_upper = x_region(region_x)(1);
                let y_upper = y_region(region_y)(1);

                if region_x == 1 && region_y == 1 {
                    loop_y(0, (y_upper - y_lower) / y_step, |ly|
                        range(ly * y_step + y_lower, (ly + 1) * y_step + y_lower, |ry|
                            range(0, (x_upper - x_lower) / x_step, |rx|
                                loop_x(rx * x_step + x_lower, (rx + 1) * x_step + x_lower, |lx|
                                    body((region_x, region_y), lx, ry)))))
                } else {
                    loop_y(y_lower, y_upper, |y|
                        loop_x(x_lower, x_upper, |x|
                              body((region_x, region_y), x, y)))
                }
            }
        }
    }
}

fn vec(vector_length: i32) -> Loop {
    |lower, upper, body| vectorize(vector_length, 32, lower, upper, body)
}

fn par(num_threads: i32) -> Loop {
    |lower, upper, body| parallel(num_threads, lower, upper, body)
}

// compute

fn @compute(out: Img, loop: Loop_xy, f: RegOp) -> BinOp {
    let width  = out.width;
    let height = out.height;
    let data   = bitcast[&mut[i32]](out.data);

    for region, x, y in loop(0, 0, width, height) @{
        data(y * width + x) = f(region, x, y);
    }
    |x, y| data(y * width + x)
}

// border handling

fn @clip(v: i32, a: i32, b: i32) -> i32 { min(max(v, a), b) }

fn @is_within(region: (i32, i32), x: i32, y: i32, w: i32, h: i32) -> bool {
    let (rx, ry) = region;
    pe_info("region", region);
    let check = @|region, idx, upper| match region {
        0 => 0 <= idx,
        2 => idx < upper,
        _ => true
    };
    check(rx, x, w) && check(ry, y, h)
}

type Region = (i32, i32);
type Border = fn(Region, Img, i32, i32) -> i32;

fn @border_img(region: Region, img: Img, x: i32, y: i32, border: fn() -> i32) -> fn(i32, i32) -> i32 {
    @|x, y| if is_within(region, x, y, img.width, img.height) {
        access(img, x, y)
    } else {
        border()
    }
}

fn @border_const(v: i32) -> fn((i32, i32), Img, i32, i32) -> fn(i32, i32) -> i32 {
    @|region, img, x, y| border_img(region, img, x, y, @|| v)
}

fn @border_clamp(region: Region, img: Img, x: i32, y: i32) -> fn(i32, i32) -> i32 {
    border_img(region, img, x, y, @|| access(img, clip(x, 0, img.width), clip(y, 0, img.height)))
}

fn @border_mirror(region: Region, img: Img, x: i32, y: i32) -> fn(i32, i32) -> i32 {
    let mirror = @|x, w| if x < 0 { -x } else { if x >= w { w + w - x - 1 } else { x } };
    border_img(region, img, x, y, @|| access(img, mirror(x, img.width), mirror(y, img.height)))
}


extern
fn run_halide(data: &mut[i32], width: i32, height: i32) -> () {
    let img = Img { width : width, height : height, data : data };
    let out = Img { width : width, height : height, data : ~[width*height:i32] };

    //let read   = @|region, x, y| border_mirror(region, img, x, y)(x, y);
    let read   = @|region, x, y| border_const(0)(region, img, x, y)(x, y);
    let blur_x = @|region, x, y| (  read(region, x-1, y) +   read(region, x, y) +   read(region, x+1, y)) / 3;
    let blur_y = @|region, x, y| (blur_x(region, x, y-1) + blur_x(region, x, y) + blur_x(region, x, y+1)) / 3;
    let blur   = @|region, x, y|  blur_y(region, x, y);

    //let schedule = combine_xy(range, range, (1, 1));
    //let schedule = combine_xy(vec(8), par(16));
    //let schedule = tile(256, 32, vec(8), par(4));

    let schedule = tile(512, 32, vec(8), par(0), (1, 1));

    with benchmark_cpu() {
        compute(out, schedule, blur);
    }
    print_total_timing();

    for y in range(0, height) {
        for x in range(0, width) {
            data(y * width + x) = out.data(y * width + x);
        }
    }
}
