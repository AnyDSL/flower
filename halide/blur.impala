type pixel_t = i32;

extern
fn run_halide(data: &mut[pixel_t], width: i32, height: i32) -> () {
    let use_cuda = false;

    let img = Img { width : width, height : height, data : data };
    let out = Img { width : width, height : height, data : ~[width*height:pixel_t] };

    let blur_x = @|read: Read, x: i32, y: i32| (read(x-1, y) + read(x, y) + read(x+1, y)) / 3 as pixel_t;
    let blur_y = @|read: Read, x: i32, y: i32| (read(x, y-1) + read(x, y) + read(x, y+1)) / 3 as pixel_t;

    let blur = @|read: Read, x: i32, y: i32| blur_y(@|x: i32, y: i32| blur_x(read, x, y), x, y);

    let blur_x_extents = Extents { x: 1, y: 0 };
    let blur_y_extents = Extents { x: 0, y: 1 };
    let blur_extents = add_extents(blur_x_extents, blur_y_extents);

    // let vec_size_x = 1;
    let vec_size_x = 8;
    let vec_size_y = 1;

    // --- stencil schedules with parallelization and/or vectorization ---
    let xy_r_r = @|s: StencilOp| combine_xy(range, range, s);
    let xy_p_r = @|s: StencilOp| combine_xy(par(0), range, s);
    let xy_v_v = @|s: StencilOp| combine_xy(vec(vec_size_x), vec(vec_size_y), s);
    let xy_v_p = @|s: StencilOp| combine_xy(vec(vec_size_x), par(0), s);

    // --- scheduling multiple stencils ---
    let schedule_x = xy_v_v(blur_x);
    let schedule_y = xy_v_v(blur_y);
    let xy_schedule = produce_root(schedule_x, schedule_y, blur_y_extents);

    // --- which schedule to use in the tiling or in general if no tiling ---
    // let tile_schedule = xy_v_v(blur);
    let tile_schedule = xy_schedule;

    // --- outermost y loop for tiling ---
    let outer_tile_loop = par(0);
    // let outer_tile_loop = range;

    // --- tiling schedules ---
    // let tile_width = 256; let tile_height = 32;
    // let tile_256_32 = tile(tile_width, tile_height, tile_schedule, outer_tile_loop);
    let tile_width = 32; let tile_height = 16;
    let tile_32_16 = tile(tile_width, tile_height, tile_schedule, outer_tile_loop);

    // --- schedule to use in central region ---
    // let middle_schedule = tile_schedule;
    let middle_schedule = tile_32_16;

    // --- schedule to use in border regions ---
    // let border_schedule = xy_r_r(@|read, x, y| 0);
    let border_schedule = middle_schedule;

    // --- which border handling to use ---
    // let border = border_const(0);
    // let border = border_mirror();
    let border = border_clamp();

    // --- bake everything together with border handling ---
    let schedule_cpu = handle_border(border(img), tile_width, tile_height, middle_schedule, border_schedule, blur_extents);

    // let schedule_cuda = tile_cuda(border(img), 32, 4, blur, blur_extents);
    let schedule_cuda = tile_cuda_tmp(border(img), 32, 4, blur_x, blur_y, blur_x_extents, blur_y_extents);

    if use_cuda {
        let img_cuda = Img { width : width, height : height, data : alloc_cuda(cuda_dev, width * height * sizeof[pixel_t]()).data as &[pixel_t] };
        let out_cuda = Img { width : width, height : height, data : alloc_cuda(cuda_dev, width * height * sizeof[pixel_t]()).data as &[pixel_t] };
        runtime_copy(runtime_device(0, 0), img.data as &[i8], 0i64, runtime_device(1, cuda_dev), img_cuda.data as &[i8], 0i64, (width * height * sizeof[pixel_t]()) as i64);

        with benchmark_cuda() {
            compute(img_cuda, out_cuda, schedule_cuda);
        }

        runtime_copy(runtime_device(1, cuda_dev), out_cuda.data as &[i8], 0i64, runtime_device(0, 0), out.data as &[i8], 0i64, (width * height * sizeof[pixel_t]()) as i64);
        runtime_release(runtime_device(1, cuda_dev), img_cuda.data as &[i8]);
        runtime_release(runtime_device(1, cuda_dev), out_cuda.data as &[i8]);
    } else {
        with benchmark_cpu() {
            compute(img, out, schedule_cpu);
        }
    }

    print_total_timing();

    for y in range(0, height) {
        for x in range(0, width) {
            data(y * width + x) = out.data(y * width + x);
        }
    }
}
