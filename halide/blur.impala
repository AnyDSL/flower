type Read = fn(i32, i32) -> i32;
type BinOp = fn(i32, i32) -> i32;

type ReadOp = fn(Read, i32, i32) -> i32;

type Region = (i32, i32);
type Border = fn(Region) -> Read;
type ImgBorder = fn(Img) -> Border;

type Loop = fn(i32, i32, fn(i32) -> ()) -> ();
type Loop_xy = fn(Border, i32, i32, i32, i32, fn(Read, i32, i32) -> ()) -> ();

struct Img {
    width  : i32,
    height : i32,
    data : &[i32]
};

fn @access(img: Img, x: i32, y:  i32) -> i32 { img.data(y * img.width + x) }

fn @combine_xy(loop_x: Loop, loop_y: Loop, extent: (i32, i32)) -> Loop_xy {
    @|border: Border, x_lower, y_lower, x_upper, y_upper, body: fn(Read, i32, i32)->()| {
        let (x_extent, y_extent) = extent;

        let x_lower_inner = x_lower + x_extent;
        let y_lower_inner = y_lower + y_extent;
        let x_upper_inner = x_upper - x_extent;
        let y_upper_inner = y_upper - y_extent;

        let x_region = [[x_lower, x_lower_inner], [x_lower_inner, x_upper_inner], [x_upper_inner, x_upper]];
        let y_region = [[y_lower, y_lower_inner], [y_lower_inner, y_upper_inner], [y_upper_inner, y_upper]];

        for region_y in unroll(0, 3) {
            for region_x in unroll(0, 3) {
                let read = border((region_x, region_y));
                let x_lower = x_region(region_x)(0);
                let y_lower = y_region(region_y)(0);
                let x_upper = x_region(region_x)(1);
                let y_upper = y_region(region_y)(1);
                loop_y(y_lower, y_upper, |yy|
                    loop_x(x_lower, x_upper, |xx|
                        body(read, xx, yy)))
            }
        }
    }
}

fn @tile_tmp_x(tile_x: i32, tile_y: i32, inner_loop_x: Loop, loop_y: Loop, body_x: ReadOp, extent: (i32, i32)) -> Loop_xy {
    @|border: Border, x_lower, y_lower, x_upper, y_upper, body: fn(Read, i32, i32)->()| {
        let (x_extent, y_extent) = extent;

        let x_lower_aligned = round_up(x_lower + x_extent, tile_x);
        let y_lower_aligned = round_up(y_lower + y_extent, tile_y);
        let x_upper_aligned = round_down(x_upper - x_extent, tile_x);
        let y_upper_aligned = round_down(y_upper - y_extent, tile_y);

        let x_region = [[x_lower, x_lower_aligned], [x_lower_aligned, x_upper_aligned], [x_upper_aligned, x_upper]];
        let y_region = [[y_lower, y_lower_aligned], [y_lower_aligned, y_upper_aligned], [y_upper_aligned, y_upper]];

        for region_y in unroll(0, 3) {
            for region_x in unroll(0, 3) {
                let read = border((region_x, region_y));
                let x_lower = x_region(region_x)(0);
                let y_lower = y_region(region_y)(0);
                let x_upper = x_region(region_x)(1);
                let y_upper = y_region(region_y)(1);

                let inner = @|outer_y| @|outer_x| {
                    let tmp = Img { width : tile_x, height : tile_y, data : ~[tile_x * (extent(1)*2 + tile_y):i32] };
                    let tmp_data = bitcast[&mut[i32]](tmp.data);

                    let tile_border = @|region| @|ix, iy| read(x_lower + outer_x * tile_x + ix, y_lower + outer_y * tile_y + iy);
                    let inner_xy = combine_xy(inner_loop_x, range, (0, 0));

                    for read, x, y in inner_xy(tile_border, 0, -1, tile_x, tile_y + 1) @{
                        tmp_data((y+1) * tile_x + x) = body_x(read, x, y);
                    }

                    let tmp_border = @|region| @|x, y| tmp_data((y - y_lower - outer_y * tile_y + 1) * tile_x + x - x_lower - outer_x * tile_x);
                    for read, x, y in inner_xy(tmp_border, x_lower + outer_x * tile_x,
                                                           y_lower + outer_y * tile_y,
                                                           x_lower + (outer_x+1) * tile_x,
                                                           y_lower + (outer_y+1) * tile_y) @{ body(read, x, y); }
                    runtime_release(0, bitcast[&[i8]](tmp.data));
                };

                if region_x == 1 && region_y == 1 {
                    loop_y(0, (y_upper - y_lower) / tile_y, |outer_y|
                        range(0, (x_upper - x_lower) / tile_x, inner(outer_y)))
                } else {
                    loop_y(y_lower, y_upper, |y|
                       range(x_lower, x_upper, |x|
                          body(@|x, y| body_x(read, x, y), x, y)))
                }
            }
        }
    }
}

fn @get_bounds(lower: i32, upper: i32, tile_size: i32, extent: i32, boundary: i32) -> (i32, i32) {
    let lower_aligned = round_up(lower + extent, tile_size);
    let upper_aligned = round_down(upper - extent, tile_size);
    match boundary {
      0 => (lower, lower_aligned),
      1 => (lower_aligned, upper_aligned),
      2 => (upper_aligned, upper),
      _ => undef()
    }
}

fn @tile(tile_x: i32, tile_y: i32, loop_x: Loop, loop_y: Loop, extent: (i32, i32)) -> Loop_xy {
    |border: Border, x_lower, y_lower, x_upper, y_upper, body: fn(Read, i32, i32)->()| {
        let (x_extent, y_extent) = extent;

        //let x_lower_aligned = round_up(x_lower + x_extent, tile_x);
        //let y_lower_aligned = round_up(y_lower + y_extent, tile_y);
        //let x_upper_aligned = round_down(x_upper - x_extent, tile_x);
        //let y_upper_aligned = round_down(y_upper - y_extent, tile_y);

        //let x_region = [[x_lower, x_lower_aligned], [x_lower_aligned, x_upper_aligned], [x_upper_aligned, x_upper]];
        //let y_region = [[y_lower, y_lower_aligned], [y_lower_aligned, y_upper_aligned], [y_upper_aligned, y_upper]];

        for region_y in unroll(0, 3) {
            let (y_lower, y_upper) = get_bounds(y_lower, y_upper, tile_y, y_extent, region_y);
            pe_info("bounds_y", (y_lower, y_upper));
            for region_x in unroll(0, 3) {
                let (x_lower, x_upper) = get_bounds(x_lower, x_upper, tile_x, x_extent, region_x);
                pe_info("bounds_x", (x_lower, x_upper));
                let read = border((region_x, region_y));
                //let x_lower = x_region(region_x)(0);
                //let y_lower = y_region(region_y)(0);
                //let x_upper = x_region(region_x)(1);
                //let y_upper = y_region(region_y)(1);

                if region_x == 1 && region_y == 1 {
                    loop_y(0, (y_upper - y_lower) / tile_y, |ly|
                        range(ly * tile_y + y_lower, (ly + 1) * tile_y + y_lower, |ry|
                            range(0, (x_upper - x_lower) / tile_x, |rx|
                                loop_x(rx * tile_x + x_lower, (rx + 1) * tile_x + x_lower, |lx|
                                    body(read, lx, ry)))))
                } else {
                    loop_y(y_lower, y_upper, |y|
                        loop_x(x_lower, x_upper, |x|
                            body(read, x, y)))
                }
            }
        }
    }
}


static gpu_dev = 0;
fn @benchmark_gpu(body: fn() -> ()) -> () { total_kernel_timing += benchmark(get_kernel_time, iter_acc, body, || synchronize_cuda(gpu_dev)) }

fn @tile_gpu(tile_x: i32, tile_y: i32, extent: (i32, i32)) -> Loop_xy {
    |border: Border, x_lower, y_lower, x_upper, y_upper, body: fn(Read, i32, i32)->()| {
        let (x_extent, y_extent) = extent;
        for region_y in unroll(0, 3) {
            let (y_lower, y_upper) = get_bounds(y_lower, y_upper, tile_y, y_extent, region_y);
            for region_x in unroll(0, 3) {
                let (x_lower, x_upper) = get_bounds(x_lower, x_upper, tile_x, x_extent, region_x);
                let read = border((region_x, region_y));
                let grid  = (x_upper - x_lower, y_upper - y_lower, 1);
                let block = (tile_x, tile_y, 1);
                cuda(gpu_dev, grid, block, || {
                    let x = x_lower + cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();
                    let y = y_lower + cuda_threadIdx_y() + cuda_blockDim_y() * cuda_blockIdx_y();
                    body(read, x, y)
                });
                synchronize_cuda(gpu_dev)
            }
        }
    }
}

fn vec(vector_length: i32) -> Loop {
    |lower, upper, body| vectorize(vector_length, 32, lower, upper, body)
}

fn par(num_threads: i32) -> Loop {
    |lower, upper, body| parallel(num_threads, lower, upper, body)
}


// compute

fn @compute(input: Img, out: Img, border: ImgBorder, loop: Loop_xy, f: ReadOp) -> BinOp {
    let width  = out.width;
    let height = out.height;
    let data   = bitcast[&mut[i32]](out.data);

    for read, x, y in loop(border(input), 0, 0, width, height) @{
        data(y * width + x) = f(read, x, y);
    }
    |x, y| data(y * width + x)
}


// border handling

fn @clip(v: i32, a: i32, b: i32) -> i32 { min(max(v, a), b) }

fn @is_within(region: Region, x: i32, y: i32, w: i32, h: i32) -> bool {
    let (rx, ry) = region;
    pe_info("region", region);
    let check = @|region, idx, upper| match region {
        0 => 0 <= idx,
        2 => idx < upper,
        _ => true
    };
    check(rx, x, w) && check(ry, y, h)
}

fn @border_img(border: fn(Img, i32, i32) -> i32) -> ImgBorder {
    @|img| @|region| @|x, y| if is_within(region, x, y, img.width, img.height) {
        access(img, x, y)
    } else {
        @@border(img, x, y)
    }
}

fn @border_const(v: i32) -> ImgBorder {
    border_img(@|_, _, _| v)
}

fn @border_clamp() -> ImgBorder {
    border_img(@|img, x, y| access(img, clip(x, 0, img.width-1), clip(y, 0, img.height-1)))
}

fn @border_mirror() -> ImgBorder {
    let mirror = @|x, w| if x < 0 { -x } else { if x >= w { w + w - x - 1 } else { x } };
    border_img(@|img, x, y| access(img, mirror(x, img.width), mirror(y, img.height)))
}


extern
fn run_halide(data: &mut[i32], width: i32, height: i32) -> () {
    let use_gpu = false;

    let img = Img { width : width, height : height, data : data };
    let out = Img { width : width, height : height, data : ~[width*height:i32] };

    let blur_x = @|read: Read, x: i32, y: i32| (read(x-1, y) + read(x, y) + read(x+1, y)) / 3;
    let blur_y = @|read: Read, x: i32, y: i32| (read(x, y-1) + read(x, y) + read(x, y+1)) / 3;

    let blur_simple = @|read: Read, x: i32, y: i32| blur_y(@|x: i32, y: i32| blur_x(read, x, y), x, y);

    // let schedule_cpu = combine_xy(range, range, (1, 1));
    // let schedule_cpu = combine_xy(vec(8), par(16), (1, 1));

     let schedule_cpu = tile(256, 32, vec(8), par(0), (1, 1));
    // let schedule_cpu = tile_tmp_x(32, 16, vec(8), par(0), blur_x, (1, 1));

    // let schedule_cpu = tile_tmp_x(256, 32, vec(8), par(0), blur_x, (1, 1));
    // let schedule_cpu = tile_tmp_x(32, 16, vec(8), par(0), blur_x, (1, 1));

    let schedule_gpu = tile_gpu(32, 4, (1, 1));

    //let border = border_const(0);
    //let border = border_mirror();
    let border = border_clamp();

    if use_gpu {
        let img_gpu = Img { width : width, height : height, data : alloc_cuda(gpu_dev, width * height * sizeof[i32]()).data as &[i32] };
        let out_gpu = Img { width : width, height : height, data : alloc_cuda(gpu_dev, width * height * sizeof[i32]()).data as &[i32] };
        runtime_copy(runtime_device(0, 0), img.data as &[i8], 0i64, runtime_device(1, gpu_dev), img_gpu.data as &[i8], 0i64, (width * height * sizeof[i32]()) as i64);

        with benchmark_gpu() {
            compute(img_gpu, out_gpu, border, schedule_gpu, blur_y);
        }

        runtime_copy(runtime_device(1, gpu_dev), out_gpu.data as &[i8], 0i64, runtime_device(0, 0), out.data as &[i8], 0i64, (width * height * sizeof[i32]()) as i64);
        runtime_release(runtime_device(1, gpu_dev), img_gpu.data as &[i8]);
        runtime_release(runtime_device(1, gpu_dev), out_gpu.data as &[i8]);
    } else {
        with benchmark_cpu() {
            // compute(img, out, border, schedule_cpu, blur_simple);
            compute(img, out, border, schedule_cpu, blur_y);
        }
    }
    print_total_timing();

    for y in range(0, height) {
        for x in range(0, width) {
            data(y * width + x) = out.data(y * width + x);
        }
    }
}
