type Read = fn(i32, i32) -> pixel_t;
type Write = fn(i32, i32, pixel_t) -> ();
type BinOp = fn(i32, i32) -> pixel_t;

type StencilOp = fn(Read, i32, i32) -> pixel_t;

struct Extents {
    x: i32,
    y: i32
};

fn @add_extents(e1: Extents, e2: Extents) -> Extents {
    Extents { x: e1.x + e2.x, y: e1.y + e2.y }
}

struct Img {
    width  : i32,
    height : i32,
    data : &[pixel_t]
};

type Region = (i32, i32);
type Border = fn(Region, Read) -> Read;
type ImgBorder = fn(Img) -> Border;

type Loop = fn(i32, i32, fn(i32) -> ()) -> ();
type Schedule = fn(Read, i32, i32, i32, i32, Write) -> ();

// compute

fn @compute(input: Img, out: Img, loop: Schedule) -> BinOp {
    loop(img_read(input), 0, 0, out.width, out.height, img_write(out));
    img_read(out)
}

// image read and write

fn @img_read(img: Img) -> Read {
    |x: i32, y: i32| -> pixel_t { img.data(y * img.width + x) }
}

fn @img_read_bounds(img: Img) -> Read {
    |x: i32, y: i32| -> pixel_t {
        if (x < 0 || x >= img.width || y < 0 || y >= img.height) {
            print_string("OOB: "); print_i32(x); print_string(", "); print_i32(y);
            print_string(" not in "); print_i32(img.width); print_string(" x "); print_i32(img.height);
            print_string("\n");
            return(128 as pixel_t)
        }

        img_read(img)(x, y)
    }
}

fn @img_write(img: Img) -> Write {
    let data = bitcast[&mut[pixel_t]](img.data);
    |x: i32, y: i32, v: pixel_t| -> () { data(y * img.width + x) = v; }
}

// border handling

fn @clip(v: i32, a: i32, b: i32) -> i32 { min(max(v, a), b) }

fn @is_within(region: Region, x: i32, y: i32, w: i32, h: i32) -> bool {
    let (rx, ry) = region;
    pe_info("region", region);
    let check = @|region, idx, upper| match region {
        0 => 0 <= idx,
        2 => idx < upper,
        _ => true
    };
    check(rx, x, w) && check(ry, y, h)
}

fn @border_img(border: fn(Img, Read, i32, i32) -> pixel_t) -> ImgBorder {
    @|img| @|region, read| @|x, y| if is_within(region, x, y, img.width, img.height) {
        read(x, y)
    } else {
        @@border(img, read, x, y)
    }
}

fn @border_const(v: pixel_t) -> ImgBorder {
    border_img(|_, _, _, _| v)
}

fn @border_clamp() -> ImgBorder {
    border_img(|img, read, x, y| read(clip(x, 0, img.width-1), clip(y, 0, img.height-1)))
}

fn @border_mirror() -> ImgBorder {
    let mirror = @|x, w| if x < 0 { -x } else { if x >= w { w + w - x - 1 } else { x } };
    border_img(|img, read, x, y| read(mirror(x, img.width), mirror(y, img.height)))
}

// 1D loops

fn vec(vector_length: i32) -> Loop {
    if vector_length == 1 {
        range
    } else {
        |lower, upper, body| vectorize(vector_length, 32, lower, upper, body)
    }
}

fn par(num_threads: i32) -> Loop {
    |lower, upper, body| parallel(num_threads, lower, upper, body)
}


// 2D schedules

fn @get_bounds(lower: i32, upper: i32, tile_size: i32, extent: i32, boundary: i32) -> (i32, i32) {
    let lower_aligned = round_up(lower + extent, tile_size);
    let upper_aligned = round_down(upper - extent, tile_size);
    match boundary {
        0 => (lower, lower_aligned),
        1 => (lower_aligned, upper_aligned),
        2 => (upper_aligned, upper),
        _ => undef()
    }
}

fn @handle_border(border: Border, align_x:i32, align_y:i32, loop_middle: Schedule, loop_border: Schedule, extents: Extents) -> Schedule {
    |read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        for region_y in unroll(0, 3) {
            let (y_lower, y_upper) = get_bounds(y_lower, y_upper, align_y, extents.y, region_y);
            for region_x in unroll(0, 3) {
                let (x_lower, x_upper) = get_bounds(x_lower, x_upper, align_x, extents.x, region_x);
                let border_read = border((region_x, region_y), read);
                if region_x == 1 && region_y == 1 {
                    loop_middle(border_read, x_lower, y_lower, x_upper, y_upper, write);
                } else {
                    loop_border(border_read, x_lower, y_lower, x_upper, y_upper, write);
                }
            }
        }
    }
}

fn @combine_xy(loop_x: Loop, loop_y: Loop, stencil: StencilOp) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        for y in loop_y(y_lower, y_upper) {
            for x in loop_x(x_lower, x_upper) {
                write(x, y, stencil(read, x, y))
            }
        }
    }
}

fn @produce_root(loop1: Schedule, loop2: Schedule, extents2: Extents) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        let width = x_upper - x_lower;
        let height = y_upper - y_lower;

        let tmp_width = width + extents2.x * 2;
        let tmp_height = height + extents2.y * 2;
        let tmp = Img { width : tmp_width, height : tmp_height, data : ~[tmp_width * tmp_height:pixel_t] };

        let read_outer = @|ix, iy| read(x_lower + ix, y_lower + iy);

        for ix, iy, value in loop1(read_outer, -extents2.x, -extents2.y, width + extents2.x, height + extents2.y) @{
            img_write(tmp)(ix + extents2.x, iy + extents2.y, value);
        }

        let read_tmp = @|ix, iy| { img_read(tmp)(ix + extents2.x, iy + extents2.y) };

        for ix, iy, value in loop2(read_tmp, 0, 0, width, height) {
            write(x_lower + ix, y_lower + iy, value);
        }
        runtime_release(0, bitcast[&[i8]](tmp.data));
    }
}

fn @tile(tile_width: i32, tile_height: i32, inner: Schedule, y_loop: Loop) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        for y_tile in y_loop(0, (y_upper - y_lower) / tile_height) {
            for x_tile in range(0, (x_upper - x_lower) / tile_width) {
                let to_img_x = @|ix| x_lower + x_tile * tile_width + ix;
                let to_img_y = @|iy| y_lower + y_tile * tile_height + iy;

                let tile_read = @|ix, iy| read(to_img_x(ix), to_img_y(iy));

                for ix, iy, value in inner(tile_read, 0, 0, tile_width, tile_height) @{
                    write(to_img_x(ix), to_img_y(iy), value)
                }
            }
        }
    }
}

static cuda_dev = 0;
fn @benchmark_cuda(body: fn() -> ()) -> () {
    total_kernel_timing += benchmark(get_kernel_time, iter_acc, body, || synchronize_cuda(cuda_dev))
}

fn @tile_cuda(border: Border, tile_x: i32, tile_y: i32, stencil: StencilOp, extents: Extents) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        for region_y in unroll(0, 3) {
            let (y_lower, y_upper) = get_bounds(y_lower, y_upper, tile_y, extents.y, region_y);
            for region_x in unroll(0, 3) {
                let (x_lower, x_upper) = get_bounds(x_lower, x_upper, tile_x, extents.x, region_x);
                let read = border((region_x, region_y), read);
                let grid  = (x_upper - x_lower, y_upper - y_lower, 1);
                let block = (tile_x, tile_y, 1);
                cuda(cuda_dev, grid, block, || {
                    let x = x_lower + cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();
                    let y = y_lower + cuda_threadIdx_y() + cuda_blockDim_y() * cuda_blockIdx_y();
                    write(x, y, stencil(read, x, y))
                });
            }
        }
        synchronize_cuda(cuda_dev)
    }
}

fn @tile_cuda_tmp(border: Border, tile_x: i32, tile_y: i32, stencil1: StencilOp, stencil2: StencilOp, extents1: Extents, extents2: Extents) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        let extents = add_extents(extents1, extents2);
        for region_y in unroll(0, 3) {
            let (y_lower, y_upper) = get_bounds(y_lower, y_upper, tile_y, extents.y, region_y);
            for region_x in unroll(0, 3) {
                let (x_lower, x_upper)   = get_bounds(x_lower, x_upper, tile_x, extents.x, region_x);
                let (x_extent, y_extent) = (extents2.x, extents2.y);
                let read  = border((region_x, region_y), read);
                let grid  = (x_upper - x_lower, y_upper - y_lower, 1);
                let block = (tile_x, tile_y, 1);
                cuda(cuda_dev, grid, block, || {
                    let (tid_x, tid_y) = (cuda_threadIdx_x(), cuda_threadIdx_y());
                    let gid_x = x_lower + tid_x + cuda_blockDim_x() * cuda_blockIdx_x();
                    let gid_y = y_lower + tid_y + cuda_blockDim_y() * cuda_blockIdx_y();
                    let (tmp_size_x, tmp_size_y) = (tile_x + 2 * x_extent, tile_y + 2 * y_extent);
                    let tmp = reserve_shared[pixel_t](tmp_size_x * tmp_size_y);

                    let tmp_idx = @|x, y| { x_extent + x + (y_extent + y) * tmp_size_x };

                    if tid_y < y_extent {
                        tmp(tmp_idx(tid_x, tid_y - y_extent)) = stencil1(read, gid_x, gid_y - y_extent);
                    }
                    if tid_y >= tile_y - y_extent {
                        tmp(tmp_idx(tid_x, tid_y + y_extent)) = stencil1(read, gid_x, gid_y + y_extent);
                    }
                    tmp(tmp_idx(tid_x, tid_y)) = stencil1(read, gid_x, gid_y);

                    cuda_syncthreads();

                    let tmp_read = @|x, y| tmp(tmp_idx(x - gid_x + tid_x, y - gid_y + tid_y));
                    write(gid_x, gid_y, stencil2(tmp_read, gid_x, gid_y))
                });
            }
        }
        synchronize_cuda(cuda_dev)
    }
}

