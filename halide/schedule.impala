type Read = fn(i32, i32) -> pixel_t;
type Write = fn(i32, i32, pixel_t) -> ();
type BinOp = fn(i32, i32) -> pixel_t;

type StencilOp = fn(Read, i32, i32) -> pixel_t;

struct Extents {
    x : i32,
    y : i32
};

fn @add_extents(e1: Extents, e2: Extents) -> Extents {
    Extents { x: e1.x + e2.x, y: e1.y + e2.y }
}

struct Img {
    width  : i32,
    height : i32,
    data : &[pixel_t]
};

type Region = (i32, i32);
type Border = fn(Region, Read) -> Read;
type ImgBorder = fn(Img) -> Border;

type Loop = fn(i32, i32, fn(i32) -> ()) -> ();
type Schedule = fn(Read, i32, i32, i32, i32, Write) -> ();

// compute

fn @compute(input: Img, out: Img, loop: Schedule) -> BinOp {
    loop(img_read(input), 0, 0, out.width, out.height, img_write(out));
    img_read(out)
}

// image read and write

fn @img_read(img: Img) -> Read {
    |x: i32, y: i32| -> pixel_t { img.data(y * img.width + x) }
}

fn @img_read_bounds(img: Img) -> Read {
    |x: i32, y: i32| -> pixel_t {
        if (x < 0 || x >= img.width || y < 0 || y >= img.height) {
            print_string("OOB: "); print_i32(x); print_string(", "); print_i32(y);
            print_string(" not in "); print_i32(img.width); print_string(" x "); print_i32(img.height);
            print_string("\n");
            return(128 as pixel_t)
        }

        img_read(img)(x, y)
    }
}

fn @img_write(img: Img) -> Write {
    let data = bitcast[&mut[pixel_t]](img.data);
    |x: i32, y: i32, v: pixel_t| -> () { data(y * img.width + x) = v; }
}

// border handling

fn @clip(v: i32, a: i32, b: i32) -> i32 { min(max(v, a), b) }

fn @is_within(region: Region, x: i32, y: i32, w: i32, h: i32) -> bool {
    let (rx, ry) = region;
    pe_info("region", region);
    let check = @|region, idx, upper| match region {
        0 => 0 <= idx,
        2 => idx < upper,
        _ => true
    };
    check(rx, x, w) && check(ry, y, h)
}

fn @border_img(border: fn(Img, Read, i32, i32) -> pixel_t) -> ImgBorder {
    @|img| @|region, read| @|x, y| if is_within(region, x, y, img.width, img.height) {
        read(x, y)
    } else {
        @@border(img, read, x, y)
    }
}

fn @border_const(v: pixel_t) -> ImgBorder {
    border_img(|_, _, _, _| v)
}

fn @border_clamp() -> ImgBorder {
    border_img(|img, read, x, y| read(clip(x, 0, img.width-1), clip(y, 0, img.height-1)))
}

fn @border_mirror() -> ImgBorder {
    let mirror = @|x, w| if x < 0 { -x } else { if x >= w { w + w - x - 1 } else { x } };
    border_img(|img, read, x, y| read(mirror(x, img.width), mirror(y, img.height)))
}

// 1D loops

fn vec(vector_length: i32) -> Loop {
    if vector_length == 1 {
        range
    } else {
        |lower, upper, body| vectorize(vector_length, 32, lower, upper, body)
    }
}

fn par(num_threads: i32) -> Loop {
    |lower, upper, body| parallel(num_threads, lower, upper, body)
}


// 2D schedules

fn @iterate_regions(lower: i32, upper: i32, tile_size: i32, extent: i32, body: fn(i32, i32, i32) -> ()) -> () {
    if extent == 0 {
        let region = 1;
        @@body(lower, upper, 1);
    } else {
        let lower_aligned = round_up(lower + extent, tile_size);
        let upper_aligned = round_down(upper - extent, tile_size);
        for region in unroll(0, 3) {
            let (lower, upper) = match region {
                0 => (lower, lower_aligned),
                1 => (lower_aligned, upper_aligned),
                2 => (upper_aligned, upper),
                _ => undef()
            };
            @@body(lower, upper, region);
        }
    }
}

fn @handle_border(border: Border, align_x:i32, align_y:i32, loop_middle: Schedule, loop_border: Schedule, extents: Extents) -> Schedule {
    |read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        for y_lower, y_upper, region_y in iterate_regions(y_lower, y_upper, align_y, extents.y) {
            for x_lower, x_upper, region_x in iterate_regions(x_lower, x_upper, align_x, extents.x) {
                let border_read = border((region_x, region_y), read);
                if region_x == 1 && region_y == 1 {
                    loop_middle(border_read, x_lower, y_lower, x_upper, y_upper, write);
                } else {
                    loop_border(border_read, x_lower, y_lower, x_upper, y_upper, write);
                }
            }
        }
    }
}

fn @combine_xy(loop_x: Loop, loop_y: Loop, stencil: StencilOp) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        for y in loop_y(y_lower, y_upper) {
            for x in loop_x(x_lower, x_upper) {
                write(x, y, stencil(read, x, y))
            }
        }
    }
}

fn @produce_root(loop1: Schedule, loop2: Schedule, extents2: Extents) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        let width  = x_upper - x_lower;
        let height = y_upper - y_lower;

        let tmp_width  = width  + extents2.x * 2;
        let tmp_height = height + extents2.y * 2;
        let tmp = Img { width : tmp_width, height : tmp_height, data : ~[tmp_width * tmp_height:pixel_t] };

        let read_outer = @|ix, iy| read(x_lower + ix, y_lower + iy);

        for ix, iy, value in loop1(read_outer, -extents2.x, -extents2.y, width + extents2.x, height + extents2.y) @{
            img_write(tmp)(ix + extents2.x, iy + extents2.y, value);
        }

        let read_tmp = @|ix, iy| { img_read(tmp)(ix + extents2.x, iy + extents2.y) };

        for ix, iy, value in loop2(read_tmp, 0, 0, width, height) {
            write(x_lower + ix, y_lower + iy, value);
        }
        runtime_release(0, bitcast[&[i8]](tmp.data));
    }
}

fn @tile(tile_width: i32, tile_height: i32, inner: Schedule, y_loop: Loop) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        for y_tile in y_loop(0, (y_upper - y_lower) / tile_height) {
            for x_tile in range(0, (x_upper - x_lower) / tile_width) {
                let to_img_x = @|ix| x_lower + x_tile * tile_width + ix;
                let to_img_y = @|iy| y_lower + y_tile * tile_height + iy;

                let tile_read = @|ix, iy| read(to_img_x(ix), to_img_y(iy));

                for ix, iy, value in inner(tile_read, 0, 0, tile_width, tile_height) @{
                    write(to_img_x(ix), to_img_y(iy), value)
                }
            }
        }
    }
}


static cuda_dev = 0;
fn @benchmark_cuda(body: fn() -> ()) -> () {
    total_kernel_timing += benchmark(get_kernel_time, iter_acc, body, || synchronize_cuda(cuda_dev))
}

fn @tile_cuda(tile_width: i32, tile_height: i32, stencil: StencilOp) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        let grid  = (x_upper - x_lower, y_upper - y_lower, 1);
        let block = (tile_width, tile_height, 1);
        cuda(cuda_dev, grid, block, || {
            let x = x_lower + cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();
            let y = y_lower + cuda_threadIdx_y() + cuda_blockDim_y() * cuda_blockIdx_y();
            write(x, y, stencil(read, x, y))
        });
    }
}

fn @tile_cuda_at(tile_width: i32, tile_height: i32, stencil1: StencilOp, stencil2: StencilOp, extents1: Extents, extents2: Extents) -> Schedule {
    @|read: Read, x_lower, y_lower, x_upper, y_upper, write: Write| {
        let grid  = (x_upper - x_lower, y_upper - y_lower, 1);
        let block = (tile_width, tile_height, 1);
        let (x_extent, y_extent) = (extents2.x, extents2.y);
        cuda(cuda_dev, grid, block, || {
            let (tid_x, tid_y)   = (cuda_threadIdx_x(), cuda_threadIdx_y());
            let (bdim_x, bdim_y) = (cuda_blockDim_x(),  cuda_blockDim_y());
            let gid_x = x_lower + tid_x + bdim_x * cuda_blockIdx_x();
            let gid_y = y_lower + tid_y + bdim_y * cuda_blockIdx_y();

            let (tmp_size_x, tmp_size_y) = (tile_width + 2 * x_extent, tile_height + 2 * y_extent);
            let tmp = reserve_shared[pixel_t](tmp_size_x * tmp_size_y);

            let tmp_idx1 = @|x, y| x + y * tmp_size_x;
            let steps_x  = round_up(tile_width,  tmp_size_x) / tile_width;
            let steps_y  = round_up(tmp_size_y, tile_height) / tile_height;

            for yy in unroll(0, steps_y) {
                let lid_y = tid_y            + yy * bdim_y;
                let idx_y = gid_y - y_extent + yy * bdim_y;
                for xx in unroll(0, steps_x) {
                    let lid_x = tid_x            + xx * bdim_x;
                    let idx_x = gid_x - x_extent + xx * bdim_x;

                    if lid_x < tmp_size_x && lid_y < tmp_size_y {
                        tmp(tmp_idx1(lid_x, lid_y)) = stencil1(read, idx_x, idx_y);
                    }
                }
            }

            cuda_syncthreads();

            let tmp_idx2 = @|x, y| x_extent + x + (y_extent + y) * tmp_size_x;
            let tmp_read = @|x, y| tmp(tmp_idx2(x - gid_x + tid_x, y - gid_y + tid_y));
            write(gid_x, gid_y, stencil2(tmp_read, gid_x, gid_y))
        });
    }
}
