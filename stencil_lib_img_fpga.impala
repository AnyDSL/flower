// ---------------------------------------------------------------------------
// Everything related with Img in stencil_lib
// ---------------------------------------------------------------------------
// ------------------------- new stuff
struct Img {
    buf     : Buffer,
    fifo    : &mut pipe,
    virtual : bool,
    width   : i32,
    height  : i32,
    stride  : i32,
}

fn @new_img(width: i32, height: i32, stride: i32, buf: Buffer) -> Img {
    static mut dummy: pipe;
    Img { buf: buf, fifo: &mut dummy, virtual: false, width: width, height: height, stride: stride }
}

fn @alloc_img(img: Img, alloc: fn(i32) -> Buffer) -> Img {
    new_img(img.width, img.height, img.stride, alloc(img.stride * img.height * sizeof[pixel_t]()))
}

fn @create_host_img(width: i32, height: i32) -> Img {
    let stride = round_up(width * sizeof[pixel_t](), round_up(sizeof[pixel_t](), get_vector_length())) / sizeof[pixel_t]();
    let buf = alloc_cpu(stride * height * sizeof[pixel_t]());
    new_img(width, height, stride, buf)
}

fn @new_virtual_img(width: i32, height: i32, stride: i32, fifo: &mut pipe) -> Img {
    let buf = alloc_cpu(0);
    Img { buf: buf, fifo: fifo, virtual: true, width: width, height: height, stride: stride }
}

fn @create_virtual_img(width: i32, height: i32, fifo: &mut pipe) -> Img {
    let stride = round_up(width * sizeof[pixel_t](), round_up(sizeof[pixel_t](), get_vector_length())) / sizeof[pixel_t]();
    new_virtual_img(width, height, stride, fifo)
}

// ------------------------- hackish
//fn @get_acc_virtual(img: Img, set_pixel: fn(i32, pixel_t) -> (), get_pixel: fn(i32) -> pixel_t) -> Acc {
//    let in_s = get_stream(img);
//    Acc {
//        read  : @|x, y|    { if x == 0 {in_s.update(0)}; in_s.read(x) },
//        write : @|x, y, v| { set_pixel(0, v) }
//    }
//}
fn @get_acc_virtual(img: Img, set_pixel: fn(i32, pixel_t) -> (), get_pixel: fn(i32) -> pixel_t) -> Acc {
    Acc {
        read  : @|x, y|    { get_pixel(x) },
        write : @|x, y, v| { set_pixel(x, v) }
    }
}

fn @get_acc(img: Img, set_pixel: fn(i32, pixel_t) -> (), get_pixel: fn(i32) -> pixel_t) -> Acc {
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        get_acc_offset(real_img, set_pixel, get_pixel, 0, 0)
    } else {
        get_acc_virtual(img, set_pixel, get_pixel)
    }
}

fn @get_acc_bh(img: Img, set_pixel: fn(i32, pixel_t) -> (), get_pixel: fn(i32) -> pixel_t, region: Region, bh_lower: BoundaryFn, bh_upper: BoundaryFn) -> Acc {
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        get_acc_bh_offset(real_img, set_pixel, get_pixel, 0, 0, region, bh_lower, bh_upper)
    } else {
        get_acc_virtual(img, set_pixel, get_pixel)
    }
}

// ------------------------- old
// &   [pixel_t] on CPU/AVX
// &[1][pixel_t] on CUDA/NVVM & OpenCL/AMDGPU
fn @get_acc_bh_offset(img: Img, set_pixel: fn(i32, pixel_t) -> (), get_pixel: fn(i32) -> pixel_t, rox: i32, roy: i32, region: Region, bh_lower: BoundaryFn, bh_upper: BoundaryFn) -> Acc {
    Acc {
        read  : @|x, y|    read_pixel(x + rox, y + roy, region, RoI { o_x : 0, o_y : 0, width : img.width, height : img.height }, @|x, y| { get_pixel(y * img.stride + x) }, bh_lower, bh_upper),
        write : @|x, y, v| set_pixel((y + roy) * img.stride + x + rox, v)
    }
}

fn @get_acc_offset(img: Img, set_pixel: fn(i32, pixel_t) -> (), get_pixel: fn(i32) -> pixel_t, rox: i32, roy: i32) -> Acc {
    Acc {
        read  : @|x, y|    get_pixel((y + roy) * img.stride + x + rox),
        write : @|x, y, v| set_pixel((y + roy) * img.stride + x + rox, v)
    }
}


// ---------------------------- streaming --------------------------------------
fn create_stream_in(width: int, height: int, stride: int, pFactor: int, update: fn(int) -> (), read: fn(int) -> pixel_t) -> stream_in {
    stream_in{ width: width, height: height, stride: stride, pFactor: pFactor, update: update, read: read}
}

fn img_to_stream_in(img: Img, pFactor: int, update: fn(int) -> (), read: fn(int) -> pixel_t) -> stream_in {
    stream_in{ width: img.width, height: img.height, stride: img.stride, pFactor: pFactor, update: update, read: read}
}

fn create_stream_out(width: int, height: int, stride: int, pFactor: int, update: fn(int) -> (), write : fn(int, pixel_t) -> ()) -> stream_out {
    stream_out{ width: width, height: height, stride: stride, pFactor: pFactor, update: update, write : write}
}

fn img_to_stream_out(img: Img, pFactor: int, update: fn(int) -> (), write : fn(int, pixel_t) -> ()) -> stream_out {
    stream_out{ width: img.width, height: img.height, stride: img.stride, pFactor: pFactor, update: update, write: write}
}

fn @channel_to_stream_out_vec1(img: Img) -> stream_out {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { write_channel(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value = din; }
    img_to_stream_out(img, 1, update, write)
}

fn @channel_to_stream_out_vec2(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let pFactor = 2;
    fn @update(idx: int) -> () { write_channel2(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 2, update, write)
}

fn @channel_to_stream_out_vec4(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let pFactor = 4;
    fn @update(idx: int) -> () { write_channel4(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 4, update, write)
}

fn @channel_to_stream_out_vec8(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let pFactor = 8;
    fn @update(idx: int) -> () { write_channel8(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 8, update, write)
}

fn @channel_to_stream_out_vec16(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let pFactor = 16;
    fn @update(idx: int) -> () { write_channel16(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 16, update, write)
}

fn @channel_to_stream_out_vec32(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let pFactor = 32;
    fn @update(idx: int) -> () { write_channel32(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 32, update, write)
}

fn @channel_to_stream_in_vec1(img: Img) -> stream_in {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { value = read_channel(img.fifo); }
    fn @read(idx: int) -> pixel_t { value }
    img_to_stream_in(img, 1, update, read)
}

fn @channel_to_stream_in_vec2(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let pFactor = 2;
    fn @update(idx: int) -> () { value = read_channel2(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 2, update, read)
}

fn @channel_to_stream_in_vec4(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let pFactor = 4;
    fn @update(idx: int) -> () { value = read_channel4(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 4, update, read)
}

fn @channel_to_stream_in_vec8(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let pFactor = 8;
    fn @update(idx: int) -> () { value = read_channel8(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 8, update, read)
}

fn @channel_to_stream_in_vec16(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let pFactor = 16;
    fn @update(idx: int) -> () { value = read_channel16(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 16, update, read)
}

fn @channel_to_stream_in_vec32(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let pFactor = 32;
    fn @update(idx: int) -> () { value = read_channel32(img.fifo); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 32, update, read)
}
