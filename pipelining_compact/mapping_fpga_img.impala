// Common
// pipe support
type pipe = channel;

// old
// --------------------- accessor: mapping dependent functions ----------------
// images
fn @get_pixel_real_fn(img: Img) -> fn(i32) -> pixel_t     { |idx|      bitcast[&[1][pixel_t]](img.buf.data)(idx) }
fn @set_pixel_real_fn(img: Img) -> fn(i32, pixel_t) -> () { |idx, val| bitcast[&mut[1][pixel_t]](img.buf.data)(idx) = val }
fn @get_pixel_virtual_fn(img: Img) -> fn(i32) -> pixel_t     { |idx| read_pipe(img.fifo) }
fn @set_pixel_virtual_fn(img: Img) -> fn(i32, pixel_t) -> () { |idx, val| write_pipe(img.fifo, val) }

fn @set_pixel_fn(img: Img) -> fn(i32, pixel_t) -> () {
    if img.virtual == false {
        set_pixel_real_fn(img)
    } else {
        set_pixel_virtual_fn(img)
    }
}

fn @get_pixel_fn(img: Img) -> fn(i32) -> pixel_t {
    if img.virtual == false {
        get_pixel_real_fn(img)
    } else {
        get_pixel_virtual_fn(img)
    }
}

// hack
fn @copy_img(src: Img, dst: Img) -> () {
    copy_real_img(src, dst);
}

// new
// --------------------- memory copy functions --------------------------------
fn @copy_real_img(src: Img, dst: Img) -> () {
    if src.virtual == false {
        copy(src.buf, dst.buf, dst.stride * dst.height * sizeof[pixel_t]());
    }
}

fn @get_device_copy(img: Img) -> Img {
    if img.virtual == false {
        let acc = accelerator(device_id);
        let img_dev = alloc_img(img, acc.alloc);
        copy_real_img(img, img_dev);
        img_dev
    } else {
        img
    }
}

fn @get_host_copy(img_dev: Img, img: Img) -> () {
    if img_dev.virtual == false {
        let acc = accelerator(device_id);
        acc.sync();
        copy_real_img(img_dev, img);
    } 
}

fn @release_device_copy(img: Img) -> () {
    if img.virtual == false {
        release(img.buf)
    }
}

// ---------------------------- streaming --------------------------------------
fn @get_stream(img: Img) -> fn() -> stream_in {
    let pFactor = get_vector_length();
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        get_stream_from_global_img(real_img, pFactor)
    } else {
        channel_to_stream_in(img, pFactor)
    }
}

fn @set_stream(img: Img) -> fn() -> stream_out {
    let pFactor = get_vector_length();
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        set_stream_from_global_img(real_img, pFactor)
    } else {
        channel_to_stream_out(img, pFactor)
    }
}

fn @channel_to_stream_in(img: Img, pFactor: int) -> fn() -> stream_in {
    @|| {
        match pFactor {
             1 => channel_to_stream_in_vec1 (img),
             2 => channel_to_stream_in_vec2 (img),
             4 => channel_to_stream_in_vec4 (img),
             8 => channel_to_stream_in_vec8 (img),
            16 => channel_to_stream_in_vec16(img),
            32 => channel_to_stream_in_vec32(img),
             _ => undef[stream_in]()
        }
    }
}

fn @channel_to_stream_out(img: Img, pFactor: int) -> fn() -> stream_out {
    @|| {
        match pFactor {
             1 => channel_to_stream_out_vec1 (img),
             2 => channel_to_stream_out_vec2 (img),
             4 => channel_to_stream_out_vec4 (img),
             8 => channel_to_stream_out_vec8 (img),
            16 => channel_to_stream_out_vec16(img),
            32 => channel_to_stream_out_vec32(img),
             _ => undef[stream_out]()
        }
    }
}

fn @channel_to_stream_out_vec1(img: Img) -> stream_out {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { write_pipe(img.fifo, value); }
    fn @write(idx: int, din: pixel_t) -> () { value = din; }
    img_to_stream_out(img, 1, update, write)
}

fn @channel_to_stream_out_vec2(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let pFactor = 2;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { write_pipe(img.fifo, value(v)); opencl_barrier(1u); }}
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 2, update, write)
}

fn @channel_to_stream_out_vec4(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let pFactor = 4;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { write_pipe(img.fifo, value(v)); opencl_barrier(1u);} }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 4, update, write)
}

fn @channel_to_stream_out_vec8(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let pFactor = 8;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { write_pipe(img.fifo, value(v)); opencl_barrier(1u); }}
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 8, update, write)
}

fn @channel_to_stream_out_vec16(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let pFactor = 16;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { write_pipe(img.fifo, value(v)); opencl_barrier(1u); }}
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 16, update, write)
}

fn @channel_to_stream_out_vec32(img: Img) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let pFactor = 32;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { write_pipe(img.fifo, value(v)); opencl_barrier(1u); }}
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    img_to_stream_out(img, 32, update, write)
}

fn @channel_to_stream_in_vec1(img: Img) -> stream_in {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { value = read_pipe(img.fifo); }
    fn @read(idx: int) -> pixel_t { value }
    img_to_stream_in(img, 1, update, read)
}

fn @channel_to_stream_in_vec2(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let pFactor = 2;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { value(v) = read_pipe(img.fifo); opencl_barrier(1u); }}
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 2, update, read)
}

fn @channel_to_stream_in_vec4(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let pFactor = 4;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { value(v) = read_pipe(img.fifo); opencl_barrier(1u); }}
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 4, update, read)
}

fn @channel_to_stream_in_vec8(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let pFactor = 8;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { value(v) = read_pipe(img.fifo); opencl_barrier(1u); }}
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 8, update, read)
}

fn @channel_to_stream_in_vec16(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let pFactor = 16;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { value(v) = read_pipe(img.fifo); opencl_barrier(1u); }}
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 16, update, read)
}

fn @channel_to_stream_in_vec32(img: Img) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let pFactor = 32;
    fn @update(idx: int) -> () { for v in unroll(0, pFactor) { value(v) = read_pipe(img.fifo); opencl_barrier(1u); }}
    fn @read(idx: int) -> pixel_t { value(idx) }
    img_to_stream_in(img, 32, update, read)
}

//  ------------------- Stencil Processing ----------------------
fn @iteration(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out_dev = get_device_copy(out);

    for benchmark_fpga(acc) {
        let in_s_fn  = get_stream(arr_dev);
        let out_s_fn = set_stream(out_dev);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let coarsening_fun = FetchAndCalc;

            let (in_s, out_s) = (in_s_fn(), out_s_fn());
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, mask, bh_lower, bh_upper, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @iteration_point(math: Intrinsics, out: Img, body: fn(Intrinsics, i32, i32, Acc) -> ()) -> () {
    let acc = accelerator(device_id);
    let out_dev = get_device_copy(out);

    for benchmark_fpga(acc) {
        let out_s_fn = set_stream(out_dev);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = out_s_fn();
            iter_point_body(pFactor, out_s, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @split_image(math: Intrinsics, arr: Img, pipe0: &mut pipe, pipe1: &mut pipe) -> (Img, Img) {
    let acc = accelerator(device_id);
    let out0 = new_virtual_img(arr.width, arr.height, arr.stride, pipe0);
    let out1 = new_virtual_img(arr.width, arr.height, arr.stride, pipe1);

    let pFactor = get_vector_length();
    let image_size = (arr.height * (arr.stride / pFactor) );
    for benchmark_fpga(acc) {
        let   in_s_fn = get_stream(arr);
        let out0_s_fn = set_stream(out0);
        let out1_s_fn = set_stream(out1);
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let (in_s, out0_s, out1_s) = (in_s_fn(), out0_s_fn(), out1_s_fn());
            for idx in range(0, image_size) {
                in_s.update(idx);
                for v in unroll(0, pFactor) {
                    let data = in_s.read(v);
                    out0_s.write(v, data);
                    out1_s.write(v, data);
                }
                out0_s.update(idx);
                out1_s.update(idx);
            }
        }
    }
    (out0, out1)
}

// alternative in case of data_pack read/writes (delete in next commit)
// fn @split_image_data_pack(math: Intrinsics, arr: Img, pipe0: &mut pipe, pipe1: &mut pipe) -> (Img, Img) {
//     let acc = accelerator(device_id);
//     let pFactor = get_vector_length();
//     let image_size = (arr.height * (arr.stride / pFactor) );
//     for benchmark_fpga(acc) {
//         for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
//             //for idx in range(0, image_size) {
//             for y in range(0, arr.height) {
//             for x in range(0, arr.stride / pFactor) {
//                 match pFactor {
//                     1 =>  { let din = read_pipe(arr.fifo);
//                             write_pipe(pipe0, din);
//                             write_pipe(pipe1, din); },
//                     2 =>  { let din = read_pipe2(arr.fifo);
//                             write_pipe2(pipe0, din);
//                             write_pipe2(pipe1, din); },
//                     _ => undef()
//                 }
//             }
//             }
//         }
//     }
//     //let out0 = create_virtual_img(arr.width, arr.height, pipe0);
//     //let out1 = create_virtual_img(arr.width, arr.height, pipe1);
//     let out0 = new_virtual_img(arr.width, arr.height, arr.stride, pipe0);
//     let out1 = new_virtual_img(arr.width, arr.height, arr.stride, pipe1);
//     (out0, out1)
// }
