// Common
// pipe support
type pipe = channel;

// old
// --------------------- accessor: mapping dependent functions ----------------
// images
fn @get_pixel_real_fn(img: Img) -> fn(i32) -> pixel_t     { |idx|      bitcast[&[1][pixel_t]](img.buf.data)(idx) }
fn @set_pixel_real_fn(img: Img) -> fn(i32, pixel_t) -> () { |idx, val| bitcast[&mut[1][pixel_t]](img.buf.data)(idx) = val }
fn @get_pixel_virtual_fn(img: Img) -> fn(i32) -> pixel_t     {|idx|      read_channel(img.fifo) }
fn @set_pixel_virtual_fn(img: Img) -> fn(i32, pixel_t) -> () {|idx, val| write_channel(img.fifo, val)}

fn @set_pixel_fn(img: Img) -> fn(i32, pixel_t) -> () {
    if img.virtual == false {
        set_pixel_real_fn(img)
    } else {
        set_pixel_virtual_fn(img)
    }
}

fn @get_pixel_fn(img: Img) -> fn(i32) -> pixel_t {
    if img.virtual == false {
        get_pixel_real_fn(img)
    } else {
        get_pixel_virtual_fn(img)
    }
}

// hack
fn @copy_img(src: Img, dst: Img) -> () {
    copy_real_img(src, dst);
}

// new
// --------------------- memory copy functions --------------------------------
fn @copy_real_img(src: Img, dst: Img) -> () {
    if src.virtual == false {
        copy(src.buf, dst.buf, dst.stride * dst.height * sizeof[pixel_t]());
    }
}

fn @get_device_copy(img: Img) -> Img {
    if img.virtual == false {
        let acc = accelerator(device_id);
        let img_dev = alloc_img(img, acc.alloc);
        copy_real_img(img, img_dev);
        img_dev
    } else {
        img
    }
}

fn @get_host_copy(img_dev: Img, img: Img) -> () {
    if img_dev.virtual == false {
        let acc = accelerator(device_id);
        acc.sync();
        copy_real_img(img_dev, img);
    } 
}

fn @release_device_copy(img: Img) -> () {
    if img.virtual == false {
        release(img.buf)
    }
}

// ---------------------------- streaming --------------------------------------
fn @get_stream(img: Img, pFactor: int) -> stream_in {
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        get_stream_from_global_img(real_img, pFactor)
    } else {
        let mut value = 0 as pixel_t;
        fn @update(idx: int) -> () { value = read_channel(img.fifo); }
        fn @read(idx: int) -> pixel_t { value }
        img_to_stream_in(img, pFactor, update, read)
    }
}

fn @set_stream(img: Img, pFactor: int) -> stream_out {
    if img.virtual == false {
        let real_img = new_img(img.width, img.height, img.stride, img.buf);
        set_stream_from_global_img(real_img, pFactor)
    } else {
        let mut value = 0 as pixel_t;
        fn @update(idx: int) -> () { write_channel(img.fifo, value); }
        fn @write(idx: int, din: pixel_t) -> () { value = din; }
        img_to_stream_out(img, pFactor, update, write)
    }
}

//  ------------------- Stencil Processing ----------------------
fn @iteration(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_dev = get_device_copy(arr);
    let out_dev = get_device_copy(out);

    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let coarsening_fun = FetchAndCalc;

            let in_s  = get_stream(arr_dev, pFactor);
            let out_s = set_stream(out_dev, pFactor);
            iter_body(math, coarsening_fun, pFactor, out_s, in_s, mask, bh_lower, bh_upper, body);
        }
    }
    get_host_copy(out_dev, out);
}

fn @iteration_point(math: Intrinsics, out: Img, body: fn(Intrinsics, i32, i32, Acc) -> ()) -> () {
    let acc = accelerator(device_id);
    let out_dev = get_device_copy(out);

    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let out_s = set_stream(out_dev, pFactor);
            iter_point_body(pFactor, out_s, body);
        }
    }
    get_host_copy(out_dev, out);
}

// fix this
fn @split_image(math: Intrinsics, arr: Img, pipe0: &mut pipe, pipe1: &mut pipe) -> (Img, Img) {
    let acc = accelerator(device_id);
    for benchmark_fpga(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = get_vector_length();
            let image_size = arr.height * arr.stride;

            for y in range(0, image_size) {
                let data = read_channel(arr.fifo);
                write_channel(pipe0, data);
                write_channel(pipe1, data);
            }
        }
    }
    let out0 = create_virtual_img(arr.width, arr.height, pipe0);
    let out1 = create_virtual_img(arr.width, arr.height, pipe1);
    (out0, out1)
}
