fn @channel_to_Mem2D_read[T](img: Img[T], pFactor: i32) -> Mem2D[T] {
    if(pFactor == 4) {
        channel_to_Mem2D_read_vec4[T](img)
    } else {
        undef[Mem2D[T]]()
    }
}

fn @channel_to_Mem2D_write[T](img: Img[T], pFactor: i32) -> Mem2D[T] {
    if(pFactor == 4) {
        channel_to_Mem2D_write_vec4[T](img)
    } else {
        undef[Mem2D[T]]()
    }
}

fn @channel_to_Mem2D_write_vec4[T](img: Img[T]) -> Mem2D[T] {
    //let mut value = [ 0 as pixel_t, .. 4 ];
    let mut value = bitcast[[T * 4]]([0; 4]);
    let pFactor = 4;
    fn @update(idx: i32) -> () { write_channel4[T](img.fifo, value); }
    fn @read(idx: i32) -> T { value(idx) }
    fn @write(idx: i32, din: T) -> () { value(idx) = din; }
    create_Mem2D_from_img[T](img, 4, update, read, write)
}

fn @channel_to_Mem2D_read_vec4[T](img: Img[T]) -> Mem2D[T] {
    //let mut value = [ 0 as pixel_t, .. 4 ];
    let mut value = bitcast[[T * 4]]([0; 4]);
    let pFactor = 4;
    fn @update(idx: i32) -> () { value = read_channel4[T](img.fifo); }
    fn @read(idx: i32) -> T { value(idx) }
    fn @write(idx: i32, din: T) -> () { value(idx) = din; }
    create_Mem2D_from_img[T](img, 4, update, read, write)
}
