// ---------------------------------------------------------------------------
// Support for virtual images
// ---------------------------------------------------------------------------
// pipe support
type pipe[T] = pixel_t;

fn @create_virtual_img[T](width: i32, height: i32, _buf: &mut pipe[T]) = create_img[T](width, height, alloc_cpu);

fn @create_host_img[T](width: i32, height: i32) -> Img[T] {
    let stride = round_up(width, get_vector_length());
    let buf = alloc_cpu((stride * height) as i64 * sizeof[T]());
    new_img[T](width, height, stride, buf)
}

// -------------------------- point operators ----------------------------------
fn @split_image[T](_math: Intrinsics, arr: Img[T], _out0: &mut pipe[T], _out1: &mut pipe[T]) = (arr, arr);


fn @split_image3[T](_math: Intrinsics, arr: Img[T], _out0: &mut pipe[T], _out1: &mut pipe[T], _out2: &mut pipe[T]) = (arr, arr, arr);


fn @split_image5[T](_math: Intrinsics, arr: Img[T], _out0: &mut pipe[T], _out1: &mut pipe[T], _out2: &mut pipe[T], _out3: &mut pipe[T], _out4: &mut pipe[T]) = (arr, arr, arr, arr, arr);

fn @split_image6[T](_math: Intrinsics, arr: Img[T], _out0: &mut pipe[T], _out1: &mut pipe[T], _out2: &mut pipe[T], _out3: &mut pipe[T], _out4: &mut pipe[T],
_out5: &mut pipe[T]) = (arr, arr, arr, arr, arr, arr);
// ---------------------------------------------------------------------------
// Everything related with Img in stencil_lib
// ---------------------------------------------------------------------------
struct Img[_T] {
    buf : Buffer,
    width  : i32,
    height : i32,
    stride : i32,
}

fn @new_img[T](width: i32, height: i32, stride: i32, buf: Buffer) = Img[T] { buf = buf, width = width,  height = height, stride = stride };

fn @alloc_img[T](img: Img[T], alloc: fn(i64) -> Buffer) = new_img[T](img.width, img.height, img.stride, alloc((img.stride * img.height) as i64 * sizeof[T]()));

fn @create_img[T](width: i32, height: i32, alloc: fn(i64) -> Buffer) -> Img[T] {
    let stride = round_up(width, get_vector_length());
    new_img[T](width, height, stride, alloc((stride * height) as i64 * sizeof[pixel_t]()))
}

fn @copy_img[T](src: Img[T], dst: Img[T]) = copy(src.buf, dst.buf);

// &   [pixel_t] on CPU/AVX
// &[1][pixel_t] on CUDA/NVVM & OpenCL/AMDGPU
fn @get_acc_bh[T](img: Img[T], set_pixel: fn(i32, T) -> (), get_pixel: fn(i32) -> T, region: Region, bh_lower: BoundaryFn[T], bh_upper: BoundaryFn[T]) -> Acc[T] {
    get_acc_bh_offset[T](img, set_pixel, get_pixel, 0, 0, region, bh_lower, bh_upper)
}
fn @get_acc_bh_offset[T](img: Img[T], set_pixel: fn(i32, T) -> (), get_pixel: fn(i32) -> T, rox: i32, roy: i32, region: Region, bh_lower: BoundaryFn[T], bh_upper: BoundaryFn[T]) = Acc[T] {
        read  = @|x, y|    read_pixel[T](x + rox, y + roy, region, RoI { o_x = 0, o_y = 0, width = img.width, height = img.height }, @|x, y| { get_pixel(y * img.stride + x) }, bh_lower, bh_upper),
        write = @|x, y, v| set_pixel((y + roy) * img.stride + x + rox, v)
    };
fn @get_acc[T](img: Img[T], set_pixel: fn(i32, T) -> (), get_pixel: fn(i32) -> T) = get_acc_offset[T](img, set_pixel, get_pixel, 0, 0);
fn @get_acc_offset[T](img: Img[T], set_pixel: fn(i32, T) -> (), get_pixel: fn(i32) -> T, rox: i32, roy: i32) = Acc[T] {
        read  = @|x, y|    get_pixel((y + roy) * img.stride + x + rox),
        write = @|x, y, v| set_pixel((y + roy) * img.stride + x + rox, v)
    };
