fn init_data(arr: Img) -> () {
    let buf = bitcast[&mut[pixel_t]](arr.buf.data);

    for y in range(0, arr.height) {
        for x in range(0, arr.width) {
            let val = if ((((x % 16) >= 8) & (( y % 16) < 8)) | (((x % 16) < 8) & ((y % 16) >= 8))) == false {
                255 as pixel_t
            }
            else {
                0 as pixel_t
            };
            buf(y * arr.stride + x) = val;
        }
    }
}


fn main() -> i32 {
    let width  = 1024;
    let height = 1024;

    static mut channel_it : pipe;
    static mut channel_ix : pipe;
    static mut channel_iy : pipe;
    static mut channel_ixx : pipe;
    static mut channel_iyy : pipe;
    static mut channel_denom : pipe;
    static mut channel_denom_to_common_x : pipe;
    static mut channel_denom_to_common_y : pipe;
    static mut channel_common_x : pipe;
    static mut channel_common_y : pipe;
    static mut channel_v0_x : pipe;
    static mut channel_v0_y : pipe;
    static mut channel_it_to_v0_x : pipe;
    static mut channel_it_to_v0_y : pipe;
    static mut channel_it_to_common0: pipe;
    static mut channel_ix_to_ixx : pipe;
    static mut channel_ix_to_common0 : pipe;
    static mut channel_iy_to_iyy : pipe;
    static mut channel_iy_to_common0 : pipe;
    static mut channel_av0_x_to_common0 : pipe;
    static mut channel_av0_x_to_v1_x : pipe;
    static mut channel_av0_y_to_common0 : pipe;
    static mut channel_av0_y_to_v1_y : pipe;
    static mut channel_common_x_to_v0_x : pipe;
    static mut channel_common_x_to_v1_x : pipe;
    static mut channel_common_x_to_v2_x : pipe;
    static mut channel_common_x_to_v3_x : pipe;
    static mut channel_common_x_to_v4_x : pipe;
    static mut channel_common_x_to_v5_x : pipe;
    static mut channel_common_y_to_v0_y : pipe;
    static mut channel_common_y_to_v1_y : pipe;
    static mut channel_common_y_to_v2_y : pipe;
    static mut channel_common_y_to_v3_y : pipe;
    static mut channel_common_y_to_v4_y : pipe;
    static mut channel_common_y_to_v5_y : pipe;

    let in_frame_1 = create_host_img(width, height);
    let in_frame_2 = create_host_img(width, height);
    let out        = create_host_img(width, height);

    let it = create_virtual_img(width, height, &mut channel_it );
    let ix = create_virtual_img(width, height, &mut channel_ix );
    let iy = create_virtual_img(width, height, &mut channel_iy );
    let ixx = create_virtual_img(width, height, &mut channel_ixx );
    let iyy = create_virtual_img(width, height, &mut channel_iyy );
    let denom = create_virtual_img(width, height, &mut channel_denom );
    let common_x = create_virtual_img(width, height, &mut channel_common_x );
    let common_y = create_virtual_img(width, height, &mut channel_common_y );
    let v0_x = create_virtual_img(width, height, &mut channel_v0_x );
    let v0_y = create_virtual_img(width, height, &mut channel_v0_y );

    init_data(in_frame_1);
    init_data(in_frame_2);
    init_zero(bitcast[&mut[pixel_t]](out.buf.data), out.stride, out.height);

    let mask_x = get_mask3(sobel_maskx);
    let mask_y = get_mask3(sobel_masky);
    let mask_a = get_mask3(average_mask);

    let lower = nobh_center;
    let upper = nobh_center;
    //let lower = clamp_lower;
    //let upper = clamp_upper;
    //let lower = mirro_lower;
    //let upper = mirro_upper;
    let enable_offset = 0;

    // Solving I_x * U + I_y * V + I_t = 0 iteratively by discretising of derivatives via finite differences.
    // I_t        => difference over frames (temporal derivative)
    // I_x , I_y  => Image derivative along x and y, respectively (spatial derivatives)
    // Computing (U = dx/dt, V = dy/dt ) indicating displacement, by Hornâ€“Schunck method
    // In this implementation We denote U by V(n)_x and V by V(n)_x which are computed iteratively for (n) times

    for benchmark_host(num_host_iter) {
        // ---------------- Preprocessing stages ------------------

        // I_t
        for math, x, y, out, in_frame_1, in_frame_2 in iteration_point2(math, it, in_frame_1, in_frame_2) {
            let pix_it = in_frame_1 - in_frame_2;
            out.write(x, y, pix_it);
        }

        // I_x
        for math, x, y, out, in_frame_1, mask in iteration(math, ix, in_frame_1, mask_x, lower, upper) {
            let pix_ix = apply_stencil(x, y, in_frame_1, mask);
            out.write(x, y, pix_ix);
        }

        let (ix_to_ixx, ix_to_common0) = split_image(math, ix, &mut channel_ix_to_ixx, channel_ix_to_common0)

        // I_y
        for math, x, y, out, in_frame_1, mask in iteration(math, iy, in_frame_1, mask_y, lower, upper) {
            let pix_iy = apply_stencil(x, y, in_frame_1, mask);
            out.write(x, y, pix_iy);
        }

        let (iy_to_iyy, iy_to_common0) = split_image(math, iy, &mut channel_iy_to_iyy, channel_iy_to_common0)

        // I_xx
        for math, x, y, out, ix_to_ixx in iteration_point(math, ixx, ix_to_ixx) {
            let pix_ixx = ix_to_ixx * ix_to_ixx;
            out.write(x, y, pix_ixx);
        }

        // I_yy
        for math, x, y, out, iy in iteration_point(math, iyy, iy) {
            let pix_iyy = iy * iy;
            out.write(x, y, pix_iyy);
        }


        // Denominator
        for math, x, y, out, ixx, iyy in iteration_point2(math, denom, ixx, iyy) {
            let pix_iyy = (alpha * alpha) + ixx  + iyy;
            out.write(x, y, pix_iyy);
        }

        // Denom is used both in common_x and common_y
        let (denom_x, denom_y) = split_image(math, denom, &mut channel_denom_to_common_x , &mut channel_denom_to_common_y);

        // Common_x
        for math, x, y, out, denom_x, ix in iteration_point2(math, common_x, denom_x, ix) {
            let pix_denom_x = ix / denom_x;
            out.write(x, y, pix_denom_x);
        }

        let (common_x_to_v0_x, common_x_to_v1_x, common_x_to_v2_x, common_x_to_v3_x, common_x_to_v4_x, common_x_to_v5_x) =
        split_image6(math, common_x, &mut channel_common_x_to_v0_x, &mut channel_common_x_to_v1_x, &mut channel_common_x_to_v2_x,
        &mut channel_common_x_to_v3_x, &mut channel_common_x_to_v4_x, &mut channel_common_x_to_v5_x);

        // Common_y
        for math, x, y, out, denom_y, iy in iteration_point2(math, common_y, denom_y, iy) {
            let pix_denom_y = iy / denom_y;
            out.write(x, y, pix_denom_y);
        }

        let (common_y_to_v0_y, common_y_to_v1_y, common_y_to_v2_y, common_y_to_v3_y, common_y_to_v4_y, common_y_to_v5_y) =
        split_image6(math, common_y, &mut channel_common_y_to_v0_y, &mut channel_common_y_to_v1_y, &mut channel_common_y_to_v2_y,
        &mut channel_common_y_to_v3_y, &mut channel_common_y_to_v4_y, &mut channel_common_y_to_v5_y);

        let (it_to_v0_x, it_to_v0_y, it_to_common0) = split_image3(math, it, &mut channel_it_to_v0_x, &mut channale_it_to_v0_y , &mut channel_it_to_common0)

        // V0_x
        for math, x, y, out, common_x_to_v0_x, it in iteration_point2(math, v0_x, common_x_to_v0_x, it) {
            let pix_common_x = -i_t * common_x;
            out.write(x, y, pix_common_x);
        }

        // V0_y
        for math, x, y, out, common_y_to_v0_y, it in iteration_point2(math, v0_y, common_y_to_v0_y, it) {
            let pix_common_y = -it * common_y;
            out.write(x, y, pix_common_y);
        }

        // ---------------  Iterative section --------------
        // V(n+1)_x = AV(n)_x - Common(n)*Common_x
        // V(n+1)_y = AV(n)_y - Common(n)*Common_y
        // n : [1 .. 4]

        // n = 0

        // A*V0_x --> Velocity_x average
        for math, x, y, out, v0_x, mask in iteration(math, av0_x, v0_x, mask_a) {
            let pix_av0_x = apply_stencil(x, y, v0_x, mask);
            out.write(x, y, pix_av0_x);

        }

        let (av0_x_to_common0, av0_x_to_av_x) = split_image(math, av0_x, &mut channel_av0_x_to_common0, &mut channel_av0_x_to_v1_x);

        // A*V0_y --> Velocity_y average
        for math, x, y, out, v0_y, mask in iteration(math, av0_y, v0_y, mask_a) {
            let pix_av0_y = apply_stencil(x, y, v0_y, mask);
            out.write(x, y, pix_av0_y);
        }

        let (av0_y_to_common0, av0_y_to_av_y) = split_image(math, av0_y, &mut channel_av0_y_to_common0, &mut channel_av0_y_to_v1_y);

        // Common0
        for math, x, y, out, av0_x_to_common0, av0_y, ix_to_common0, iy_to_common0, it_to_common0 in
            iteration_point5(math, common0, av0_x_to_common0, av0_y_to_common0, ix_to_common0, iy_to_common0, it_to_common0 ) {
                let pix_common0 = ix_to_common0 * av0_x + iy_to_common0 * av0_x + it_to_common0;
                out.write(x, y, pix_common0);
        }

        // V1_x


        // V1_y

        // n=1


    }
    print_total_timing();
    // display results
    let in_frame_1_acc = get_acc(in_frame_1, |idx, val| { bitcast[&mut[pixel_t]](in_frame_1.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](in_frame_1.buf.data)(idx));
    let in_frame_2_acc = get_acc(in_frame_2, |idx, val| { bitcast[&mut[pixel_t]](in_frame_2.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](in_frame_2.buf.data)(idx));
    let out_acc = get_acc(out, |idx, val| { bitcast[&mut[pixel_t]](out.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](out.buf.data)(idx));

    let roi_x = 0;
    let roi_y = 0;
    print_string("Frame 1 ");
    display_image(in_frame_1_acc, roi_x, roi_y);
    print_string("Frame 2 ");
    display_image(in_frame_2_acc, roi_x, roi_y);
    print_string("Optical flow:\n");
    display_image(out_acc, roi_x, roi_y);

    release(in_frame_1.buf);
    release(in_frame_2.buf);
    release(out.buf);
    0
}
