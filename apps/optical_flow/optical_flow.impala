fn init_data(arr: Img) -> () {
    let buf = bitcast[&mut[pixel_t]](arr.buf.data);

    for y in range(0, arr.height) {
        for x in range(0, arr.width) {
            let val = if ((((x % 16) >= 8) & (( y % 16) < 8)) | (((x % 16) < 8) & ((y % 16) >= 8))) == false {
                255 as pixel_t
            }
            else {
                0 as pixel_t
            };
            buf(y * arr.stride + x) = val;
        }
    }
}


fn main() -> i32 {
    let width  = 1024;
    let height = 1024;

    static mut channel_i_t : pipe;
    static mut channel_i_x : pipe;
    static mut channel_i_y : pipe;
    static mut channel_i_xx : pipe;
    static mut channel_i_yy : pipe;
    static mut channel_denom : pipe;
    static mut channel_denom_to_common_x : pipe;
    static mut channel_denom_to_common_y : pipe;
    static mut channel_common_x : pipe;
    static mut channel_common_y : pipe;
    static mut channel_v0_x : pipe;
    static mut channel_v0_y : pipe;

    let in_frame_1 = create_host_img(width, height);
    let in_frame_2 = create_host_img(width, height);
    let out        = create_host_img(width, height);

    let i_t = create_virtual_img(width, height, &mut channel_i_t );
    let i_x = create_virtual_img(width, height, &mut channel_i_x );
    let i_y = create_virtual_img(width, height, &mut channel_i_y );
    let i_xx = create_virtual_img(width, height, &mut channel_i_xx );
    let i_yy = create_virtual_img(width, height, &mut channel_i_yy );
    let denom = create_virtual_img(width, height, &mut channel_denom );
    let common_x = create_virtual_img(width, height, &mut channel_common_x );
    let common_y = create_virtual_img(width, height, &mut channel_common_y );
    let v0_x = create_virtual_img(width, height, &mut channel_v0_x );
    let v0_y = create_virtual_img(width, height, &mut channel_v0_y );

    init_data(in_frame_1);
    init_data(in_frame_2);
    init_zero(bitcast[&mut[pixel_t]](out.buf.data), out.stride, out.height);

    let mask_x = get_mask3(sobel_maskx);
    let mask_y = get_mask3(sobel_masky);

    let lower = nobh_center;
    let upper = nobh_center;
    //let lower = clamp_lower;
    //let upper = clamp_upper;
    //let lower = mirro_lower;
    //let upper = mirro_upper;
    let enable_offset = 0;

    // Solving I_x * u + I_y * v + I_t = 0 iteratively by discretising of derivatives via finite differences.
    // I_t        => differenec over frames
    // I_x , I_y  => Image derivative along x and y, respectively
    // Computing (u = dx/dt, v = dy/dt ) indicating displacement

    for benchmark_host(num_host_iter) {
        // I_t
        for math, x, y, out, in_frame_1, in_frame_2 in iteration_point2(math, i_t, in_frame_1, in_frame_2) {
            let pix_i_t = in_frame_1 - in_frame_2;
            out.write(x, y, pix_i_t);
        }

        // I_x
        for math, x, y, out, in_frame_1, mask in iteration(math, i_x, in_frame_1, mask_x, lower, upper) {
            let pix_i_x = apply_stencil(x, y, in_frame_1, mask);
            out.write(x, y, pix_i_x);
        }

        // I_y
        for math, x, y, out, in_frame_1, mask in iteration(math, i_y, in_frame_1, mask_y, lower, upper) {
            let pix_i_y = apply_stencil(x, y, in_frame_1, mask);
            out.write(x, y, pix_i_y);
        }

        // I_xx
        for math, x, y, out, i_x in iteration_point(math, i_xx, i_x) {
            let pix_i_xx = i_x * i_x;
            out.write(x, y, pix_i_xx);
        }

        // I_yy
        for math, x, y, out, i_y in iteration_point(math, i_yy, i_y) {
            let pix_i_yy = i_y * i_y;
            out.write(x, y, pix_i_yy);
        }

        // Denominator
        for math, x, y, out, i_xx, i_yy in iteration_point2(math, denom, i_xx, i_yy) {
            let pix_i_yy = (alpha * alpha) + i_xx  + i_yy;
            out.write(x, y, pix_i_yy);
        }

        // Denom is used both in common_x and common_y
        let (denom_x, denom_y) = split_image(math, denom, &mut channel_denom_to_common_x , &mut channel_denom_to_common_y);

        // Common_x
        for math, x, y, out, denom_x, i_x in iteration_point2(math, common_x, denom_x, i_x) {
            let pix_denom_x = i_x / denom_x;
            out.write(x, y, pix_denom_x);
        }

        // Common_y
        for math, x, y, out, denom_y, i_y in iteration_point2(math, common_y, denom_y, i_y) {
            let pix_denom_y = i_y / denom_y;
            out.write(x, y, pix_denom_y);
        }

        // V0_x
        for math, x, y, out, common_x, i_t in iteration_point2(math, v0_x, common_x, i_t) {
            let pix_common_x = -i_t * common_x;
            out.write(x, y, pix_common_x);
        }

        // V0_y
        for math, x, y, out, common_y, i_t in iteration_point2(math, v0_y, common_x, i_t) {
            let pix_common_y = -i_t * common_y;
            out.write(x, y, pix_common_y);
        }

        // Iterative section


    }
    print_total_timing();
    // display results
    let in_frame_1_acc = get_acc(in_frame_1, |idx, val| { bitcast[&mut[pixel_t]](in_frame_1.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](in_frame_1.buf.data)(idx));
    let in_frame_2_acc = get_acc(in_frame_2, |idx, val| { bitcast[&mut[pixel_t]](in_frame_2.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](in_frame_2.buf.data)(idx));
    let out_acc = get_acc(out, |idx, val| { bitcast[&mut[pixel_t]](out.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](out.buf.data)(idx));

    let roi_x = 0;
    let roi_y = 0;
    print_string("Frame 1 ");
    display_image(in_frame_1_acc, roi_x, roi_y);
    print_string("Frame 2 ");
    display_image(in_frame_2_acc, roi_x, roi_y);
    print_string("Optical flow:\n");
    display_image(out_acc, roi_x, roi_y);

    release(in_frame_1.buf);
    release(in_frame_2.buf);
    release(out.buf);
    0
}
