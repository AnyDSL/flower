fn init_data(arr: Img) -> () {
    let buf = bitcast[&mut[pixel_t]](arr.buf.data);

    for y in range(0, arr.height) {
        for x in range(0, arr.width) {
            let val = if ((((x % 16) >= 8) & (( y % 16) < 8)) | (((x % 16) < 8) & ((y % 16) >= 8))) == false {
                255 as pixel_t
            }
            else {
                0 as pixel_t
            };
            buf(y * arr.stride + x) = val;
        }
    }
}


fn main() -> i32 {
    let width  = 1024;
    let height = 1024;

    static mut channel_i_t : pipe;
    static mut channel_i_x : pipe;
    static mut channel_i_y : pipe;

    let in_frame_1 = create_host_img(width, height);
    let in_frame_2 = create_host_img(width, height);
    let out = create_host_img(width, height);

    let i_t = create_virtual_img(width, height, &mut channel_i_t );
    let i_x = create_virtual_img(width, height, &mut channel_i_x );
    let i_y = create_virtual_img(width, height, &mut channel_i_y );

    init_data(in_frame_1);
    init_data(in_frame_2);
    init_zero(bitcast[&mut[pixel_t]](out.buf.data), out.stride, out.height);

    let mask_x = get_mask3(sobel_maskx);
    let mask_y = get_mask3(sobel_masky);

    let lower = nobh_center;
    let upper = nobh_center;
    //let lower = clamp_lower;
    //let upper = clamp_upper;
    //let lower = mirro_lower;
    //let upper = mirro_upper;
    let enable_offset = 0;

    // Solving the following equation iteratively: I_x * u + I_y * v + I_t = 0
    // I_t        => differenec over frames
    // I_x , I_y  => Image derivative along x and y, respectively
    // Computing (u,v) indicating displacement

    for benchmark_host(num_host_iter) {
        // I_t
        for math, x, y, out, in_frame_1, in_frame_2 in iteration_point2(math, i_t, in_frame_1, in_frame_2) {
            let pix_i_t = in_frame_1 - in_frame_2;
            out.write(x, y, pix_i_t);
        }

        // I_x
        for math, x, y, out, in_frame_1, mask in iteration(math, i_x, in_frame_1, mask_x, lower, upper) {
            let pix_i_x = apply_stencil(x, y, in_frame_1, mask);
            out.write(x, y, pix_i_x);
        }

        // I_y
        for math, x, y, out, in_frame_1, mask in iteration(math, i_y, in_frame_1, mask_y, lower, upper) {
            let pix_i_y = apply_stencil(x, y, in_frame_1, mask);
            out.write(x, y, pix_i_y);
        }
    }
    print_total_timing();
    // display results
    let in_frame_1_acc = get_acc(in_frame_1, |idx, val| { bitcast[&mut[pixel_t]](in_frame_1.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](in_frame_1.buf.data)(idx));
    let in_frame_2_acc = get_acc(in_frame_2, |idx, val| { bitcast[&mut[pixel_t]](in_frame_2.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](in_frame_2.buf.data)(idx));
    let out_acc = get_acc(out, |idx, val| { bitcast[&mut[pixel_t]](out.buf.data)(idx) = val }, |idx| bitcast[&[pixel_t]](out.buf.data)(idx));

    let roi_x = 0;
    let roi_y = 0;
    print_string("Frame 1 ");
    display_image(in_frame_1_acc, roi_x, roi_y);
    print_string("Frame 2 ");
    display_image(in_frame_2_acc, roi_x, roi_y);
    print_string("Optical flow:\n");
    display_image(out_acc, roi_x, roi_y);

    release(in_frame_1.buf);
    release(in_frame_2.buf);
    release(out.buf);
    0
}
