extern "C" {
    fn print_string(&[u8]) -> ();
}

extern "thorin" {
    fn pe_info[T](&[u8], T) -> ();
}

type Loop = fn(i32, i32, fn(i32) -> ()) -> ();
type Loop_xy = fn(i32, i32, i32, i32, fn(i32, i32) -> ()) -> ();

fn @(?lower & ?upper & ?step) unroll_step(lower: i32, upper: i32, @step: i32, body: fn(i32) -> ()) -> () {
    if lower < upper {
        pe_info("counter: ", lower);
        body(lower);
        unroll_step(lower+step, upper, step, body)
    }
}

fn @unroll(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    unroll_step(lower, upper, 1, body)
}

fn range_step(lower: i32, upper: i32, step: i32, body: fn(i32) -> ()) -> () {
    if lower < upper {
        body(lower);
        range_step(lower+step, upper, step, body)
    }
}

fn @range(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    range_step(lower, upper, 1, body)
}

type Compute = fn(i32, i32) -> i32;

fn @schedule(loop: Loop_xy, w: i32, h: i32, fun: Compute) -> Compute {
    let out = ~[w*h:i32];
    for x, y in loop(0, 0, w, h) {
        out(y*h + x) = fun(x, y);
    }
    |x, y| out(y*h + x)
}

fn @combine_xy(loop_x: Loop, loop_y: Loop) -> Loop_xy {
    |x, y, w, h, body| loop_y(y, h, |yy| loop_x(x, w, |xx| body(xx, yy)))
}

fn @combine_xy2(loop: Loop) -> Loop_xy { combine_xy(loop, loop) }

fn @tile(x_step: i32, y_step: i32, w: i32, h: i32, loop_xy: Loop_xy) -> Loop_xy {
    |x, y, w, h, body: fn(i32, i32)->()| range_step(0, h, y_step, |yy| range_step(0, w, x_step, |xx| loop_xy(xx, yy, xx+x_step, yy+y_step, |xxx, yyy| body(xxx, yyy))))
}

fn main(input: &[i32], w: i32, h: i32) -> i32 {
    let a = |x, y| input(y*h + x);
    let b = |x, y| input(y*h + x);

    let c = |pre1, pre2| |x, y| pre1(x, y) + pre2(x, y);
    let d = schedule(tile(4, 8, w, h, combine_xy2(range)), w, h, c(a, b));
    let e = schedule(combine_xy2(range), w, h, d);
    e(0, 0)
}
