extern "C" {
    fn print_string(&[u8]) -> ();
}

extern "thorin" {
    fn pe_info[T](&[u8], T) -> ();
    fn parallel(num_threads: i32, lower: i32, upper: i32, body: fn(i32) -> ()) -> ();
    fn vectorize(vector_length: i32, alignment: i32, lower: i32, upper: i32, body: fn(i32) -> ()) -> ();
}

type Loop = fn(i32, i32, fn(i32) -> ()) -> ();
type Loop_xy = fn(i32, i32, i32, i32, fn(i32, i32) -> ()) -> ();
type Op = (fn((i32, i32), i32, i32) -> i32, i32, i32);

struct Img {
    width: i32,
    height: i32,
    data: &[i32]
};

fn @access(img: Img, x: i32, y:  i32) -> i32 { img.data(y*img.height + x) }

// range + unroll

fn @(?lower & ?upper & ?step) unroll_step(lower: i32, upper: i32, @step: i32, body: fn(i32) -> ()) -> () {
    if lower < upper {
        body(lower);
        unroll_step(lower+step, upper, step, body)
    }
}

fn @unroll(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    unroll_step(lower, upper, 1, body)
}

fn range_step(lower: i32, upper: i32, step: i32, body: fn(i32) -> ()) -> () {
    if lower < upper {
        body(lower);
        range_step(lower+step, upper, step, body)
    }
}

fn @range(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    range_step(lower, upper, 1, body)
}

fn @combine_xy(loop_x: Loop, loop_y: Loop) -> Loop_xy {
    |x, y, w, h, body| loop_y(y, h, |yy| loop_x(x, w, |xx| body(xx, yy)))
}

fn @combine_xy2(loop: Loop) -> Loop_xy { combine_xy(loop, loop) }

fn @tile(x_step: i32, y_step: i32, loop_xy: Loop_xy) -> Loop_xy {
    |x, y, w, h, body: fn(i32, i32)->()|
        range_step(0, h, y_step,
            |yy| range_step(0, w, x_step,
                |xx| loop_xy(xx, yy, xx+x_step, yy+y_step,
                    |xxx, yyy| body(xxx, yyy))))
}

fn vec(vector_length: i32) -> Loop {
    |lower, upper, body| vectorize(vector_length, 0, lower, upper, body)
}

fn par(num_threads: i32) -> Loop {
    |lower, upper, body| parallel(num_threads, lower, upper, body)
}

// schedule

fn @schedule(loop: Loop_xy, w: i32, h: i32, op: Op) -> fn(i32, i32) -> i32 {
    let out = ~[w*h:i32];
    let (f, x_extend, y_extend) = op;

    let x_region = [[0, x_extend], [x_extend, w-x_extend], [w-x_extend, w]];
    let y_region = [[0, y_extend], [y_extend, h-y_extend], [h-y_extend, h]];

    for ry in unroll(0, 3) @{
        for rx in unroll(0, 3) @{
            for x, y in loop(x_region(rx)(0), y_region(ry)(0), x_region(rx)(1), y_region(ry)(1)) {
                out(y*h + x) = f((rx, ry), x, y);
            }
        }
    }
    |x, y| out(y*h + x)
}

// border handling

fn @min(a: i32, b: i32) -> i32 { if a < b { a } else { b } }
fn @max(a: i32, b: i32) -> i32 { if a > b { a } else { b } }
fn @clip(v: i32, a: i32, b: i32) -> i32 { min(max(v, a), b) }

fn @is_within(region: (i32, i32), x: i32, y: i32, w: i32, h: i32) -> bool {
    let (rx, ry) = region;
    pe_info("region", region);
    let check = @|r, x, w| match r {
        0 => 0 <= x,
        2 => x < w,
        _ => true
    };
    check(rx, x, w) && check(ry, y, h)
}


fn @border_img(region: (i32, i32), img: Img, x: i32, y: i32, border: fn() -> i32) -> fn(i32, i32) -> i32 {
    @|x, y| if is_within(region, x, y, img.width, img.height) {
        access(img, x, y)
    } else {
        border()
    }
}

fn @border_const(v: i32) -> fn((i32, i32), Img, i32, i32) -> fn(i32, i32) -> i32 {
    @|region, img, x, y| border_img(region, img, x, y, @|| v)
}

fn @border_clamp(region: (i32, i32), img: Img, x: i32, y: i32) -> fn(i32, i32) -> i32 {
    border_img(region, img, x, y, @|| access(img, clip(x, 0, img.width), clip(y, 0, img.height)))
}

fn @border_mirror(region: (i32, i32), img: Img, x: i32, y: i32) -> fn(i32, i32) -> i32 {
    let mirror = @|x, w| if x < 0 { -x } else { if x >= w { w + w - x - 1 } else { x } };
    border_img(region, img, x, y, @|| access(img, mirror(x, img.width), mirror(y, img.height)))
}

// main

fn main(img: Img) -> i32 {
    let w = img.width;
    let h = img.height;
    let data = img.data;

    let blur = (@|region, x, y| {
        //let read = border_mirror(region, img, x, y);
        let read = border_const(0)(region, img, x, y);
        let blur_x = @|x, y| (  read(x-1, y) +   read(x, y) +   read(x+1, y))/3;
        let blur_y = @|x, y| (blur_x(x, y-1) + blur_x(x, y) + blur_x(x, y+1))/3;
        blur_y(x, y)
    }, 1, 1);

    //let res = schedule(combine_xy(range, range), w, h, blur);
    //let res = schedule(combine_xy(par(4), vec(8)), w, h, blur);
    let res = schedule(tile(256, 32, combine_xy(par(4), vec(8))), w, h, blur);
    0
}
