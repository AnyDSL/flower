// Stream types for data movements
struct stream_in {
    update: fn(int) -> (),
    read  : fn(int) -> pixel_t,
    pFactor  : int
}
struct stream_out {
    update: fn(int) -> (),
    write : fn(int, pixel_t) -> (),
    pFactor  : int
}

// Global memory read/write functions
fn @get_global_stream_vec1(data: &[i8]) -> stream_in {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { value = bitcast[&[1][pixel_t]](data)(idx); }
    fn @read(idx: int) -> pixel_t { value }
    stream_in { update : update, read : read, pFactor : 1 }
}
fn @get_global_stream_vec2(data: &[i8]) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 2 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  2]]](bitcast[&[1][pixel_t]](data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    stream_in { update : update, read : read, pFactor : 2 }
}
fn @get_global_stream_vec4(data: &[i8]) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 4 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  4]]](bitcast[&[1][pixel_t]](data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    stream_in { update : update, read : read, pFactor : 4 }
}
fn @get_global_stream_vec8(data: &[i8]) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 8 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t *  8]]](bitcast[&[1][pixel_t]](data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    stream_in { update : update, read : read, pFactor : 8 }
}
fn @get_global_stream_vec16(data: &[i8]) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 16 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t * 16]]](bitcast[&[1][pixel_t]](data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    stream_in { update : update, read : read, pFactor : 16 }
}
fn @get_global_stream_vec32(data: &[i8]) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 32 ];
    fn @update(idx: int) -> () { value = bitcast[&[1][[pixel_t * 32]]](bitcast[&[1][pixel_t]](data))(idx); }
    fn @read(idx: int) -> pixel_t { value(idx) }
    stream_in { update : update, read : read, pFactor : 32 }
}
fn @get_global_stream_from_img(img: Img, pFactor: int) -> stream_in {
    match pFactor {
         1 => get_global_stream_vec1(img.buf.data),
         2 => get_global_stream_vec2(img.buf.data),
         4 => get_global_stream_vec4(img.buf.data),
         8 => get_global_stream_vec8(img.buf.data),
        16 => get_global_stream_vec16(img.buf.data),
        32 => get_global_stream_vec32(img.buf.data),
         _ => undef[stream_in]()
    }
}

fn @set_global_stream_vec1(data: &[i8]) -> stream_out {
    let mut value = 0 as pixel_t;
    fn @update(idx: int) -> () { bitcast[&mut[1][pixel_t]](data)(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value = din; }
    stream_out { update : update, write : write, pFactor : 1 }
}
fn @set_global_stream_vec2(data: &[i8]) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 2 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  2]]](bitcast[&[1][pixel_t]](data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    stream_out { update : update, write : write, pFactor : 2 }
}
fn set_global_stream_vec4(data: &[i8]) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 4 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  4]]](bitcast[&[1][pixel_t]](data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    stream_out { update : update, write : write, pFactor : 4 }
}
fn set_global_stream_vec8(data: &[i8]) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 8 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t *  8]]](bitcast[&[1][pixel_t]](data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    stream_out { update : update, write : write, pFactor : 8 }
}
fn set_global_stream_vec16(data: &[i8]) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 16 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t * 16]]](bitcast[&[1][pixel_t]](data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    stream_out { update : update, write : write, pFactor : 16 }
}
fn set_global_stream_vec32(data: &[i8]) -> stream_out {
    let mut value = [ 0 as pixel_t, .. 32 ];
    fn @update(idx: int) -> () { bitcast[&mut[1][[pixel_t * 32]]](bitcast[&[1][pixel_t]](data))(idx) = value; }
    fn @write(idx: int, din: pixel_t) -> () { value(idx) = din; }
    stream_out { update : update, write : write, pFactor : 32 }
}
fn set_global_stream_from_img(img: Img, pFactor: int) -> stream_out {
    match pFactor {
         1 => set_global_stream_vec1(img.buf.data),
         2 => set_global_stream_vec2(img.buf.data),
         4 => set_global_stream_vec4(img.buf.data),
         8 => set_global_stream_vec8(img.buf.data),
        16 => set_global_stream_vec16(img.buf.data),
        32 => set_global_stream_vec32(img.buf.data),
         _ => undef[stream_out]()
    }
}


// Shared memory read/write functions
fn @new_shared_line_vec1(in_s: stream_in, width: int) -> stream_in {
    let mut value = 0 as pixel_t;
    let lbuf = reserve_shared[pixel_t](width);

    fn @shift(col: int) -> () {
        value     = lbuf(col);
        lbuf(col) = in_s.read(0);
    }

    stream_in {
        read   : @|v| value,
        update : shift,
        pFactor : 1
    }
}
fn @new_shared_line_vec2(in_s: stream_in, width: int) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let lbuf = reserve_shared[[pixel_t * 2]](width);

    fn @shift(col: int) -> () {
        value     = lbuf(col);
        let dlbin = [in_s.read(0), in_s.read(1)];
        lbuf(col) = dlbin;
    }

    stream_in {
        read   : @|v| value(v),
        update : shift,
        pFactor : 2
    }
}
fn @new_shared_line_vec4(in_s: stream_in, width: int) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let lbuf = reserve_shared[[pixel_t * 4]](width);

    fn @shift(col: int) -> () {
        value     = lbuf(col);
        let dlbin = [in_s.read(0), in_s.read(1), in_s.read(2), in_s.read(3)];
        lbuf(col) = dlbin;
    }

    stream_in {
        read   : @|v| value(v),
        update : shift,
        pFactor : 4
    }
}
fn @new_shared_line_vec8(in_s: stream_in, width: int) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let lbuf = reserve_shared[[pixel_t * 8]](width);

    fn @shift(col: int) -> () {
        value     = lbuf(col);
        let dlbin = [in_s.read(0), in_s.read(1), in_s.read(2), in_s.read(3),
                     in_s.read(4), in_s.read(5), in_s.read(6), in_s.read(7)];
        lbuf(col) = dlbin;
    }

    stream_in {
        read   : @|v| value(v),
        update : shift,
        pFactor : 8
    }
}
fn @new_shared_line_vec16(in_s: stream_in, width: int) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let lbuf = reserve_shared[[pixel_t * 16]](width);

    fn @shift(col: int) -> () {
        value     = lbuf(col);
        let dlbin = [in_s.read(0), in_s.read(1), in_s.read(2), in_s.read(3),
                     in_s.read(4), in_s.read(5), in_s.read(6), in_s.read(7),
                     in_s.read(8), in_s.read(9), in_s.read(10), in_s.read(11),
                     in_s.read(12), in_s.read(13), in_s.read(14), in_s.read(15)];
        lbuf(col) = dlbin;
    }

    stream_in {
        read   : @|v| value(v),
        update : shift,
        pFactor : 16
    }
}
fn @new_shared_line_vec32(in_s: stream_in, width: int) -> stream_in {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let lbuf = reserve_shared[[pixel_t * 32]](width);

    fn @shift(col: int) -> () {
        value     = lbuf(col);
        let dlbin = [in_s.read(0),  in_s.read(1),  in_s.read(2),  in_s.read(3),
                     in_s.read(4),  in_s.read(5),  in_s.read(6),  in_s.read(7),
                     in_s.read(8),  in_s.read(9),  in_s.read(10), in_s.read(11),
                     in_s.read(12), in_s.read(13), in_s.read(14), in_s.read(15),
                     in_s.read(16), in_s.read(17), in_s.read(18), in_s.read(19),
                     in_s.read(20), in_s.read(21), in_s.read(22), in_s.read(23),
                     in_s.read(24), in_s.read(25), in_s.read(26), in_s.read(27),
                     in_s.read(28), in_s.read(29), in_s.read(30), in_s.read(31)];
        lbuf(col) = dlbin;
    }

    stream_in {
        read   : @|v| value(v),
        update : shift,
        pFactor : 32
    }
}
fn @new_shared_line(in_s: stream_in, width: int) -> stream_in {
    match in_s.pFactor {
         1 => new_shared_line_vec1(in_s, width),
         2 => new_shared_line_vec2(in_s, width),
         4 => new_shared_line_vec4(in_s, width),
         8 => new_shared_line_vec8(in_s, width),
        16 => new_shared_line_vec16(in_s, width),
        32 => new_shared_line_vec32(in_s, width),
         _ => undef[stream_in]()
    }
}


//  -------------- Array of Registers --------------------
struct regs1d {
    write : fn(int, pixel_t) -> (),
    read  : fn(int) -> pixel_t,
    begin : int,
    end   : int
}

struct regs2d {
    write : fn(int, int, pixel_t) -> (),
    read  : fn(int, int) -> pixel_t,
    begin : (int, int),
    end   : (int, int)
}

fn @new_databeat(width: int) -> regs1d {
    new_regs1d(0, width)
}

fn @new_regs1d(begin: int, end: int) -> regs1d {
    if end == begin {
        regs1d {
            write : @|_, _| (),
            read  : @|_| undef[pixel_t](),
            begin : begin,
            end   : end
        }
    } else if begin + 1 == end {
        //pe_info("found", begin);
        let mut value = 0 as pixel_t;
        regs1d {
            write : @|i, v| value = v,
            read  : @|i| value,
            begin : begin,
            end   : end
        }
    } else {
        //pe_info("begin", begin);
        //pe_info("end", end);
        let m = (end + begin) / 2;
        let left  = new_regs1d(begin, m);
        let right = new_regs1d(m, end);
        regs1d {
            write : @|i, v| if i >= m { right.write(i, v) } else { left.write(i, v) },
            read  : @|i|    if i >= m { right.read(i) } else { left.read(i) },
            begin : begin,
            end   : end
        }
    }
}

fn @new_regs2d(begin: (int, int), end: (int, int)) -> regs2d {
    let (begin_x, begin_y) = begin;
    let (end_x, end_y)     = end;
    if end_y == begin_y {
        regs2d {
            write : @|_, _, _| (),
            read  : @|_, _| undef[pixel_t](),
            begin : begin,
            end   : end
        }
    } else if begin_y + 1 == end_y {
        let row = new_regs1d(begin_x, end_x);
        regs2d {
            write : @|x, y, v| row.write(x, v),
            read  : @|x, y|    row.read(x),
            begin : begin,
            end   : end
        }
    } else {
        let m = (end_y + begin_y) / 2;
        let left  = new_regs2d((begin_x, begin_y), (end_x, m));
        let right = new_regs2d((begin_x, m),       (end_x, end_y));
        regs2d {
            write : @|x, y, v| if y >= m { right.write(x, y, v) } else { left.write(x, y, v) },
            read  : @|x, y|    if y >= m { right.read(x, y) } else { left.read(x, y) },
            begin : begin,
            end   : end
        }
    }
}


//  ---- Instances of On Chip Memory: Line Buffers and Sliding Window  --------
// On Chip Memory
struct lbuftype {
    read  : fn(int, int) -> pixel_t,
    shift : fn(int) -> (),
    size_x : int,
    size_y : int
}
struct onchipmem {
    read  : fn(int, int) -> pixel_t,
    shift : fn(int, int) -> (),
    size_x : int,
    size_y : int
}

// Line Buffer
fn @new_line_buffer(in_s: stream_in, size_x: int, size_y: int) -> lbuftype {
    if size_y == 0 {
        lbuftype {
            read   : @|x, y| in_s.read(x),
            shift  : @|_| (),
            size_x : size_x,
            size_y : size_y
        }
    } else {
        let shared_s = new_shared_line(in_s, size_x);
        let sub_lbuf = new_line_buffer(shared_s, size_x, size_y - 1);
        lbuftype {
            read   : @|x, y| {
                if y == size_y {
                    in_s.read(x)
                } else {
                    sub_lbuf.read(x, y)
                }
            },
            shift  : @|col| {
                shared_s.update(col);
                sub_lbuf.shift(col)
            },
            size_x : size_x,
            size_y : size_y
        }
    }
}

// Sliding window
fn @new_sliding_win(lbufs: lbuftype, swin_x: int, swin_y: int, pFactor: int) -> onchipmem {
    let swin = new_regs2d((0, 0), (swin_x, swin_y));

    fn @shift() -> () {
        // Shift sliding window
        for j in unroll(0, swin_y) {
            for i in unroll(0, swin_x - pFactor) {
                swin.write(i, j, swin.read(i + pFactor, j));
            }
        }

        // Read new col
        for j in unroll(0, swin_y) {
            for v in unroll(0, pFactor) {
                swin.write((v + swin_x - pFactor), j, lbufs.read(v, j));
            }
        }
    }
    onchipmem {
        read  : @|x, y| {
            swin.read(x, y)
        },
        shift : @|col_ridx, row_ridx| {
            lbufs.shift(col_ridx);
            shift()
        },
        size_x : swin_x,
        size_y : swin_y
    }
}

// Sliding window
fn @new_sliding_win_simple(get_fun: fn(int, int) -> pixel_t, width: int, height: int, pFactor: int) -> onchipmem {
    let swin = new_regs2d((0, 0), (width, height));

    fn @shift() -> () {
        // Shift sliding window
        for j in unroll(0, height) {
            for i in unroll(0, width - pFactor) {
                swin.write(i, j, swin.read(i + pFactor, j));
            }
        }

        // Read new col
        for j in unroll(0, height) {
            for v in unroll(0, pFactor) {
                swin.write((v + width - pFactor), j, get_fun(v, j));
            }
        }
    }
    onchipmem {
        read  : swin.read,
        shift : @|col_ridx, row_ridx| shift(),
        size_x : width,
        size_y : height
    }
}

//  -------------------  Border Handling  ----------------------
type Bounds = (int, int);
type get_bounds_fun_type = fn(Boundary) -> Bounds;
type pixel_read_type = fn(int, int, Boundary, Bounds, fn(int) -> pixel_t) -> pixel_t;
type row_sel_fun_type = fn(fn(int) -> pixel_t, fn(int, pixel_t) -> (), int) -> ();

struct RoI1d {
    o_x : i32,
    width : i32,
}

struct borderhandling {
    get_read_fn : fn(int) -> fn(int, int) -> pixel_t,
    update      : fn(int) -> ()
}

struct coarsening_type {
    process : fn(int, int) -> ()
}

fn @new_bounds(lower: i32, lower_bh_pixels: i32, upper_bh_pixels: i32, upper: i32) -> get_bounds_fun_type {
    @|boundary| {
        match boundary {
            Boundary::Lower  => (lower, lower_bh_pixels),
            Boundary::Center => (lower_bh_pixels, upper_bh_pixels),
            Boundary::Upper  => (upper_bh_pixels, upper),
            _                => undef()
        }
    }
}

fn @iterate_1dborder(body: fn(Boundary) -> ()) -> () {
    for row in unroll(0, 3) {
        let boundary = get_boundary(row);
        @@body(boundary);
    }
}
fn @iterate_borders_1dregion(body: fn(Boundary) -> ()) -> () {
    @@body(Boundary::Lower);
    @@body(Boundary::Upper);
}

// sliding window with row selection
fn @new_sliding_win_bh(lbufs: lbuftype, swin_x: int, swin_y: int, pFactor: int, row_sel_fun: row_sel_fun_type) -> onchipmem {
    let swin = new_regs2d((0, 0), (swin_x, swin_y));
    let out_width = 4 + pFactor;
    let radius_y = 2;
    let get_bounds_fun = new_bounds(0, radius_y, radius_y + 1, 1 + 2 * radius_y);

    fn @shift(col_ridx: int, row_ridx: int) -> () {
        // Shift sliding window
        for j in unroll(0, swin_y) {
            for i in unroll(0, swin_x - pFactor) {
                swin.write(i, j, swin.read(i + pFactor, j));
            }
        }

        // Read new col: row selection
        for v in unroll(0, pFactor) {
            let get_fun =       @|j| { lbufs.read(v, j) };
            let set_fun = @|j, data| { swin.write(v + swin_x - pFactor, j, data) };

            row_sel_fun(get_fun, set_fun, row_ridx);
            //bh_type0_1d(get_fun, set_fun, 1, row_ridx, RoI1d { o_x : 2, width : 1024 }, get_bounds_fun, mirror_lower, mirror_upper);
        }
    }
    onchipmem {
        read  : @|x, y| {
            swin.read(x, y)
        },
        shift : @|col_ridx, row_ridx| {
            lbufs.shift(col_ridx);
            shift(col_ridx, row_ridx)
        },
        size_x : out_width,
        size_y : swin_y
    }
}

fn @get_pixel_read(pFactor: int, roi: RoI1d, bh_lower: BoundaryFn, bh_upper: BoundaryFn) -> pixel_read_type {
    let lower_arr   = roi.o_x;
    let upper_arr   = roi.o_x + roi.width;

    @|x, xw, boundary, bounds_win, read| {
        let lower_w = bounds_win(0);
        let upper_w = bounds_win(1);
        let radius = upper_w - lower_w;

        let mode_x = match boundary {
            Boundary::Lower => {
                let mut lower_high = lower_w;
                for i in unroll_step(0, radius, pFactor) {
                    if x == lower_arr + i / pFactor {
                        lower_high = upper_w - i;
                    }
                }
                bh_lower(xw, lower_high, 0)
            },
            Boundary::Center  => BoundaryMode::Index(xw),
            Boundary::Upper => {
                let mut upper_low = upper_w;
                for i in unroll_step(0, radius, pFactor) {
                    if x == upper_arr - 1 - i / pFactor {
                        upper_low = lower_w + i;
                    }
                }
                bh_upper(xw, 0, upper_low)
            },
            Boundary::Unknown => undef()
        };

        match mode_x {
            BoundaryMode::Index(idx) => read(idx),
            BoundaryMode::Const(c)   => c,
            _                        => undef()
        }
    }
}

fn @bh_type0_1d(pFactor: int, roi: RoI1d, get_bounds_fun: get_bounds_fun_type, bh_lower: BoundaryFn, bh_upper: BoundaryFn) -> row_sel_fun_type {
    @|get_fun, set_fun, idx| {
        let read_fun = get_pixel_read(pFactor, roi, bh_lower, bh_upper);
        for boundary in iterate_1dborder() {
            let bounds = get_bounds_fun(boundary);
            for xw in unroll(bounds(0), bounds(1)) {
                set_fun(xw, read_fun(idx, xw, boundary, bounds, get_fun));
            }
        }
    }
}

fn @new_type0(swin: onchipmem, pFactor: int, roi: RoI1d, get_bounds_fun: get_bounds_fun_type, bh_lower: BoundaryFn, bh_upper: BoundaryFn) -> borderhandling {
    let (lower_low, lower_high) = get_bounds_fun(Boundary::Lower);
    let (upper_low, upper_high) = get_bounds_fun(Boundary::Upper);
    let lower_regs = new_regs2d((lower_low, 0), (lower_high, swin.size_y));
    let upper_regs = new_regs2d((upper_low, 0), (upper_high, swin.size_y));
    let acc = Acc {
        read  : @|x, y|    { if x > upper_low - 1 && x < upper_high { upper_regs.read(x, y) }
                        else if x > lower_low - 1 && x < lower_high { lower_regs.read(x, y) }
                        else { swin.read(x, y) }},
        write : @|x, y, d| { if x > upper_low - 1 && x < upper_high { upper_regs.write(x, y, d) }
                        else if x > lower_low - 1 && x < lower_high { lower_regs.write(x, y, d) }
                        else {}}
    };

    let bh_fun = bh_type0_1d(pFactor, roi, get_bounds_fun, bh_lower, bh_upper);

    fn @update(col_ridx: int) -> () {
        for j in unroll(0, swin.size_y) {
            let get_fun = @|i|    { swin.read(i, j) };
            let set_fun = @|i, d| { acc.write(i, j, d) };

            bh_fun(get_fun, set_fun, col_ridx);
        }
    }

    borderhandling {
        get_read_fn : @|v| { @|x, y| acc.read(x + v, y) },
        update      : update
    }
}

//  -------------------  Loop Coarsening  ----------------------
fn @FetchAndCalc(math: Intrinsics, in_s: stream_in, out_s: stream_out, img_stride: int, mask: Mask, pFactor: int, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> coarsening_type {
    let radius_y = mask.size_y >> 1;
    let radius_x = mask.size_x >> 1;
    let win_lat = round_up(radius_x, pFactor) / pFactor;
    let swin_y = mask.size_y;
    let swin_x = radius_x + (1 + win_lat) * pFactor;
    let swin_x_opt = pFactor + 2 * radius_x;

    // border handling row selection
    let row_bounds_fun = new_bounds(0, radius_y, radius_y + 1, 1 + 2 * radius_y);
    let row_sel_fun = bh_type0_1d(1, RoI1d { o_x: 2, width: 1024 }, row_bounds_fun, bh_lower, bh_upper);

    // On Chip Memory Architecture
    let lbufs = new_line_buffer(in_s, img_stride, swin_y - 1);
    let swin = new_sliding_win_bh(lbufs, swin_x, swin_y, pFactor, row_sel_fun);

    // border handling col selection
    let get_bounds_fun = new_bounds(0, radius_x, radius_x + pFactor, swin_x_opt);
    let col_sel_type0 = new_type0(swin, pFactor, RoI1d { o_x: win_lat, width: 0 }, get_bounds_fun, bh_lower, bh_upper);

    fn @process(col_ridx: int, row_ridx: int) -> () {
        swin.shift(col_ridx, row_ridx);
        col_sel_type0.update(col_ridx);

        for v in unroll(0, pFactor) {
            let win_acc = Acc { read : col_sel_type0.get_read_fn(v), write : @|x, y, v| {} };
            let out_acc = Acc { read : |x, y| 0 as pixel_t,          write : @|x, y, data| out_s.write(v, data) };
            body(math, radius_x, radius_y, out_acc, win_acc, mask);
            //out_acc.write(0, 0, win_acc.read(2 * radius_x, radius_y));
        }
    }

    coarsening_type {
        process : process
    }
}

fn @CalcAndPack(math: Intrinsics, in_s: stream_in, out_s: stream_out, img_stride: int, mask: Mask, pFactor: int, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> coarsening_type {
    let radius_y = mask.size_y >> 1;
    let radius_x = mask.size_x >> 1;
    let swin_y = mask.size_y;
    let swin_x = pFactor + 2 * radius_x;

    // Border_handling
    let row_bounds_fun = new_bounds(0, radius_y, radius_y + 1, 1 + 2 * radius_y);
    let row_sel_fun = bh_type0_1d(1, RoI1d { o_x: 2, width: 1024 }, row_bounds_fun, bh_lower, bh_upper);

    // On Chip Memory Architecture
    let lbufs = new_line_buffer(in_s, img_stride, swin_y - 1);
    let swin = new_sliding_win_bh(lbufs, swin_x, swin_y, pFactor, row_sel_fun);

    // Constants for Packing
    let delay_width = (pFactor + ((pFactor - radius_x) % pFactor)) % pFactor;
    let pack_offset = pFactor - delay_width;
    let vec_delayed = new_databeat(delay_width);

    let col_sel_type0 = {
        if pack_offset == pFactor {
            let win_lat = round_up(radius_x, pFactor) / pFactor;
            let get_bounds_fun = new_bounds(0, radius_x, radius_x + pFactor, swin_x);
            new_type0(swin, pFactor, RoI1d { o_x : win_lat, width : 0 }, get_bounds_fun, bh_lower, bh_upper)
        } else {
            let win_lat = radius_x / pFactor;
            let roi = RoI1d { o_x : win_lat, width : 1 };
            let upper_low  = pack_offset + radius_x;
            let upper_get_bounds_fun = new_bounds(0, 0, upper_low, upper_low + radius_x);
            let lower_get_bounds_fun = new_bounds(upper_low - radius_x, upper_low, swin_x, swin_x);
            let upper = new_type0(swin, pFactor, roi, upper_get_bounds_fun, bh_lower, bh_upper);
            let lower = new_type0(swin, pFactor, roi, lower_get_bounds_fun, bh_lower, bh_upper);
            borderhandling {
                get_read_fn : @|v|   { if v < pack_offset { upper.get_read_fn(v) } else { lower.get_read_fn(v) } },
                update      : @|idx| { upper.update(idx); lower.update(idx); }
            }
        }
    };

    fn @pack(v: int) -> fn(int, int, pixel_t) -> () {
        @|x, y, data| {
            if  v < pack_offset {
                let pack_idx =  v + delay_width;
                out_s.write(pack_idx, data);
            } else {
                let pack_idx =  v - pack_offset;
                out_s.write(pack_idx, vec_delayed.read(pack_idx));
                vec_delayed.write(pack_idx, data);
            }
        }
    }

    fn @process(col_ridx: int, row_ridx: int) -> () {
        swin.shift(col_ridx, row_ridx);
        col_sel_type0.update(col_ridx);

        for v in unroll(0, pFactor) {
            let win_acc = Acc { read : col_sel_type0.get_read_fn(v), write : @|x, y, v| {} };
            let out_acc = Acc { read : @|x, y| 0 as pixel_t, write : pack(v) };
            body(math, radius_x, radius_y, out_acc, win_acc, mask);
            //vec_pix_out_acc.write(0, 0, in_acc.read(radius_x, radius_y));
        }
    }

    coarsening_type {
        process : process
    }
}


//  ------------------- Stencil Processing ----------------------
// coarsening: assumes that image_stride is factor of pFactor
// note that image stride was the factor of 64 at the time this mapping
// is developed (create_img)
fn @iteration(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    for benchmark_aocl(acc) {
        for tid, bid, bdim, gdim, gid in acc.exec((1,1,1), (1,1,1)) {
            let pFactor = 2;
            let radius_y = mask.size_y >> 1;
            let radius_x = mask.size_x >> 1;
            let win_lat = round_up(radius_x, pFactor) / pFactor;
            let crsn_width  = (arr.width - 1) / pFactor + 1;
            let crsn_stride = (arr.stride -1) / pFactor + 1;

            let in_s  = get_global_stream_from_img(arr_gpu, pFactor);
            let out_s = set_global_stream_from_img(out_gpu, pFactor);

            //let coarsening = FetchAndCalc(math, in_s, out_s, crsn_width, mask, pFactor, bh_lower, bh_upper, body);
            let coarsening = CalcAndPack (math, in_s, out_s, crsn_width, mask, pFactor, bh_lower, bh_upper, body);

            let process_time  = crsn_width * arr.height + 1;
            let initial_delay = crsn_width * radius_y + win_lat - 1;
            let life_time     = initial_delay + process_time;

            let mut col_ridx = 0; let mut row_ridx = 0;
            let mut col_widx = 0; let mut row_widx = 0;
            for clock_tick in range(0, life_time) {
                // read new pix
                if clock_tick < process_time {
                    in_s.update(row_ridx * crsn_stride + col_ridx);
                }

                // shift on chip mem
                coarsening.process(col_ridx, row_ridx);
                //for v in unroll(0, pFactor) { out_s.write(v, in_s.read(v)); }

                // write output
                if clock_tick > initial_delay {
                    out_s.update(row_widx * crsn_stride + col_widx);
                    col_widx++;
                }

                // update image indexes
                col_ridx++;
                if col_ridx == crsn_width { col_ridx = 0; row_ridx++; }
                if col_widx == crsn_width { col_widx = 0; row_widx++; }
            }
        }
        //acc.sync();
    }
    copy_img(out_gpu, out);
}
