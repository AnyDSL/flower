fn iteration(arr : Img, out : Img,
             body : fn(int, int, Acc, Acc) -> ()
            ) -> () {
    let unroll = 1;
    let dim = (out.width, out.height/unroll, 1);
    let block = (128, 1, 1);

    acc(acc_dev(), dim, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

        let arr_acc = Acc { img : arr, o_x : 0, o_y : 0 };
        let out_acc = Acc { img : out, o_x : 0, o_y : 0 };

        for i in @iterate(0, unroll) {
            body(gid_x, gid_y + i * acc_bdimy(), arr_acc, out_acc);
        }
    });
}

fn compute_config(ksize : (int, int), unroll : int) -> ((int, int, int), (int, int)) {
    fn compute_config_y (y_max : int) -> int {
        for n in range(1, y_max+1) {
            if n * unroll >= ksize(1) { return(n) }
        }
        y_max
    }

    let config_y_max = 4; // must be 1 for CPU on Mac OS X
    let config_x_max = 128;

    let threads_y = compute_config_y(config_y_max);
    let threads_x = config_x_max / threads_y;

    let blocks_x = round_up(ksize(0), threads_x) / threads_x;
    let blocks_y = round_up(ksize(1), threads_y) / threads_y;

    ((threads_x, threads_y, 1), (blocks_x, blocks_y))
}

fn iteration_bounds(ksize : int, arr : Img, out : Img,
                    body : fn(int, int, Acc, Acc, int) -> ()
                   ) -> () {
    // compute the number of blocks required for boundary handling
    let unroll = 1;
    let config = @compute_config((ksize/2, ksize/2), unroll);
    let block = config(0);
    let bx = config(1)(0);
    let by = config(1)(1);

    let arr_acc = Acc { img : arr, o_x : 0, o_y : 0 };
    let out_acc = Acc { img : out, o_x : 0, o_y : 0 };

    // define if we want to generate one big kernel or multiple kernels
    let big_kernel = true;

    if big_kernel {
        let dim = (out.width, out.height/unroll, 1);

        acc(acc_dev(), dim, block, || {
            let bid_x = acc_bidx();
            let bid_y = acc_bidy();
            let bdim_y = acc_bdimy();
            let gdim_x = acc_gdimx();
            let gdim_y = acc_gdimy();
            let gid_x = acc_gidx();
            let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

            // 0 --- 1 --- 2
            // 3 --- 4 --- 5
            // 6 --- 7 --- 8
            if (bid_x < bx && bid_y < by) {                 // top-left: 0
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 0);
                }
                return()
            }
            if (bid_x >= gdim_x-bx && bid_y < by) {         // top-right: 2
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 2);
                }
                return()
            }
            if (bid_y < by) {                               // top: 1
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 1);
                }
                return()
            }
            if (bid_y >= gdim_y-by && bid_x < bx) {         // bottom-left: 6
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 6);
                }
                return()
            }
            if (bid_y >= gdim_y-by && bid_x >= gdim_x-bx) { // bottom-right: 8
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 8);
                }
                return()
            }
            if (bid_y >= gdim_y-by) {                       // bottom: 7
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 7);
                }
                return()
            }
            if (bid_x >= gdim_x-bx) {                       // right: 5
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 5);
                }
                return()
            }
            if (bid_x < bx) {                               // left: 3
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 3);
                }
                return()
            }
            // no border handling
            for i in @iterate(0, unroll) {
                body(gid_x, gid_y + i * bdim_y, arr_acc, out_acc, 4);
            }
        });
    } else {
        // bounds account for unroll factor
        let hu = out.height/unroll;
        let Bounds2D = [
            (0                      , bx*block(0)            , 0               , by*block(1)),
            (bx*block(0)            , out.width - bx*block(0), 0               , by*block(1)),
            (out.width - bx*block(0), out.width              , 0               , by*block(1)),

            (0                      , bx*block(0)            , by*block(1)     , hu - by*block(1)),
            (bx*block(0)            , out.width - bx*block(0), by*block(1)     , hu - by*block(1)),
            (out.width - bx*block(0), out.width              , by*block(1)     , hu - by*block(1)),

            (0                      , bx*block(0)            , hu - by*block(1), hu),
            (bx*block(0)            , out.width - bx*block(0), hu - by*block(1), hu),
            (out.width - bx*block(0), out.width              , hu - by*block(1), hu)
        ];

        for region in @iterate(0, 9) {
            let bounds = Bounds2D(region);
            let dim = (bounds(1) - bounds(0), bounds(3) - bounds(2), 1);

            acc(acc_dev(), dim, block, || {
                let gid_x = bounds(0) +
                            acc_tidx() + acc_bdimx() * acc_bidx();
                let gid_y = bounds(2) * unroll +
                            acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * acc_bdimy(), arr_acc, out_acc, region);
                }
            });
        }
    }
}

fn iteration_advanced(ksize : int, arr : Img, out : Img,
                      body : fn(int, int, Acc, Acc, int) -> ()
                     ) -> () {
    let unroll = 1;
    let dim = (out.width, out.height/unroll, 1);
    // must be 1, 1, 1 for CPU on Mac OS X when local memory is used
    let block = (128, 1, 1);

    // compute number of steps required to stage data to shared memory
    let ksize2 = ksize / 2;
    let steps_x = 2;
    let offset_y = if (ksize-1)%block(1)==0 { 0 } else { 1 };
    let steps_y = unroll + (ksize-1)/block(1) + offset_y;

    // 0 -> generic
    // 1 -> global
    // 2 -> texture
    // 3 -> shared
    // 4 -> constant
    let dev = acc_dev();
    let gpu_arr = mmap(arr.data, dev, acc_tex(), 0, arr.width * arr.height);
    let gpu_out = mmap(out.data, dev, 1,         0, out.width * out.height);

    acc(dev, dim, block, || {
        let tid_x = acc_tidx();
        let tid_y = acc_tidy();
        let bdim_x = acc_bdimx();
        let bdim_y = acc_bdimy();
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

        let lstride = block(0) + 2 * ksize2;
        let lheight = block(1) * unroll + 2 * ksize2;
        let mut smem = mmap(arr.data, dev, 3, 0, lstride * lheight);
        let sma_img = Img { data : smem,    width : lstride,   height : lheight };
        let out_img = Img { data : gpu_out, width : out.width, height : out.height };
        let region = 4; // no bh

        for y in @range(0, steps_y) {
            let lid_y = tid_y + y*bdim_y;
            let mut idx_y = gid_y - ksize2 + y*bdim_y;
            idx_y = clamp_lower(idx_y, 0);
            idx_y = clamp_upper(idx_y, arr.height);
            for x in @range(0, steps_x) {
                let lid_x = tid_x + x*bdim_x;
                let mut idx_x = gid_x - ksize2 + x*bdim_x;
                idx_x = clamp_lower(idx_x, 0);
                idx_x = clamp_upper(idx_x, arr.width);

                if (lid_x < lstride && lid_y < lheight) {
                    smem(lid_y * lstride + lid_x) = gpu_arr(idx_y * arr.width + idx_x);
                }
            }
        }

        acc_barrier();

        for i in @iterate(0, unroll) {
            // index space: block
            let out_acc = Acc { img : out_img, o_x : acc_bdimx() * acc_bidx(), o_y : acc_bdimy() * acc_bidy() * unroll + i * bdim_y };
            let arr_acc = Acc { img : sma_img, o_x : ksize2,                   o_y : ksize2 + i * bdim_y };
            body(tid_x, tid_y, arr_acc, out_acc, region);
        }
    });
}

fn iteration_sep(arr : Img, out : Img,
                 body : fn(int, int, Acc, Acc, bool) -> ()
                ) -> () {
    let unroll = 1;
    let dim = (out.width, out.height/unroll, 1);
    let block = (128, 1, 1);

    // allocate temporary array
    let tmp = Img { data : ~[out.width*out.height:float], width : out.width, height : out.height };
    init_zero(tmp.data, $tmp.width, $tmp.height);
    let arr_acc = Acc { img : arr, o_x : 0, o_y : 0 };
    let out_acc = Acc { img : out, o_x : 0, o_y : 0 };
    let tmp_acc = Acc { img : tmp, o_x : 0, o_y : 0 };

    let dev = acc_dev();
    acc(dev, dim, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
        let is_row = false;

        for i in @iterate(0, unroll) {
            body(gid_x, gid_y + i * acc_bdimy(), arr_acc, tmp_acc, is_row);
        }
    });
    acc(dev, dim, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
        let is_row = true;

        for i in @iterate(0, unroll) {
            body(gid_x, gid_y + i * acc_bdimy(), tmp_acc, out_acc, is_row);
        }
    });
}

fn iteration_sep_bounds(ksize : int, arr : Img, out : Img,
                        body : fn(int, int, Acc, Acc, bool, int) -> ()
                       ) -> () {
    // compute the number of blocks required for boundary handling
    let unroll = 1;
    let config = @compute_config((ksize/2, ksize/2), unroll);
    let block = config(0);
    let bx = config(1)(0);
    let by = config(1)(1);

    // allocate temporary array
    let tmp = Img { data : ~[out.width*out.height:float], width : out.width, height : out.height };
    init_zero(tmp.data, $tmp.width, $tmp.height);
    let arr_acc = Acc { img : arr, o_x : 0, o_y : 0 };
    let out_acc = Acc { img : out, o_x : 0, o_y : 0 };
    let tmp_acc = Acc { img : tmp, o_x : 0, o_y : 0 };

    // define if we want to generate one big kernel or multiple kernels
    let big_kernel = false;

    if big_kernel {
        let dim = (out.width, out.height/unroll, 1);

        // column component
        acc(acc_dev(), dim, block, || {
            let bid_y = acc_bidy();
            let bdim_y = acc_bdimy();
            let gdim_y = acc_gdimy();
            let gid_x = acc_gidx();
            let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
            let is_row = false;

            // 0
            // 1
            // 2
            if (bid_y < by) {                               // top: 0
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, tmp_acc, is_row, 0);
                }
                return()
            }
            if (bid_y >= gdim_y-by) {                       // bottom: 2
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, arr_acc, tmp_acc, is_row, 2);
                }
                return()
            }
            // no border handling
            for i in @iterate(0, unroll) {
                body(gid_x, gid_y + i * bdim_y, arr_acc, tmp_acc, is_row, 1);
            }
        });

        // row component
        acc(acc_dev(), dim, block, || {
            let bid_x = acc_bidx();
            let bdim_y = acc_bdimy();
            let gdim_x = acc_gdimx();
            let gid_x = acc_gidx();
            let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
            let is_row = true;

            // 0 --- 1 --- 2
            if (bid_x < bx) {                               // left: 0
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, tmp_acc, out_acc, is_row, 0);
                }
                return()
            }
            if (bid_x >= gdim_x-bx) {                       // right: 2
                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * bdim_y, tmp_acc, out_acc, is_row, 2);
                }
                return()
            }
            // no border handling
            for i in @iterate(0, unroll) {
                body(gid_x, gid_y + i * bdim_y, tmp_acc, out_acc, is_row, 1);
            }
        });
    } else {
        let hu = out.height / unroll;
        let Bounds2DCol = [
            (0               , by*block(1)),
            (by*block(1)     , hu - by*block(1)),
            (hu - by*block(1), hu)
        ];

        for region in @iterate(0, 3) {
            let bounds = Bounds2DCol(region);
            let dim = (out.width, bounds(1) - bounds(0), 1);

            acc(acc_dev(), dim, block, || {
                let gid_x = acc_gidx();
                let gid_y = bounds(0) * unroll +
                            acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
                let is_row = false;

                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * acc_bdimy(), arr_acc, tmp_acc, is_row, region);
                }
            });
        }

        let Bounds2DRow = [
            (0                      , bx*block(0)),
            (bx*block(0)            , out.width - bx*block(0)),
            (out.width - bx*block(0), out.width)
        ];

        for region in @iterate(0, 3) {
            let bounds = Bounds2DRow(region);
            let dim = (bounds(1) - bounds(0), out.height/unroll, 1);

            acc(acc_dev(), dim, block, || {
                let gid_x = bounds(0) + acc_gidx();
                let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
                let is_row = true;

                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * acc_bdimy(), tmp_acc, out_acc, is_row, region);
                }
            });
        }
    }
}

fn iteration_sep_advanced(ksize : int, arr : Img, out : Img,
                          body : fn(int, int, Acc, Acc, bool, int) -> ()
                         ) -> () {
    let unroll = 1;
    let dim = (out.width, out.height/unroll, 1);
    // must be 1, 1, 1 for CPU on Mac OS X when local memory is used
    let block = (128, 1, 1);

    // compute number of steps required to stage data to shared memory
    let ksize2 = ksize / 2;
    let steps_x = 2;
    let offset_y = if (ksize-1)%block(1)==0 { 0 } else { 1 };
    let steps_y = unroll + (ksize-1)/block(1) + offset_y;

    // 0 -> generic
    // 1 -> global
    // 2 -> texture
    // 3 -> shared
    // 4 -> constant
    let dev = acc_dev();
    let gpu_arr = mmap(arr.data, dev, acc_tex(), 0, arr.width * out.height);
    let gpu_out = mmap(out.data, dev, 1,         0, out.width * out.height);

    acc(dev, dim, block, || {
        let tid_x = acc_tidx();
        let tid_y = acc_tidy();
        let bdim_x = acc_bdimx();
        let bdim_y = acc_bdimy();
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

        let lstride = block(0) + 2 * ksize2;
        let lheight_col = block(1) * unroll + 2 * ksize2;
        let lheight_row = block(1) * unroll;
        let mut smem_col = mmap(arr.data, dev, 3, 0, lstride * lheight_col);
        let     smem_row = mmap(arr.data, dev, 3, 0, lstride * lheight_row);
        let smr_img = Img { data : smem_row, width : lstride, height : lheight_row };
        let smc_img = Img { data : smem_col, width : lstride, height : lheight_col };
        let out_img = Img { data : gpu_out, width : out.width, height : out.height };
        let region = 1; // no bh


        for y in @range(0, steps_y) {
            let lid_y = tid_y + y*bdim_y;
            let mut idx_y = gid_y - ksize2 + y*bdim_y;
            idx_y = clamp_lower(idx_y, 0);
            idx_y = clamp_upper(idx_y, arr.height);
            for x in @range(0, steps_x) {
                let lid_x = tid_x + x*bdim_x;
                let mut idx_x = gid_x - ksize2 + x*bdim_x;
                idx_x = clamp_lower(idx_x, 0);
                idx_x = clamp_upper(idx_x, arr.width);

                if (lid_x < lstride && lid_y < lheight_col) {
                    smem_col(lid_y * lstride + lid_x) = gpu_arr(idx_y * arr.width + idx_x);
                }
            }
        }

        acc_barrier();

        for i in @iterate(0, unroll) {
            // index space: block
            let is_row = false;
            let out_acc = Acc { img : smr_img, o_x : ksize2, o_y :          i * bdim_y };
            let arr_acc = Acc { img : smc_img, o_x : ksize2, o_y : ksize2 + i * bdim_y };
            body(tid_x, tid_y, arr_acc, out_acc, is_row, region);

            if (tid_x < ksize2) {
                // left halo
                let out_acc = Acc { img : smr_img, o_x : 0, o_y :          i * bdim_y };
                let arr_acc = Acc { img : smc_img, o_x : 0, o_y : ksize2 + i * bdim_y };
                @body(tid_x, tid_y, arr_acc, out_acc, is_row, region);
            }
            if (tid_x >= bdim_x-ksize2) {
                // right halo
                let out_acc = Acc { img : smr_img, o_x : ksize2 + ksize2, o_y :          i * bdim_y };
                let arr_acc = Acc { img : smc_img, o_x : ksize2 + ksize2, o_y : ksize2 + i * bdim_y };
                @body(tid_x, tid_y, arr_acc, out_acc, is_row, region);
            }
        }

        acc_barrier();

        for i in @iterate(0, unroll) {
            // index space: block
            let is_row = true;
            let out_acc = Acc { img : out_img, o_x : acc_bdimx() * acc_bidx(), o_y : acc_bdimy() * acc_bidy() * unroll + i * bdim_y };
            let arr_acc = Acc { img : smr_img, o_x : ksize2,                   o_y : i * bdim_y };
            body(tid_x, tid_y, arr_acc, out_acc, is_row, region);
        }
    });
}

fn iteration_multi(width : int, height : int,
                   arr : &[float], out : &[float],
                   body : fn(int, int, &[float], &[float]) -> ()
                  ) -> () {
    let dim = (width, height/2, 1);
    let block = (128, 1, 1);

    let dev_gpu1 = 0;
    let map_arr_GPU1 = mmap(arr, dev_gpu1, 1, 0, width * height/2);
    let map_out_GPU1 = mmap(out, dev_gpu1, 1, 0, width * height/2);

    acc(dev_gpu1, dim, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_gidy();

        @body(gid_x, gid_y, map_arr_GPU1, map_out_GPU1);
    });

    let dev_gpu2 = 1;
    let map_arr_GPU2 = mmap(arr, dev_gpu2, 1, width * height/2, width * height/2);
    let map_out_GPU2 = mmap(out, dev_gpu2, 1, width * height/2, width * height/2);

    acc(dev_gpu2, dim, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_gidy();

        @body(gid_x, gid_y, map_arr_GPU2, map_out_GPU2);
    });
}
