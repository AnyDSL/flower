fn compute_config(m_range : (int, int), unroll : int) -> ((int, int, int), (int, int)) {
    fn compute_config_y (y_max : int) -> int {
        if m_range(1) > 1 { return(y_max) }
        for n in range(1, y_max+1) {
            if n * unroll >= m_range(1) { return(n) }
        }
        y_max
    }

    let config_y_max = 4;   // must be 1 for CPU on Mac OS X
    let config_x_max = 128; // use 256 for AMD GPUs; 512 for Intel MIC

    let threads_y = compute_config_y(config_y_max);
    let threads_x = config_x_max / threads_y;

    let blocks_x = round_up(m_range(0), threads_x) / threads_x;
    let blocks_y = round_up(m_range(1), threads_y) / threads_y;

    ((threads_x, threads_y, 1), (blocks_x, blocks_y))
}

fn iteration(out: Img, arr: Img, mask: Mask,
             body: fn(int, int, Acc, Acc, Mask) -> ()
            ) -> () {
    let unroll = 1;
    let config = @compute_config((mask.size_x/2, mask.size_y/2), unroll);
    let grid   = (out.width, out.height/unroll, 1);
    let block  = config(0);

    acc(acc_dev(), grid, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

        for i in @iterate(0, unroll) {
            let arr_acc = get_acc(arr, 10);
            let out_acc = get_acc(out, 10);
            body(gid_x, gid_y + i * acc_bdimy(), out_acc, arr_acc, mask);
        }
    });
}

fn iteration_bounds(out: Img, arr: Img, mask: Mask,
                    body: fn(int, int, Acc, Acc, Mask) -> ()
                   ) -> () {
    // compute the number of blocks required for boundary handling
    let unroll = 1;
    let config = @compute_config((mask.size_x/2, mask.size_y/2), unroll);
    let block  = config(0);
    let bx     = config(1)(0);
    let by     = config(1)(1);

    // define if we want to generate one big kernel or multiple kernels
    let big_kernel = false;

    if big_kernel {
        let grid = (out.width, out.height/unroll, 1);

        acc(acc_dev(), grid, block, || {
            let bid_x = acc_bidx();
            let bid_y = acc_bidy();
            let bdim_y = acc_bdimy();
            let gdim_x = acc_gdimx();
            let gdim_y = acc_gdimy();
            let gid_x = acc_gidx();
            let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

            // 0 --- 1 --- 2
            // 3 --- 4 --- 5
            // 6 --- 7 --- 8
            if bid_x < bx && bid_y < by {                   // top-left: 0
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 0);
                    let out_acc = get_acc(out, 0);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
                return()
            }
            if bid_x >= gdim_x-bx && bid_y < by {           // top-right: 2
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 2);
                    let out_acc = get_acc(out, 2);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
                return()
            }
            if bid_y < by {                                 // top: 1
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 1);
                    let out_acc = get_acc(out, 1);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
                return()
            }
            if bid_y >= gdim_y-by && bid_x < bx {           // bottom-left: 6
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 6);
                    let out_acc = get_acc(out, 6);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
                return()
            }
            if bid_y >= gdim_y-by && bid_x >= gdim_x-bx {   // bottom-right: 8
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 8);
                    let out_acc = get_acc(out, 8);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
                return()
            }
            if bid_y >= gdim_y-by {                         // bottom: 7
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 7);
                    let out_acc = get_acc(out, 7);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
                return()
            }
            if bid_x >= gdim_x-bx {                         // right: 5
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 5);
                    let out_acc = get_acc(out, 5);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
                return()
            }
            if bid_x < bx {                                 // left: 3
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 3);
                    let out_acc = get_acc(out, 3);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
                return()
            }
            {                                               // center: 4
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, 4);
                    let out_acc = get_acc(out, 4);
                    body(gid_x, gid_y + i * bdim_y, out_acc, arr_acc, mask);
                }
            }
        });
    } else {
        // bounds account for unroll factor
        let hu = out.height/unroll;
        let Bounds2D = [
            (0                      , bx*block(0)            , 0               , by*block(1)),
            (bx*block(0)            , out.width - bx*block(0), 0               , by*block(1)),
            (out.width - bx*block(0), out.width              , 0               , by*block(1)),

            (0                      , bx*block(0)            , by*block(1)     , hu - by*block(1)),
            (bx*block(0)            , out.width - bx*block(0), by*block(1)     , hu - by*block(1)),
            (out.width - bx*block(0), out.width              , by*block(1)     , hu - by*block(1)),

            (0                      , bx*block(0)            , hu - by*block(1), hu),
            (bx*block(0)            , out.width - bx*block(0), hu - by*block(1), hu),
            (out.width - bx*block(0), out.width              , hu - by*block(1), hu)
        ];

        for region in @iterate(0, 9) {
            let bounds = Bounds2D(region);
            let grid   = (bounds(1) - bounds(0), bounds(3) - bounds(2), 1);

            let arr_acc = get_acc(arr, region);
            let out_acc = get_acc(out, region);

            acc(acc_dev(), grid, block, || {
                let gid_x = bounds(0) +
                            acc_tidx() + acc_bdimx() * acc_bidx();
                let gid_y = bounds(2) * unroll +
                            acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * acc_bdimy(), out_acc, arr_acc, mask);
                }
            });
        }
    }
}

fn iteration_advanced(out: Img, arr: Img, mask: Mask,
                      body: fn(int, int, Acc, Acc, Mask) -> ()
                     ) -> () {
    let unroll = 1;
    let config = @compute_config((mask.size_x/2, mask.size_y/2), unroll);
    let grid   = (out.width, out.height/unroll, 1);
    let block  = config(0);

    // compute number of steps required to stage data to shared memory
    let m_range_x = mask.size_x / 2;
    let m_range_y = mask.size_y / 2;
    let steps_x = 2;
    let offset_y = if (mask.size_y-1)%block(1)==0 { 0 } else { 1 };
    let steps_y = unroll + (mask.size_y-1)/block(1) + offset_y;

    let dev = acc_dev();
    let gpu_arr = mmap(arr.data, dev, acc_tex(), 0, arr.width * arr.height);
    let gpu_out = mmap(out.data, dev, acc_mem(), 0, out.width * out.height);

    acc(dev, grid, block, || {
        let tid_x = acc_tidx();
        let tid_y = acc_tidy();
        let bdim_x = acc_bdimx();
        let bdim_y = acc_bdimy();
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

        let lstride = block(0) + 2 * m_range_x;
        let lheight = block(1) * unroll + 2 * m_range_y;
        let mut smem = mmap(arr.data, dev, @acc_spm(), 0, lstride * lheight);
        let sma_img = Img { data : smem,    width : lstride,   height : lheight,    stride : lstride };
        let out_img = Img { data : gpu_out, width : out.width, height : out.height, stride : out.width };

        let region = 4; // center: no bh

        for y in @range(0, steps_y) {
            let lid_y = tid_y + y*bdim_y;
            let idx_y = gid_y - m_range_y + y*bdim_y;
            for x in @range(0, steps_x) {
                let lid_x = tid_x + x*bdim_x;
                let idx_x = gid_x - m_range_x + x*bdim_x;

                let gpu_img = Img { data : gpu_arr, width : arr.width, height : arr.height, stride : arr.stride };
                let gpu_acc = get_acc(gpu_img, 10); // TODO: set region!

                // TODO: move this to inner loop ...
                let val = get_pixel(gpu_acc, idx_x, idx_y, clamp_lower, clamp_upper);
                if lid_x < lstride && lid_y < lheight {
                    smem(lid_y * lstride + lid_x) = val;
                }
            }
        }

        acc_barrier();

        for i in @iterate(0, unroll) {
            // index space: block
            let out_acc = Acc { img : out_img, roi : RoI { o_x : 0, o_y : 0, width : out_img.width, height : out_img.height },
                                               rox : acc_bdimx() * acc_bidx(), roy : acc_bdimy() * acc_bidy() * unroll + i * bdim_y, region : region };
            let arr_acc = Acc { img : sma_img, roi : RoI { o_x : 0, o_y : 0, width : sma_img.width, height : sma_img.height },
                                               rox : m_range_x,                roy : m_range_y + i * bdim_y,                         region : region };
            body(tid_x, tid_y, out_acc, arr_acc, mask);
        }
    });
    //munmap(gpu_arr);
    //munmap(gpu_out);
}

fn iteration_sep(out: Img, arr: Img, mask: MaskSep,
                 body: fn(int, int, Acc, Acc, MaskSep, bool) -> ()
                ) -> () {
    let unroll = 1;
    let config = @compute_config((mask.size/2, mask.size/2), unroll);
    let grid   = (out.width, out.height/unroll, 1);
    let block  = config(0);

    // allocate temporary array
    let tmp = Img { data : ~[out.width*out.height:float], width : out.width, height : out.height, stride : out.width };
    $init_zero(tmp.data, tmp.stride, tmp.height);
    let arr_acc = get_acc(arr, 10);
    let out_acc = get_acc(out, 10);
    let tmp_acc = get_acc(tmp, 10);

    let dev = acc_dev();
    acc(dev, grid, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
        let is_row = false;

        for i in @iterate(0, unroll) {
            body(gid_x, gid_y + i * acc_bdimy(), tmp_acc, arr_acc, mask, is_row);
        }
    });
    acc(dev, grid, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
        let is_row = true;

        for i in @iterate(0, unroll) {
            body(gid_x, gid_y + i * acc_bdimy(), out_acc, tmp_acc, mask, is_row);
        }
    });
}

fn iteration_sep_bounds(out: Img, arr: Img, mask: MaskSep,
                        body: fn(int, int, Acc, Acc, MaskSep, bool) -> ()
                       ) -> () {
    // compute the number of blocks required for boundary handling
    let unroll = 1;
    let config = @compute_config((mask.size/2, mask.size/2), unroll);
    let block  = config(0);
    let bx     = config(1)(0);
    let by     = config(1)(1);

    let Region2DCol = [ 1, 4, 7 ];
    let Region2DRow = [ 3, 4, 5 ];

    // allocate temporary array
    let tmp = Img { data : ~[out.width*out.height:float], width : out.width, height : out.height, stride : out.width };
    $init_zero(tmp.data, tmp.stride, tmp.height);

    // define if we want to generate one big kernel or multiple kernels
    let big_kernel = false;

    if big_kernel {
        let grid = (out.width, out.height/unroll, 1);

        // column component
        acc(acc_dev(), grid, block, || {
            let bid_y = acc_bidy();
            let bdim_y = acc_bdimy();
            let gdim_y = acc_gdimy();
            let gid_x = acc_gidx();
            let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
            let is_row = false;

            if bid_y < by {                                 // top: 1
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, Region2DCol(0));
                    let tmp_acc = get_acc(tmp, Region2DCol(0));
                    body(gid_x, gid_y + i * bdim_y, tmp_acc, arr_acc, mask, is_row);
                }
                return()
            }
            if bid_y >= gdim_y-by {                         // bottom: 7
                for i in @iterate(0, unroll) {
                    let arr_acc = get_acc(arr, Region2DCol(2));
                    let tmp_acc = get_acc(tmp, Region2DCol(2));
                    body(gid_x, gid_y + i * bdim_y, tmp_acc, arr_acc, mask, is_row);
                }
                return()
            }
            for i in @iterate(0, unroll) {                  // center: 4
                let arr_acc = get_acc(arr, Region2DCol(1));
                let tmp_acc = get_acc(tmp, Region2DCol(1));
                body(gid_x, gid_y + i * bdim_y, tmp_acc, arr_acc, mask, is_row);
            }
        });

        // row component
        acc(acc_dev(), grid, block, || {
            let bid_x = acc_bidx();
            let bdim_y = acc_bdimy();
            let gdim_x = acc_gdimx();
            let gid_x = acc_gidx();
            let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
            let is_row = true;

            if bid_x < bx {                                 // left: 3
                for i in @iterate(0, unroll) {
                    let tmp_acc = get_acc(tmp, Region2DRow(0));
                    let out_acc = get_acc(out, Region2DRow(0));
                    body(gid_x, gid_y + i * bdim_y, out_acc, tmp_acc, mask, is_row);
                }
                return()
            }
            if bid_x >= gdim_x-bx {                         // right: 5
                for i in @iterate(0, unroll) {
                    let tmp_acc = get_acc(tmp, Region2DRow(2));
                    let out_acc = get_acc(out, Region2DRow(2));
                    body(gid_x, gid_y + i * bdim_y, out_acc, tmp_acc, mask, is_row);
                }
                return()
            }
            {                                               // center: 4
                for i in @iterate(0, unroll) {
                    let tmp_acc = get_acc(tmp, Region2DRow(1));
                    let out_acc = get_acc(out, Region2DRow(1));
                    body(gid_x, gid_y + i * bdim_y, out_acc, tmp_acc, mask, is_row);
                }
            }
        });
    } else {
        let hu = out.height / unroll;
        let Bounds2DCol = [
            (0               , by*block(1)),
            (by*block(1)     , hu - by*block(1)),
            (hu - by*block(1), hu)
        ];

        for iter in @iterate(0, 3) {
            let region = Region2DCol(iter);
            let bounds = Bounds2DCol(iter);
            let grid   = (out.width, bounds(1) - bounds(0), 1);

            let arr_acc = get_acc(arr, region);
            let tmp_acc = get_acc(tmp, region);

            acc(acc_dev(), grid, block, || {
                let gid_x = acc_gidx();
                let gid_y = bounds(0) * unroll +
                            acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
                let is_row = false;

                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * acc_bdimy(), tmp_acc, arr_acc, mask, is_row);
                }
            });
        }

        let Bounds2DRow = [
            (0                      , bx*block(0)),
            (bx*block(0)            , out.width - bx*block(0)),
            (out.width - bx*block(0), out.width)
        ];

        for iter in @iterate(0, 3) {
            let region = Region2DRow(iter);
            let bounds = Bounds2DRow(iter);
            let grid   = (bounds(1) - bounds(0), out.height/unroll, 1);

            let tmp_acc = get_acc(tmp, region);
            let out_acc = get_acc(out, region);

            acc(acc_dev(), grid, block, || {
                let gid_x = bounds(0) + acc_gidx();
                let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;
                let is_row = true;

                for i in @iterate(0, unroll) {
                    body(gid_x, gid_y + i * acc_bdimy(), out_acc, tmp_acc, mask, is_row);
                }
            });
        }
    }
}

fn iteration_sep_advanced(out: Img, arr: Img, mask: MaskSep,
                          body: fn(int, int, Acc, Acc, MaskSep, bool) -> ()
                         ) -> () {
    let unroll = 1;
    let config = @compute_config((mask.size/2, mask.size/2), unroll);
    let grid   = (out.width, out.height/unroll, 1);
    let block  = config(0);

    // compute number of steps required to stage data to shared memory
    let m_range = mask.size / 2;
    let steps_x = 2;
    let offset_y = if (mask.size-1)%block(1)==0 { 0 } else { 1 };
    let steps_y = unroll + (mask.size-1)/block(1) + offset_y;

    let dev = acc_dev();
    let gpu_arr = mmap(arr.data, dev, acc_tex(), 0, arr.width * out.height);
    let gpu_out = mmap(out.data, dev, acc_mem(), 0, out.width * out.height);

    acc(dev, grid, block, || {
        let tid_x = acc_tidx();
        let tid_y = acc_tidy();
        let bdim_x = acc_bdimx();
        let bdim_y = acc_bdimy();
        let gid_x = acc_gidx();
        let gid_y = acc_tidy() + acc_bdimy() * acc_bidy() * unroll;

        let lstride = block(0) + 2 * m_range;
        let lheight_col = block(1) * unroll + 2 * m_range;
        let lheight_row = block(1) * unroll;
        let mut smem_col = mmap(arr.data, dev, @acc_spm(), 0, lstride * lheight_col);
        let     smem_row = mmap(arr.data, dev, @acc_spm(), 0, lstride * lheight_row);
        let smr_img = Img { data : smem_row, width : lstride,  height : lheight_row, stride : lstride };
        let smc_img = Img { data : smem_col, width : lstride,  height : lheight_col, stride : lstride };
        let out_img = Img { data : gpu_out,  width : out.width, height : out.height, stride : out.width };

        let region = 4; // center: no bh

        for y in @range(0, steps_y) {
            let lid_y = tid_y + y*bdim_y;
            let idx_y = gid_y - m_range + y*bdim_y;
            for x in @range(0, steps_x) {
                let lid_x = tid_x + x*bdim_x;
                let idx_x = gid_x - m_range + x*bdim_x;

                let gpu_img = Img { data : gpu_arr, width : arr.width, height : arr.height, stride : arr.stride };
                let gpu_acc = get_acc(gpu_img, 10); // TODO: set region!

                // TODO: move this to inner loop ...
                let val = get_pixel(gpu_acc, idx_x, idx_y, clamp_lower, clamp_upper);
                if lid_x < lstride && lid_y < lheight_col {
                    smem_col(lid_y * lstride + lid_x) = val;
                }
            }
        }

        acc_barrier();

        for i in @iterate(0, unroll) {
            let is_row = false;
            {
                // index space: block
                let out_acc = Acc { img : smr_img, roi : RoI { o_x : 0, o_y : 0, width : smr_img.width, height : smr_img.height }, rox : m_range, roy :           i * bdim_y, region : region };
                let arr_acc = Acc { img : smc_img, roi : RoI { o_x : 0, o_y : 0, width : smc_img.width, height : smc_img.height }, rox : m_range, roy : m_range + i * bdim_y, region : region };
                body(tid_x, tid_y, out_acc, arr_acc, mask, is_row);
            }
            if tid_x < m_range {
                // left halo
                let out_acc = Acc { img : smr_img, roi : RoI { o_x : 0, o_y : 0, width : smr_img.width, height : smr_img.height }, rox : 0, roy :           i * bdim_y, region : region };
                let arr_acc = Acc { img : smc_img, roi : RoI { o_x : 0, o_y : 0, width : smc_img.width, height : smc_img.height }, rox : 0, roy : m_range + i * bdim_y, region : region };
                @body(tid_x, tid_y, out_acc, arr_acc, mask, is_row);
            }
            if tid_x >= bdim_x-m_range {
                // right halo
                let out_acc = Acc { img : smr_img, roi : RoI { o_x : 0, o_y : 0, width : smr_img.width, height : smr_img.height }, rox : m_range + m_range, roy :           i * bdim_y, region : region };
                let arr_acc = Acc { img : smc_img, roi : RoI { o_x : 0, o_y : 0, width : smc_img.width, height : smc_img.height }, rox : m_range + m_range, roy : m_range + i * bdim_y, region : region };
                @body(tid_x, tid_y, out_acc, arr_acc, mask, is_row);
            }
        }

        acc_barrier();

        for i in @iterate(0, unroll) {
            // index space: block
            let is_row = true;
            let out_acc = Acc { img : out_img, roi : RoI { o_x : 0, o_y : 0, width : out_img.width, height : out_img.height },
                                               rox : acc_bdimx() * acc_bidx(), roy : acc_bdimy() * acc_bidy() * unroll + i * bdim_y, region : region };
            let arr_acc = Acc { img : smr_img, roi : RoI { o_x : 0, o_y : 0, width : smr_img.width, height : smr_img.height },
                                               rox : m_range,                  roy : i * bdim_y,                                     region : region };
            body(tid_x, tid_y, out_acc, arr_acc, mask, is_row);
        }
    });
    //munmap(gpu_arr);
    //munmap(gpu_out);
}

fn iteration_multi(width: int, height: int,
                   out: &[float], arr: &[float],
                   body: fn(int, int, &[float], &[float]) -> ()
                  ) -> () {
    let grid  = (width, height/2, 1);
    let block = (128, 1, 1);

    let dev_gpu1 = 0;
    let map_arr_GPU1 = mmap(arr, dev_gpu1, acc_tex(), 0, width * height/2);
    let map_out_GPU1 = mmap(out, dev_gpu1, acc_mem(), 0, width * height/2);

    acc(dev_gpu1, grid, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_gidy();

        @body(gid_x, gid_y, map_out_GPU1, map_arr_GPU1);
    });

    //munmap(map_arr_GPU1);
    //munmap(map_out_GPU1);

    let dev_gpu2 = 1;
    let map_arr_GPU2 = mmap(arr, dev_gpu2, acc_tex(), width * height/2, width * height/2);
    let map_out_GPU2 = mmap(out, dev_gpu2, acc_mem(), width * height/2, width * height/2);

    acc(dev_gpu2, grid, block, || {
        let gid_x = acc_gidx();
        let gid_y = acc_gidy();

        @body(gid_x, gid_y, map_out_GPU2, map_arr_GPU2);
    });

    //munmap(map_arr_GPU2);
    //munmap(map_out_GPU2);
}
