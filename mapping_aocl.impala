// Stream types for data movements
struct stream_in{
    update: fn(int) -> (),
    read  : fn(int) -> pixel_t,
    pFactor  : int
}
struct stream_out{
    update: fn(int) -> (),
    write : fn(int, pixel_t) -> (),
    pFactor  : int
}

// Global memory read/write functions
fn get_global_stream_vec1(data: &[i8]) -> stream_in {
    let mut value = undef[pixel_t]();
    fn update(idx : int) -> () { value = bitcast[&[1][pixel_t]](data)(idx); }
    fn read(idx: int) -> pixel_t { value };
    stream_in{update: update, read: read, pFactor: 1}
}
fn get_global_stream_vec2(data: &[i8]) -> stream_in {
    let mut value = undef[[pixel_t * 2]]();
    fn update(idx : int) -> () { value = bitcast[&[1][[pixel_t *  2]]](data)(idx); }
    fn read(idx: int) -> pixel_t { value(idx) };
    stream_in{update: update, read: read, pFactor: 2}
}
fn get_global_stream_vec4(data: &[i8]) -> stream_in {
    let mut value = undef[[pixel_t * 4]]();
    fn update(idx : int) -> () { value = bitcast[&[1][[pixel_t *  4]]](data)(idx); }
    fn read(idx: int) -> pixel_t { value(idx) };
    stream_in{update: update, read: read, pFactor: 4}
}
fn get_global_stream_vec8(data: &[i8]) -> stream_in {
    let mut value = undef[[pixel_t * 8]]();
    fn update(idx : int) -> () { value = bitcast[&[1][[pixel_t *  8]]](data)(idx); }
    fn read(idx: int) -> pixel_t { value(idx) };
    stream_in{update: update, read: read, pFactor: 8}
}
fn get_global_stream_from_img(img: Img,  pFactor: int) -> stream_in{
        match pFactor {
            1 => get_global_stream_vec1(img.buf.data),
            2 => get_global_stream_vec2(img.buf.data),
            4 => get_global_stream_vec4(img.buf.data),
            8 => get_global_stream_vec8(img.buf.data),
            _ => undef[stream_in]()
        }
}

fn set_global_stream_vec1(data: &[i8]) -> stream_out {
    let mut value = undef[pixel_t]();
    fn update(idx : int) -> () { bitcast[&mut[1][pixel_t]](data)(idx) = value; }
    fn write(idx: int, din: pixel_t) -> () { value = din; };
    stream_out{update: update, write : write, pFactor : 1}
}
fn set_global_stream_vec2(data: &[i8]) -> stream_out {
    let mut value = undef[[pixel_t * 2]]();
    fn update(idx : int) -> () { bitcast[&mut[1][[pixel_t *  2]]](data)(idx) = value; }
    fn write(idx: int, din: pixel_t) -> () { value(idx) = din; };
    stream_out{update: update, write : write, pFactor : 2}
}
fn set_global_stream_vec4(data: &[i8]) -> stream_out {
    let mut value = undef[[pixel_t * 4]]();
    fn update(idx : int) -> () { bitcast[&mut[1][[pixel_t *  4]]](data)(idx) = value; }
    fn write(idx: int, din: pixel_t) -> () { value(idx) = din; };
    stream_out{update: update, write : write, pFactor : 4}
}
fn set_global_stream_vec8(data: &[i8]) -> stream_out {
    let mut value = undef[[pixel_t * 8]]();
    fn update(idx : int) -> () { bitcast[&mut[1][[pixel_t *  8]]](data)(idx) = value; }
    fn write(idx: int, din: pixel_t) -> () { value(idx) = din; };
    stream_out{update: update, write : write, pFactor : 8}
}
fn set_global_stream_from_img(img: Img,  pFactor: int) -> stream_out{
        match pFactor {
            1 => set_global_stream_vec1(img.buf.data),
            2 => set_global_stream_vec2(img.buf.data),
            4 => set_global_stream_vec4(img.buf.data),
            8 => set_global_stream_vec8(img.buf.data),
            _ => undef[stream_out]()
        }
}


// Shared memory read/write functions
fn new_shared_line_vec1(in_s: stream_in, width: int) -> stream_in {
    let mut value = undef[pixel_t]();
    let lbuf = reserve_shared[pixel_t](width);

    fn shift(col: int) -> () {
        value     = lbuf(col);
        lbuf(col) = in_s.read(0);
    }

    stream_in {
        read   : |v| value,
        update : shift,
        pFactor : 1
    }
}
fn new_shared_line_vec2(in_s: stream_in, width: int) -> stream_in {
    let mut value = undef[[pixel_t * 2]]();
    let lbuf = reserve_shared[[pixel_t * 2]](width);

    fn shift(col: int) -> () {
        value     = lbuf(col);
        let dlbin = [in_s.read(0), in_s.read(1)];
        lbuf(col) = dlbin;
    }

    stream_in {
        read   : |v| value(v),
        update : shift,
        pFactor : 2
    }
}
fn new_shared_line_vec4(in_s: stream_in, width: int) -> stream_in {
    let mut value = undef[[pixel_t * 4]]();
    let lbuf = reserve_shared[[pixel_t * 4]](width);

    fn shift(col: int) -> () {
        value     = lbuf(col);
        let dlbin = [in_s.read(0), in_s.read(1), in_s.read(2), in_s.read(3)];
        lbuf(col) = dlbin;
    }

    stream_in {
        read   : |v| value(v),
        update : shift,
        pFactor : 4
    }
}
fn new_shared_line_vec8(in_s: stream_in, width: int) -> stream_in {
    let mut value = undef[[pixel_t * 8]]();
    let lbuf = reserve_shared[[pixel_t * 8]](width);

    fn shift(col: int) -> () {
        value     = lbuf(col);
        let dlbin = [in_s.read(0), in_s.read(1), in_s.read(2), in_s.read(3), 
                     in_s.read(4), in_s.read(5), in_s.read(6), in_s.read(7)];
        lbuf(col) = dlbin;
    }

    stream_in {
        read   : |v| value(v),
        update : shift,
        pFactor : 8
    }
}
fn new_shared_line(in_s: stream_in, width: int) -> stream_in {
        match in_s.pFactor {
            1 => new_shared_line_vec1(in_s, width),
            2 => new_shared_line_vec2(in_s, width),
            4 => new_shared_line_vec4(in_s, width),
            8 => new_shared_line_vec8(in_s, width),
            _ => undef[stream_in]()
        }
}


//  -------------- Array of Registers --------------------
struct regs1d {
    write : fn(int, pixel_t) -> (),
    read  : fn(int) -> pixel_t,
    begin : int,
    end   : int
}

struct regs2d {
    write : fn(int, int, pixel_t) -> (),
    read  : fn(int, int) -> pixel_t,
    begin : (int, int),
    end   : (int, int)
}

fn new_regs1d(begin: int, end: int) -> regs1d {
    if end == begin {
        regs1d {
            write : |_, _| (),
            read  : |_| undef[pixel_t](),
            begin : begin,
            end   : end
        }
    } else if begin + 1 == end {
        //pe_info("found", begin);
        let mut value = 0 as pixel_t; 
        regs1d {
            write : |i, v| value = v,
            read  : |i| value,
            begin : begin,
            end   : end
        }
    } else {
        //pe_info("begin", begin);
        //pe_info("end", end);
        let m = (end + begin) / 2;
        let left  = new_regs1d(begin, m);
        let right = new_regs1d(m, end);
        regs1d {
            write : |i, v| if i >= m { right.write(i, v) } else { left.write(i, v) },
            read  : |i|    if i >= m { right.read(i) } else { left.read(i) },
            begin : begin,
            end   : end
        }
    }
}

fn new_regs2d(begin: (int, int), end: (int, int)) -> regs2d {
    let (begin_x, begin_y) = begin;
    let (end_x, end_y)     = end;
    if end_y == begin_y {
        regs2d {
            write : |_, _, _| (),
            read  : |_, _| undef[pixel_t](),
            begin : begin,
            end   : end
        }
    } else if begin_y + 1 == end_y {
        let row = new_regs1d(begin_x, end_x);
        regs2d {
            write : |x, y, v| row.write(x, v),
            read  : |x, y|    row.read(x),
            begin : begin,
            end   : end
        }
    } else {
        let m = (end_y + begin_y) / 2;
        let left  = new_regs2d((begin_x, begin_y), (end_x, m));
        let right = new_regs2d((begin_x, m),       (end_x, end_y));
        regs2d {
            write : |x, y, v| if y >= m { right.write(x, y, v) } else { left.write(x, y, v) },
            read  : |x, y|    if y >= m { right.read(x, y) } else { left.read(x, y) },
            begin : begin,
            end   : end
        }
    }
}


//  ---- Instances of On Chip Memory: Line Buffers and Sliding Window  --------
// On Chip Memory
struct onchipmem {
    read  : fn(int, int) -> pixel_t,
    shift : fn(int) -> (),
    size_x : int,
    size_y : int
}


// Line Buffer
fn new_LineBuffer(in_s: stream_in, size_x: int, size_y: int) -> onchipmem {
    if size_y == 0 {
        onchipmem {
            read   : |_, _| undef[pixel_t](),
            shift  : |_| (),
            size_x : size_x,
            size_y : size_y
        }
    } else {
        let shared_s = @new_shared_line(in_s, size_x);
        let sub_lbuf = @new_LineBuffer(shared_s, size_x, size_y - 1);
        onchipmem {
            read   : |x, y| {
                if y == size_y - 1 {
                    @shared_s.read(x)
                } else {
                    sub_lbuf.read(x, y)
                }
            },
            shift  : |col| {
                @shared_s.update(col);
                @sub_lbuf.shift(col)
            },
            size_x : size_x,
            size_y : size_y
        }
    }
}


// Sliding window
fn new_sliding_win(lbufs: onchipmem, swin_x: int, swin_y: int, pFactor: int) -> onchipmem {
    let swin = @new_regs2d((0, 0), (swin_x, swin_y));

    fn shift() -> () {
        // Shift sliding window
        for j in @range(0, swin_y) {
            for i in @range(0, swin_x - pFactor) {
                @swin.write(i, j, @swin.read(i + pFactor, j));
            }
        }

        // Read new col
        for j in @range(0, swin_y) {
            for v in @range(0, pFactor) {
                @swin.write((v + swin_x - pFactor), j, lbufs.read(v, j));
            }
        }
    };
    onchipmem {
        read  : |x, y| {
            swin.read(x, y)
        },
        shift : |col_ridx| {
            @lbufs.shift(col_ridx);
            shift();
        },
        size_x : swin_x,
        size_y : swin_y
    }
}

// (mask_y - 1) line buffers -> swin
fn new_onchipmem(in_s: stream_in, image_x: int, swin_x: int, swin_y: int, pFactor: int) -> onchipmem {
    let stride = image_x/pFactor;
    let lbufs = @new_LineBuffer(in_s, stride, swin_y - 1);

    let lbufs_acc = onchipmem {
        read    : |x, y|  {
            if y == swin_y - 1 { in_s.read(x)     }
            else               { lbufs.read(x, y) }
        },
        shift   : lbufs.shift,
        size_x  : pFactor,
        size_y  : swin_y
    };

    @new_sliding_win(lbufs_acc, swin_x, swin_y, pFactor)
}


//  -------------------  Loop Coarsening  ----------------------
struct coarsening_type {
    shift   : fn(int) -> (),
    process : fn() -> (),
}

fn FetchAndCalc(math: Intrinsics, in_s: stream_in, out_s: stream_out, image_x: int, mask: Mask, pFactor: int, body: StencilFn) -> coarsening_type {
    let half_range_y      = mask.size_y >> 1;
    let half_range_x      = mask.size_x >> 1;
    let right_half_radius = ((half_range_x - 1) / pFactor) + 1;
    let swin_x            = half_range_x + (1 + right_half_radius) * pFactor;
    let swin_y            = mask.size_y;

    // On Chip Memory Architecture
    let OnChipMem = new_onchipmem(in_s, image_x, swin_x, swin_y, pFactor);
    //let OnChipMem = new_OnChipMem_alteraOne_noswin_vec(image_x, swin_x, swin_y, pFactor);

    fn process() -> () {
        for v in @range(0, pFactor) @{
            let OnChipMem_acc = Acc {
                    read  : |x, y|    OnChipMem.read(x + v, y),
                    write : |x, y, v| {}
            };
            let vec_pix_out_acc = Acc {
                read  : |x, y|       0 as pixel_t,
                write : |x, y, data| out_s.write(v, data)
            };
            @body(math, half_range_x, half_range_y, vec_pix_out_acc, OnChipMem_acc, mask);
            //vec_pix_out_acc.write(0, 0, OnChipMem_acc.read(half_range_x, half_range_y));
        }
    }

    coarsening_type {
        shift   : OnChipMem.shift,
        process : process
    }
}

//  ------------------- Stencil Processing ----------------------
// coarsening: assumes that image_width is factor of pFactor
fn iteration(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    for benchmark_aocl(acc) {
        with acc.exec((1,1,1), (1,1,1)) @{
            let half_range_y    = mask.size_y >> 1;
            let half_range_x    = mask.size_x >> 1;
            let pFactor = 1;
            let kVecRightRadius = ((half_range_x - 1) / pFactor) + 1;
            let kVecImageWidth  = arr.width / pFactor;

            let process_time    = kVecImageWidth * arr.height;
            let initial_delay   = kVecImageWidth * half_range_y + kVecRightRadius - 1;
            let life_time       = initial_delay + process_time;

            let in_s  = get_global_stream_from_img(arr_gpu, pFactor);
            let out_s = set_global_stream_from_img(out_gpu, pFactor);

            let coarsening = FetchAndCalc(math, in_s, out_s, arr.width, mask, pFactor, body);
            //let coarsening = CalcAndPack(math, arr.width, mask, pFactor, body);

            let mut col_ridx = 0; let mut row_ridx = 0;
            let mut col_widx = 0; let mut row_widx = 0;
            for clock_tick in $range(0, life_time) {
                // read new pix
                if clock_tick < process_time {
                    in_s.update(row_ridx * kVecImageWidth + col_ridx);
                }

                // Shift on chip mem
                @coarsening.shift(col_ridx);
                @coarsening.process();
                //for v in @range(0, pFactor) {@out_s.write(v, in_s.read(v));

                // write output
                if clock_tick > initial_delay {
                    out_s.update(row_widx * kVecImageWidth + col_widx);
                    col_widx++;
                }

                // update image indexes
                col_ridx++;
                if col_ridx == kVecImageWidth { col_ridx = 0; row_ridx++; }
                if col_widx == kVecImageWidth { col_widx = 0; row_widx++; }
            }
        }
        //acc.sync();
    }
    copy_img(out_gpu, out);
}


// ------------- Comparison reasons -----------------------------------------
//  // Altera style One row buffer, no Sliding window
//  fn new_OnChipMem_alteraOne_noswin_vec(image_x: int, swin_x: int, swin_y: int, pFactor: int) -> onchipmem {
//      let lbuf_size = image_x * (swin_y - 1) + swin_x;
//      let lbuf = reserve_shared[pixel_t](lbuf_size);
//      let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), image_x, swin_y);
//
//      fn shift(vec_pix_new: data_beat) -> () {
//          // shift lbuf : (lb2swin, pix_new) -> lbuf
//          for i in $range(0, lbuf_size - pFactor) {
//              lbuf(i) = lbuf(i + pFactor);
//          }
//          for v in @range(0, pFactor) {
//              lbuf(lbuf_size - pFactor + v) = vec_pix_new.read(v);
//          }
//      }
//
//      onchipmem {
//          read  : |x, y|   lbuf_acc.read(x, y),
//          shift : |x, idx| shift(x)
//      }
//  }
//  // Vivado style Multiple
//  fn new_onchipmem(image_x: int, swin_x: int, swin_y: int, pFactor: int) -> onchipmem {
//      let swin = @new_sliding_win(swin_x, swin_y, pFactor);
//      let lbuf = @new_smem1d(image_x, swin_y - 1);
//      let lb2swin = @new_regs2d ((0, 0), (pFactor, swin_y));
//
//      fn shift_lbuf2D(vec_pix_new: data_beat, col_ridx: i32) -> () {
//          // read from lbuf : lbuf -> lb2swin
//          for j in @range(0, lbuf.size_y) {
//              for v in @range(0, pFactor) {
//                  @lb2swin.write(v, j, @lbuf.read((col_ridx + v), j));
//              }
//          }
//          for v in @range(0, pFactor) {
//              @lb2swin.write(v, lbuf.size_y, vec_pix_new.read(v));
//          }
//  
//          // shift lbuf : (lb2swin, vec_pix_new) -> lbuf
//          for j in @range(0, lbuf.size_y - 1) {
//              for v in @range(0, pFactor) {
//                  @lbuf.write((col_ridx + v), j, lb2swin.read(v, j + 1));
//              }
//          }
//          for v in @range(0, pFactor) {
//              @lbuf.write((col_ridx + v), lbuf.size_y - 1, vec_pix_new.read(v));
//          }
//      }
//      fn shift(vec_pix_new: data_beat, col_ridx: i32) -> () {
//          //shift line buffers
//          shift_lbuf2D(vec_pix_new, col_ridx);
//  
//          // shift sliding window
//          @swin.shift(lb2swin);
//      }
//
//      onchipmem {
//          read  : |x, y| swin.read(x, y),
//          shift : shift,
//      }
//  }

// // Vivado style Multiple
// fn new_onchipmem(image_x: int, swin_x: int, swin_y: int, pFactor: int) -> onchipmem {
//     let swin = @new_sliding_win(swin_x, swin_y, pFactor);
//     let lbuf = @new_smem1d(image_x, swin_y - 1);
//     let lb2swin = @new_regs2d ((0, 0), (pFactor, swin_y));
//
//     fn shift_lbuf2D(vec_pix_new: data_beat, col_ridx: i32) -> () {
//         // read from lbuf : lbuf -> lb2swin
//         for j in @range(0, lbuf.size_y) {
//             for v in @range(0, pFactor) {
//                 @lb2swin.write(v, j, @lbuf.read((col_ridx + v), j));
//             }
//         }
//         for v in @range(0, pFactor) {
//             @lb2swin.write(v, lbuf.size_y, vec_pix_new.read(v));
//         }
//
//         // shift lbuf : (lb2swin, vec_pix_new) -> lbuf
//         for j in @range(0, lbuf.size_y - 1) {
//             for v in @range(0, pFactor) {
//                 @lbuf.write((col_ridx + v), j, lb2swin.read(v, j + 1));
//             }
//         }
//         for v in @range(0, pFactor) {
//             @lbuf.write((col_ridx + v), lbuf.size_y - 1, vec_pix_new.read(v));
//         }
//     }
//     fn shift(vec_pix_new: data_beat, col_ridx: i32) -> () {
//         //shift line buffers
//         shift_lbuf2D(vec_pix_new, col_ridx);
//
//         // shift sliding window
//         @swin.shift(lb2swin);
//     }
//
//     onchipmem {
//         read  : |x, y| swin.read(x, y),
//         shift : shift,
//     }
// }

// Coarsening types
// fn FetchAndCalc(math: Intrinsics, image_x: int, mask: Mask, pFactor: int, body: StencilFn) -> coarsening_type {
//     let half_range_y      = mask.size_y >> 1;
//     let half_range_x      = mask.size_x >> 1;
//     let right_half_radius = ((half_range_x - 1) / pFactor) + 1;
//     let swin_x            = half_range_x + (1 + right_half_radius) * pFactor;
//     let swin_y            = mask.size_y;
//
//     // On Chip Memory Architecture
//     let OnChipMem = new_onchipmem(image_x, swin_x, swin_y, pFactor);
//     //let OnChipMem = new_OnChipMem_alteraOne_noswin_vec(image_x, swin_x, swin_y, pFactor);
//
//     fn process() -> data_beat {
//         let vec_pix_out = @new_data_beat(pFactor);
//         for v in @range(0, pFactor) @{
//             let OnChipMem_acc = Acc {
//                     read  : |x, y|    OnChipMem.read(x + v, y),
//                     write : |x, y, v| {}
//             };
//             let vec_pix_out_acc = Acc {
//                 read  : |x, y|       0.0f,
//                 write : |x, y, data| vec_pix_out.write(v, data)
//             };
//             @body(math, half_range_x, half_range_y, vec_pix_out_acc, OnChipMem_acc, mask);
//             //vec_pix_out_acc.write(0, 0, OnChipMem_acc.read(half_range_x, half_range_y));
//         }
//         vec_pix_out
//     }
//
//     coarsening_type {
//         shift   : |vec_new, col_ridx| OnChipMem.shift(vec_new, col_ridx),
//         process : process
//     }
// }
//
// fn CalcAndPack(math: Intrinsics, image_x: int, mask: Mask, pFactor: int, body: StencilFn) -> coarsening_type {
//     let half_range_y = mask.size_y >> 1;
//     let half_range_x = mask.size_x >> 1;
//     let swin_x       = mask.size_x - 1 + pFactor;
//     let swin_y       = mask.size_y;
//
//     // On Chip Memory Architecture
//     let OnChipMem = new_onchipmem(image_x, swin_x, swin_y, pFactor);
//     //let OnChipMem = new_OnChipMem_alteraOne_noswin_vec(image_x, swin_x, swin_y, pFactor);
//
//     // Constants for Pack
//     let delayed_pixels_size = ((pFactor + ((pFactor - half_range_x) % pFactor)) % pFactor);
//     let pack_offset         = pFactor - delayed_pixels_size;
//
//     let vec_delayed = @new_data_beat(delayed_pixels_size);
//     fn process() -> data_beat {
//         let vec_pix_out = @new_data_beat(pFactor);
//         for v in @range(0, pFactor) @{
//             let OnChipMem_acc = Acc {
//                     read  : |x, y|    OnChipMem.read(x + v, y),
//                     write : |x, y, v| {}
//             };
//             let vec_pix_out_acc = Acc {
//                 read  : |x, y| 0.0f,
//                 write : |x, y, data| {
//                     if  v < pack_offset {
//                         let pack_idx =  v + delayed_pixels_size;
//                         @vec_pix_out.write(pack_idx, data)
//                     } else {
//                         let pack_idx =  v - pack_offset;
//                         @vec_pix_out.write(pack_idx, @vec_delayed.read(pack_idx));
//                         @vec_delayed.write(pack_idx, data);
//                     }
//                 }
//             };
//             @body(math, half_range_x, half_range_y, vec_pix_out_acc, OnChipMem_acc, mask);
//             //vec_pix_out_acc.write(0, 0, OnChipMem_acc.read(half_range_x, half_range_y));
//         }
//         vec_pix_out
//     }
//
//     coarsening_type {
//         shift   : |vec_new, col_ridx| OnChipMem.shift(vec_new, col_ridx),
//         process : process
//     }
// }
