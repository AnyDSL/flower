fn release_device_copy(img: Img) -> () {
    release(img.buf)
}

fn get_ldg_fn() -> fn(&[1]f32) -> f32 { if is_nvvm() { nvvm_ldg_f32 } else { cuda_ldg_f32 } }
fn set_pixel_fn(img: Img) -> fn(i32, f32) -> () { |idx, val| bitcast[&mut[1][f32]](img.buf.data)(idx) = val }
fn get_pixel_fn(img: Img) -> fn(i32) -> f32 { |idx| bitcast[&[1][f32]](img.buf.data)(idx) }
fn get_pixel_ldg_fn(img: Img) -> fn(i32) -> f32 { if has_ldg() { |idx| get_ldg_fn()(&bitcast[&[1][f32]](img.buf.data)(idx)) } else { get_pixel_fn(img) } }
fn set_pixel_shared_fn(data: &mut[3][f32]) -> fn(i32, f32) -> () { |idx, val| data(idx) = val }
fn get_pixel_shared_fn(data: &[3][f32]) -> fn(i32) -> f32 { |idx| data(idx) }

struct Swin1D {
    write: fn (int, f32) -> (),
    read: fn (int) -> f32,
    begin: int,
    end: int
}

struct Swin2D {
    write: fn (int, int, f32) -> (),
    read: fn (int, int) -> f32,
    begin: (int, int),
    end: (int, int)
}

fn new_swin1D(begin: int, end: int) -> Swin1D {
    if end == begin {
        Swin1D {
            write: |_, _| (),
            read:  |_| undef[f32](),
            begin: begin,
            end:   end
        }
    } else if begin + 1 == end {
        let mut value : f32;
        Swin1D {
            write: |i, v| value = v,
            read:  |i| value,
            begin: begin,
            end:   end
        }
    } else {
        let m = (end + begin) / 2;
        let left  = new_swin1D(begin, m);
        let right = new_swin1D(m, end);
        Swin1D {
            write: |i, v| if i >= m { right.write(i, v) } else { left.write(i, v) },
            read:  |i|    if i >= m { right.read(i) } else { left.read(i) },
            begin: begin,
            end:   end
        }
    }
}

fn new_swin2D(begin: (int, int), end: (int, int)) -> Swin2D {
    let (begin_x, begin_y) = begin;
    let (end_x, end_y)     = end;
    if end_y == begin_y {
        Swin2D {
            write: |_, _, _| (),
            read: |_, _| undef[f32](),
            begin: begin,
            end:   end
        }
    } else if begin_y + 1 == end_y {
        let row = new_swin1D(begin_x, end_x);
        Swin2D {
            write: |x, y, v| row.write(x, v),
            read:  |x, y|    row.read(x),
            begin: begin,
            end:   end
        }
    } else {
        let m = (end_y + begin_y) / 2;
        let left  = new_swin2D((begin_x, begin_y), (end_x, m));
        let right = new_swin2D((begin_x, m),       (end_x, end_y));
        Swin2D {
            write: |x, y, v| if y >= m { right.write(x, y, v) } else { left.write(x, y, v) },
            read:  |x, y|    if y >= m { right.read(x, y) } else { left.read(x, y) },
            begin: begin,
            end:   end
        }
    }
}

fn shift_swin(lbuf : Acc, swin : Swin2D) -> () {
    let (begin_x, begin_y) = swin.begin;
    let (end_x, end_y) = swin.end;

    // Shift sliding window
    for j in @range(begin_y, end_y) {
        for i in @range(begin_x, end_x - 1) {
            @swin.write(i, j, @swin.read(i + 1, j));
        }
    }

    // Read new col
    for j in @range(begin_y, end_y - 1) {
        @swin.write(end_x - 1, j, lbuf.read(0, j));
    }
}

fn shift_swin_full(lbuf : Acc, swin : Swin2D) -> () {
    let (begin_x, begin_y) = swin.begin;
    let (end_x, end_y) = swin.end;

    // Shift sliding window
    for j in @range(begin_y, end_y) {
        for i in @range(begin_x, end_x - 1) {
            @swin.write(i, j, @swin.read(i + 1, j));
        }
    }

    // Read new col
    for j in @range(begin_y, end_y) {
        @swin.write(end_x - 1, j, lbuf.read(0, j));
    }
}

fn shift_swin_cols(swin : Swin2D) -> () {
    let (begin_x, begin_y) = swin.begin;
    let (end_x, end_y) = swin.end;

    // Shift sliding window
    for j in @range(begin_y, end_y) {
        for i in @range(begin_x, end_x - 1) {
            @swin.write(i, j, @swin.read(i + 1, j));
        }
    }
}

fn get_acc_sw(swin: Swin2D) -> Acc {
    Acc {
        read: |x, y|      swin.read(x, y),
        write: |x, y, v|  swin.write(x, y, v)
    }
}

// image -> lbuf -> sw -> output
fn iteration_v0(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;

        let lbuf        = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_idx = 0;
        let mut row_idx = 0;
        for clock_tick in $range(0, life_time){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  {temp_acc.write(col_idx - half_range_x, row_idx - half_range_y, v)}
            };

            // read new pixel
            let pix_new = arr_acc.read(col_idx, row_idx);

            // shift sliding window
            @shift_swin(lbuf_acc, swin);
            @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }

            col_idx++;
            if col_idx == arr.width {col_idx = 0; row_idx++;}
            if row_idx == arr.height{row_idx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v0 -> v1 : write indexes
fn iteration_v1(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;

        let lbuf        = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  {temp_acc.write(col_widx, row_widx, v)}
            };

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift sliding window
            @shift_swin(lbuf_acc, swin);
            @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
                col_widx++;
                if col_widx == arr.width {col_widx = 0; row_widx++;}
            }

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v1 -> v1_1 : write condition is moved to accessor
fn iteration_v1_1(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;

        let lbuf        = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  if clock_tick > initial_delay {
                                    temp_acc.write(col_widx, row_widx, v);
                                    col_widx++;
                                    if col_widx == arr.width {
                                        col_widx = 0; row_widx++;}
                                  }
            };

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift sliding window
            @shift_swin(lbuf_acc, swin);
            @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v1 -> v2 : write before read
fn iteration_v2(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;

        let lbuf        = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time + 1){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  {temp_acc.write(col_widx, row_widx, v)}
            };

            // write output
            if clock_tick > initial_delay + 1 {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
                col_widx++;
                if col_widx == arr.width {col_widx = 0; row_widx++;}
            }

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift sliding window
            @shift_swin(lbuf_acc, swin);
            @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}


// v2 -> v3 : always write
fn iteration_v3(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;

        let lbuf        = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time + 1){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  {temp_acc.write(col_widx, row_widx, v)}
            };

            // write output
            @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            if clock_tick > initial_delay + 1 {
                col_widx++;
                if col_widx == arr.width {col_widx = 0; row_widx++;}
            }

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift sliding window
            @shift_swin(lbuf_acc, swin);
            @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v3 -> v3_1 : change write accessor
fn iteration_v3_1(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;

        let lbuf        = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time + 1){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  if clock_tick > initial_delay + 1 {
                                    temp_acc.write(col_widx, row_widx, v);
                                    col_widx++;
                                    if col_widx == arr.width {
                                        col_widx = 0; row_widx++;}
                                  }
            };

            // write output
            @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            //if clock_tick > initial_delay + 1 {
            //    col_widx++;
            //    if col_widx == arr.width {col_widx = 0; row_widx++;}
            //}

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift sliding window
            @shift_swin(lbuf_acc, swin);
            @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}


// v3 -> v4 : remove sliding window use shared memory
// Converging to Altera style
fn iteration_v4(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf        = reserve_shared[f32](lbuf_size);
        //let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        //let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time + 1){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  {temp_acc.write(col_widx, row_widx, v)}
            };

            // write output
            @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);
            if clock_tick > initial_delay + 1 {
                col_widx++;
                if col_widx == arr.width {col_widx = 0; row_widx++;}
            }

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift sliding window
            //@shift_swin(lbuf_acc, swin);
            //@swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v4 -> v5 : write after shift (no sliding window)
fn iteration_v5(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  {temp_acc.write(col_widx, row_widx, v)}
            };

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);
            if clock_tick > initial_delay {
                col_widx++;
                if col_widx == arr.width {col_widx = 0; row_widx++;}
            }

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
    //release(arr_gpu.buf);
    //release(out_gpu.buf);
}

// v5 -> v5_1 : write condition moved to accessor (as in v1_1)
fn iteration_v5_1(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  if clock_tick > initial_delay {
                                    temp_acc.write(col_widx, row_widx, v);
                                    col_widx++;
                                    if col_widx == arr.width {
                                        col_widx = 0; row_widx++;
                                    }
                                  }
            };

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v5_1 -> v5_2 : accessor for read as well
fn iteration_v5_2(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {let mut pix_read = 0.0f;
                                    if clock_tick < process_time {
                                        pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                    }
                                    pix_read},
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|      {temp_out_acc.read(x, y)},
                write: |x, y, v|  if clock_tick > initial_delay {
                                    temp_out_acc.write(col_widx, row_widx, v);
                                    col_widx++;
                                    if col_widx == arr.width {
                                        col_widx = 0; row_widx++;
                                    }
                                  }
            };

            // read new pixel
            let pix_new = in_acc.read(col_ridx, row_ridx);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v5_2 -> v5_3 : accessor read condition is moved from read
fn iteration_v5_3(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|    {
                                    let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                    col_ridx++;
                                    if col_ridx == arr.width {
                                        col_ridx = 0; row_ridx++;
                                    }
                                    pix_read
                                },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|      {temp_out_acc.read(x, y)},
                write: |x, y, v|  if clock_tick > initial_delay {
                                    temp_out_acc.write(col_widx, row_widx, v);
                                    col_widx++;
                                    if col_widx == arr.width {
                                        col_widx = 0; row_widx++;
                                    }
                                  }
            };

            {
                // read new pixel
                let mut pix_new = 0.0f;
                if clock_tick < process_time {
                    pix_new = in_acc.read(col_ridx, row_ridx);
                }

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;
            }

            // write output
            @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v5_3 -> v5_4 : write condition is moved from accessor to the execution of the body
fn iteration_v5_4(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    {
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                // read new pixel
                let mut pix_new = 0.0f;
                if clock_tick < process_time {
                    pix_new = in_acc.read(col_ridx, row_ridx);
                }

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;
            }

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v5_4 -> v5_5 : select for new pixel read
fn iteration_v5_5(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    { 
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            { 
                let pix_new = select(clock_tick < process_time, in_acc.read(col_ridx, row_ridx), 0.0f);

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;
            }

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v5_5 -> v5_6 : new pixel read in a pipelined manner (similar to v8_3) 
fn iteration_v5_6(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        let mut pix_new_next;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    {
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                let pix_new = pix_new_next;

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;
                
                pix_new_next = select(clock_tick < process_time, in_acc.read(col_ridx, row_ridx), pix_new);
            }

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}


// v5 -> v6 : state machine
fn iteration_v6(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        let mut clock_tick = 0;
        //for clock_tick in $range(0, life_time){
        fn state_machine() -> (){
            fn read() -> !{
                clock_tick++;
                if clock_tick > process_time { shift(0.0f) }

                col_ridx++;
                if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
                //let col_finished_flag = (col_ridx == arr.width);
                //col_ridx = select(col_finished_flag, 0, col_ridx);
                //row_ridx = select(col_finished_flag, row_ridx++, row_ridx);

                let pix_new = arr_acc.read(col_ridx, row_ridx);
                shift(pix_new)
            }

            fn shift(pix_new: float) -> !{
               for i in $range(0, lbuf_size - 1){
                   lbuf(i) = lbuf(i + 1);
               }
               lbuf(lbuf_size - 1) = pix_new;

                if clock_tick < initial_delay + 1 {
                    read()
                }else{
                    write()
                }
            }

            fn write() -> !{
                let out_acc = Acc {
                    read: |x, y|      {temp_acc.read(x, y)},
                    write: |x, y, v|  {temp_acc.write(col_widx, row_widx, v)}
                };
                @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);

                col_widx++;
                if col_widx == arr.width {col_widx = 0; row_widx++;}

                if clock_tick == life_time {
                    return()
                } else{
                    read()
                }
            }
            read()
        }
        state_machine()
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v7 -> v5_2 + v1_1 : lb -> sw ->out 
fn iteration_v7(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {let mut pix_read = 0.0f; 
                                    if clock_tick < process_time {
                                        pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                    }
                                    pix_read},
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|      {temp_out_acc.read(x, y)},
                write: |x, y, v|  if clock_tick > initial_delay {
                                    temp_out_acc.write(col_widx, row_widx, v);
                                    col_widx++;
                                    if col_widx == arr.width {
                                        col_widx = 0; row_widx++;
                                    }
                                  }
            };

            // read new pixel
            let pix_new = in_acc.read(col_ridx, row_ridx);

             // shift sliding window                                              
             @shift_swin(lbuf_acc, swin);                                         
             @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);              

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            //out_acc.write(half_range_x, half_range_y, swin_acc.read(half_range_x, half_range_y));
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v7 -> v7_1 : swin reads only from line buffer 
fn iteration_v7_1(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + 1;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {let mut pix_read = 0.0f; 
                                    if clock_tick < process_time {
                                        pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                    }
                                    pix_read},
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|      {temp_out_acc.read(x, y)},
                write: |x, y, v|  if clock_tick > initial_delay {
                                    temp_out_acc.write(col_widx, row_widx, v);
                                    col_widx++;
                                    if col_widx == arr.width {
                                        col_widx = 0; row_widx++;
                                    }
                                  }
            };

            // read new pixel
            let pix_new = in_acc.read(col_ridx, row_ridx);

             // shift sliding window                                              
             @shift_swin_full(lbuf_acc, swin);                                         

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v7_1 -> v7_2 : line buffer = 5 image rows 
fn iteration_v7_2(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * (half_range_y + 1) + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {let mut pix_read = 0.0f; 
                                    if clock_tick < process_time {
                                        pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                    }
                                    pix_read},
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|      {temp_out_acc.read(x, y)},
                write: |x, y, v|  if clock_tick > initial_delay {
                                    temp_out_acc.write(col_widx, row_widx, v);
                                    col_widx++;
                                    if col_widx == arr.width {
                                        col_widx = 0; row_widx++;
                                    }
                                  }
            };

            // read new pixel
            let pix_new = in_acc.read(col_ridx, row_ridx);

             // shift sliding window                                              
             @shift_swin_full(lbuf_acc, swin);                                         

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

//v8 = v5_5 + swin (simialar ro v7 but with select) 
fn iteration_v8(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    {
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                // read new pix
                let pix_new = select(clock_tick < process_time, in_acc.read(col_ridx, row_ridx), 0.0f);

                // shift sliding window
                @shift_swin(lbuf_acc, swin);
                @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;
            }

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

//v8 -> v8_1 : swin reads from lbuf (similar to v7_1)
fn iteration_v8_1(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + 1;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    { 
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            { 
                // read new pix
                let pix_new = select(clock_tick < process_time, in_acc.read(col_ridx, row_ridx), 0.0f);

                // shift sliding window
                @shift_swin_full(lbuf_acc, swin);

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;
            }

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

//v8_1 -> v8_2 : line buffer = 5 image rows (similar to v7_2)
fn iteration_v8_2(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * (half_range_y + 1) + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    { 
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                // read new pix
                let pix_new = select(clock_tick < process_time, in_acc.read(col_ridx, row_ridx), 0.0f);

                // shift sliding window
                @shift_swin_full(lbuf_acc, swin);

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;
            }

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

//v8_2 -> v8_3 : pix_new_next
fn iteration_v8_3(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * (half_range_y + 1) + half_range_x;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        let mut pix_new_next;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    {
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                // read new pix
                let pix_new = pix_new_next;

                // shift sliding window
                @shift_swin_full(lbuf_acc, swin);

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;

                pix_new_next = select(clock_tick < process_time, in_acc.read(col_ridx, row_ridx), pix_new);

            }

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}


//v8 -> v8_4 : select is removed (as in v5_4) 
fn iteration_v8_4(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    {
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                // read new pixel
                let mut pix_new = 0.0f;
                if clock_tick < process_time {
                    pix_new = in_acc.read(col_ridx, row_ridx);
                }

                // shift sliding window
                @shift_swin(lbuf_acc, swin);
                @swin.write(mask.size_x - 1, mask.size_y - 1, pix_new);

                // shift lbuf
                for i in $range(0, lbuf_size - 1){
                    lbuf(i) = lbuf(i + 1);
                }
                lbuf(lbuf_size - 1) = pix_new;
            }

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}


// v8 -> v9: xilinx style row buffers (last image rows are ignored)
fn iteration_v9(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf0 = reserve_shared[f32](lbuf_stride);
        let lbuf1 = reserve_shared[f32](lbuf_stride);
        let lbuf2 = reserve_shared[f32](lbuf_stride);
        let lbuf3 = reserve_shared[f32](lbuf_stride);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        //let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        let mut pix_new;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        col_ridx++;
                                        if col_ridx == arr.width {
                                            col_ridx = 0; row_ridx++;
                                        }
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    {
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                // read new pix
                if clock_tick < process_time {
                    pix_new = in_acc.read(col_ridx, row_ridx);
                }

                // reads from lbuf
				let pix_2swin0  = lbuf0(col_ridx);
				let pix_2swin1  = lbuf1(col_ridx);
				let pix_2swin2  = lbuf2(col_ridx);
				let pix_2swin3  = lbuf3(col_ridx);

				{// shift line buffers 
				lbuf0(col_ridx) = pix_2swin1; 
				lbuf1(col_ridx) = pix_2swin2;
				lbuf2(col_ridx) = pix_2swin3;
				lbuf3(col_ridx) = pix_new;
				};

				{// shift sliding window
                @shift_swin_cols(swin);
                @swin.write(mask.size_x - 1, 0, pix_2swin0);
                @swin.write(mask.size_x - 1, 1, pix_2swin1);
                @swin.write(mask.size_x - 1, 2, pix_2swin2);
                @swin.write(mask.size_x - 1, 3, pix_2swin3);
                @swin.write(mask.size_x - 1, 4, pix_new);
				};
            };

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v9 -> v9_1: image read indexes are moved to the loop 
fn iteration_v9_1(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf0 = reserve_shared[f32](lbuf_stride);
        let lbuf1 = reserve_shared[f32](lbuf_stride);
        let lbuf2 = reserve_shared[f32](lbuf_stride);
        let lbuf3 = reserve_shared[f32](lbuf_stride);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        //let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        let mut pix_new;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    {
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                // read new pix
                if clock_tick < process_time {
                    pix_new = in_acc.read(col_ridx, row_ridx);
                }

                // reads from lbuf
				let pix_2swin0  = lbuf0(col_ridx);
				let pix_2swin1  = lbuf1(col_ridx);
				let pix_2swin2  = lbuf2(col_ridx);
				let pix_2swin3  = lbuf3(col_ridx);

				{// shift line buffers 
				lbuf0(col_ridx) = pix_2swin1; 
				lbuf1(col_ridx) = pix_2swin2;
				lbuf2(col_ridx) = pix_2swin3;
				lbuf3(col_ridx) = pix_new;
				};
                
				{// update image indexes
				col_ridx++;
                if col_ridx == arr.width {
                    col_ridx = 0; row_ridx++;
                }
				};

				{// shift sliding window
                @shift_swin_cols(swin);
                @swin.write(mask.size_x - 1, 0, pix_2swin0);
                @swin.write(mask.size_x - 1, 1, pix_2swin1);
                @swin.write(mask.size_x - 1, 2, pix_2swin2);
                @swin.write(mask.size_x - 1, 3, pix_2swin3);
                @swin.write(mask.size_x - 1, 4, pix_new);
				};
            };

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}

// v9_1 -> v9_2: memory counters are masked 
fn iteration(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf0 = reserve_shared[f32](lbuf_stride);
        let lbuf1 = reserve_shared[f32](lbuf_stride);
        let lbuf2 = reserve_shared[f32](lbuf_stride);
        let lbuf3 = reserve_shared[f32](lbuf_stride);
        let swin = @new_swin2D((0, 0), (mask.size_x, mask.size_y));

        let temp_in_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_out_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        //let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);
        let swin_acc = get_acc_sw(swin);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        let mut pix_new;
        for clock_tick in $range(0, life_time){
            let in_acc = Acc {
                read: |x, y|        {
                                        let pix_read = temp_in_acc.read(col_ridx, row_ridx);
                                        pix_read
                                    },
                write: |x, y, v|    {temp_in_acc.write(x, y, v)}
            };
            let out_acc = Acc {
                read: |x, y|        {temp_out_acc.read(x, y)},
                write: |x, y, v|    {
                                        temp_out_acc.write(col_widx, row_widx, v);
                                        col_widx++;
                                        if col_widx == arr.width {
                                            col_widx = 0; row_widx++;
                                        }
                                    }
            };

            {
                // read new pix
                if clock_tick < process_time {
                    pix_new = in_acc.read(col_ridx, row_ridx);
                }

                // reads from lbuf
				let pix_2swin0  = lbuf0(col_ridx & 0x3FF);
				let pix_2swin1  = lbuf1(col_ridx & 0x3FF);
				let pix_2swin2  = lbuf2(col_ridx & 0x3FF);
				let pix_2swin3  = lbuf3(col_ridx & 0x3FF);

				{// shift line buffers 
				lbuf0(col_ridx & 0x3FF) = pix_2swin1; 
				lbuf1(col_ridx & 0x3FF) = pix_2swin2;
				lbuf2(col_ridx & 0x3FF) = pix_2swin3;
				lbuf3(col_ridx & 0x3FF) = pix_new;
				};
                
				{// update image indexes
				col_ridx = ((col_ridx + 1) & 0x3FF);
                if(col_ridx == 0){
                    row_ridx++;
                }
                // if col_ridx == arr.width {
                //     col_ridx = 0; row_ridx++;
                // }
				};

				{// shift sliding window
                @shift_swin_cols(swin);
                @swin.write(mask.size_x - 1, 0, pix_2swin0);
                @swin.write(mask.size_x - 1, 1, pix_2swin1);
                @swin.write(mask.size_x - 1, 2, pix_2swin2);
                @swin.write(mask.size_x - 1, 3, pix_2swin3);
                @swin.write(mask.size_x - 1, 4, pix_new);
				};
            };

            // write output
            if clock_tick > initial_delay {
                @body(math, half_range_x, half_range_y, out_acc, swin_acc, mask);
            }
        }
    }
    acc.sync();
    copy_img(out_gpu, out);
}
