fn release_device_copy(img: Img) -> () {
    release(img.buf)
}

fn get_ldg_fn() -> fn(&[1]f32) -> f32 { if is_nvvm() { nvvm_ldg_f32 } else { cuda_ldg_f32 } }
fn set_pixel_fn(img: Img) -> fn(i32, f32) -> () { |idx, val| bitcast[&mut[1][f32]](img.buf.data)(idx) = val }
fn get_pixel_fn(img: Img) -> fn(i32) -> f32 { |idx| bitcast[&[1][f32]](img.buf.data)(idx) }
fn get_pixel_ldg_fn(img: Img) -> fn(i32) -> f32 { if has_ldg() { |idx| get_ldg_fn()(&bitcast[&[1][f32]](img.buf.data)(idx)) } else { get_pixel_fn(img) } }
fn set_pixel_shared_fn(data: &mut[3][f32]) -> fn(i32, f32) -> () { |idx, val| data(idx) = val }
fn get_pixel_shared_fn(data: &[3][f32]) -> fn(i32) -> f32 { |idx| data(idx) }


fn iteration(math: Intrinsics, out: Img, arr: Img, mask: Mask, bh_lower: BoundaryFn, bh_upper: BoundaryFn, body: StencilFn) -> () {
    let acc = accelerator(device_id);
    let arr_gpu = alloc_img(arr, acc.alloc);
    let out_gpu = alloc_img(out, acc.alloc);

    copy_img(arr, arr_gpu);
    with acc.exec((1,1,1), (1,1,1)) @{
        let lbuf_stride = arr_gpu.stride;
        let lbuf_height = mask.size_y - 1;
        let lbuf_size   = lbuf_stride * lbuf_height + mask.size_x;
        let half_range_y    = mask.size_y / 2;
        let half_range_x    = mask.size_x / 2;
        let process_time    = arr.width * arr.height;
        let initial_delay   = arr.width * half_range_y + half_range_x - 1;
        let life_time       = initial_delay + process_time;

        let lbuf = reserve_shared[f32](lbuf_size);

        let arr_acc  = get_acc_bh(arr_gpu, set_pixel_fn(arr_gpu), get_pixel_ldg_fn(arr_gpu), 10, bh_lower, bh_upper);
        let temp_acc = get_acc(out_gpu, set_pixel_fn(out_gpu), get_pixel_fn(out_gpu));
        let lbuf_acc = get_acc_memory(set_pixel_shared_fn(lbuf), get_pixel_shared_fn(lbuf), lbuf_stride, lbuf_height);

        let mut col_ridx = 0; let mut row_ridx = 0;
        let mut col_widx = 0; let mut row_widx = 0;
        for clock_tick in $range(0, life_time){
            let out_acc = Acc {
                read: |x, y|      {temp_acc.read(x, y)},
                write: |x, y, v|  {temp_acc.write(col_widx, row_widx, v)}
            };

            // read new pixel
            let pix_new = arr_acc.read(col_ridx, row_ridx);

            // shift lbuf
            for i in $range(0, lbuf_size - 1){
                lbuf(i) = lbuf(i + 1);
            }
            lbuf(lbuf_size - 1) = pix_new;

            // write output
            @body(math, half_range_x, half_range_y, out_acc, lbuf_acc, mask);
            if clock_tick > initial_delay {
                col_widx++;
                if col_widx == arr.width {col_widx = 0; row_widx++;}
            }

            col_ridx++;
            if col_ridx == arr.width {col_ridx = 0; row_ridx++;}
            if row_ridx == arr.height{row_ridx = 0;}
        }
    }
    copy_img(out_gpu, out);
    //release(arr_gpu.buf);
    //release(out_gpu.buf);
}
