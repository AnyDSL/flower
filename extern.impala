fn iterate_step(a : int, b : int, step : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        iterate_step(a+step, b, step, yield, return)
    }
}

fn iterate_step_rev(a : int, b : int, step : int, yield : fn(int, fn())) -> () {
    if a > b {
        yield(a);
        iterate_step_rev(a-step, b, step, yield, return)
    }
}

fn iterate(a : int, b : int, yield : fn(int, fn())) -> () { iterate_step(a, b, 1, yield) }
fn iterate_rev(a : int, b : int, yield : fn(int, fn())) -> () { iterate_step_rev(a, b, 1, yield) }
fn range(a : int, b : int, yield : fn(int, fn())) -> () { iterate(a, b, yield) }
fn range_step(a : int, b : int, step : int, yield : fn(int, fn())) -> () { iterate_step(a, b, step, yield) }
fn range_rev(a : int, b : int, yield : fn(int, fn())) -> () { iterate_rev(a, b, yield) }
fn range_step_rev(a : int, b : int, step : int, yield : fn(int, fn())) -> () { iterate_step_rev(a, b, step, yield) }

fn force_unroll(a : int, b : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        @force_unroll(a+1, b, yield, return)
    }
}

fn iterate_times_two(a : int, b : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        iterate_times_two(a*2, b, yield, return)
    }
}

fn init_zero(mut arr : &[float], width : int, height : int) -> () {
    for i in iterate(0, width*height) {
        arr(i) = 0.0f;
    }
}
fn init_rand(mut arr : &[float], width : int, height : int) -> () {
    for y in iterate(0, height) {
        for x in iterate(0, width) {
            arr(y*width + x) = thorin_random_val(1024);
        }
    }
}

// border handling specialization
fn clamp_lower(idx : int, lower : int) -> int {
    if idx < lower { lower } else { idx }
}
fn clamp_upper(idx : int, upper : int) -> int {
    if idx >= upper { upper - 1 } else { idx }
}
fn clamp_none(idx : int, bound : int) -> int {
    idx
}
fn mirror_lower(idx : int, lower : int) -> int {
    if idx < lower { lower + (lower - idx-1) } else { idx }
}
fn mirror_upper(idx : int, upper : int) -> int {
    if idx >= upper { upper - (idx+1 - upper) } else { idx }
}
fn repeat_lower(idx : int, lower : int, stride : int) -> int {
    if idx < lower { idx + stride } else { idx }
}
fn repeat_upper(idx : int, upper : int, stride : int) -> int {
    if idx >= upper { idx - stride } else { idx }
}

// nearest multiple of num
fn round_up(num : int, multiple : int) -> int {
    if multiple == 0 { return(num) }

    let rem = num % multiple;
    if rem == 0 { num } else { num + multiple - rem }
}

fn sort(num : int, mut arr : &[i64]) -> () {
    // insertion sort
    for i in range(1, num) {
        let x = arr(i);
        let mut j = i;
        while j > 0 && arr(j-1) > x {
            arr(j) = arr(j-1);
            j = j - 1;
        }
        arr(j) = x;
    }
}

// structs for images and accessors
struct Img {
    data : &[float],
    width : int,
    height : int,
    stride : int,
}
struct Acc {
    img : Img,
    o_x : int,
    o_y : int,
    width: int,
    height : int,
    region : int,
}
struct Mask3 {
    data : [[float * 3] * 3],
    size_x : int,
    size_y : int,
}
struct Mask3Sep {
    data : [float * 3],
    size : int,
}
struct Mask5 {
    data : [[float * 5] * 5],
    size_x : int,
    size_y : int,
}
struct Mask5Sep {
    data : [float * 5],
    size : int,
}
