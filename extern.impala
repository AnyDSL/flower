fn iterate_step(a : int, b : int, step : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        iterate_step(a+step, b, step, yield, return)
    }
}

fn iterate_step_rev(a : int, b : int, step : int, yield : fn(int, fn())) -> () {
    if a > b {
        yield(a);
        iterate_step_rev(a-step, b, step, yield, return)
    }
}

fn iterate(a : int, b : int, yield : fn(int, fn())) -> () { iterate_step(a, b, 1, yield) }
fn iterate_rev(a : int, b : int, yield : fn(int, fn())) -> () { iterate_step_rev(a, b, 1, yield) }
fn range(a : int, b : int, yield : fn(int, fn())) -> () { iterate(a, b, yield) }
fn range_step(a : int, b : int, step : int, yield : fn(int, fn())) -> () { iterate_step(a, b, step, yield) }
fn range_rev(a : int, b : int, yield : fn(int, fn())) -> () { iterate_rev(a, b, yield) }
fn range_step_rev(a : int, b : int, step : int, yield : fn(int, fn())) -> () { iterate_step_rev(a, b, step, yield) }

fn force_unroll(a : int, b : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        @force_unroll(a+1, b, yield, return)
    }
}

fn iterate_times_two(a : int, b : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        iterate_times_two(a*2, b, yield, return)
    }
}

fn init_zero(mut arr : &[float], width : int, height : int) -> () {
    for i in iterate(0, width*height) {
        arr(i) = 0.0f;
    }
}
fn init_rand(mut arr : &[float], width : int, height : int) -> () {
    for y in iterate(0, height) {
        for x in iterate(0, width) {
            arr(y*width + x) = thorin_random_val(1024);
        }
    }
}

// border handling specialization
fn nobh_center (idx: int, lower: int, upper: int, out: fn(f32)) -> int { idx }
fn clamp_lower (idx: int, lower: int, upper: int, out: fn(f32)) -> int {
    if idx < lower { lower } else { idx }
}
fn clamp_upper (idx: int, lower: int, upper: int, out: fn(f32)) -> int {
    if idx >= upper { upper - 1 } else { idx }
}
fn mirror_lower(idx: int, lower: int, upper: int, out: fn(f32)) -> int {
    if idx < lower { lower + (lower - idx-1) } else { idx }
}
fn mirror_upper(idx: int, lower: int, upper: int, out: fn(f32)) -> int {
    if idx >= upper { upper - (idx+1 - upper) } else { idx }
}
fn repeat_lower(idx: int, lower: int, upper: int, out: fn(f32)) -> int {
    if idx < lower { idx + (lower + upper) } else { idx }
}
fn repeat_upper(idx: int, lower: int, upper: int, out: fn(f32)) -> int {
    if idx >= upper { idx - (lower + upper) } else { idx }
}
fn const_lower (idx: int, lower: int, upper: int, cval: f32, out: fn(f32)) -> int {
    if idx < lower { out(cval) } else { idx }
}
fn const_upper (idx: int, lower: int, upper: int, cval: f32, out: fn(f32)) -> int {
    if idx >= upper { out(cval) } else { idx }
}
fn wrap_const_fun(fun: fn(int, int, int, f32, fn(f32)) -> int, cval: float) -> fn(int, int, int, fn(f32)) -> int {
    |idx, lower, upper, out| fun(idx, lower, upper, cval, out)
}
fn pixel_at(acc: Acc, x: int, y: int) -> float {
    acc.img.data((acc.roi.o_y + acc.roy + y) * acc.img.stride + acc.roi.o_x + acc.rox + x)
}
fn get_pixel(acc: Acc, x: int, y: int,
             bh_lower: fn(int, int, int, fn(f32)) -> int,
             bh_upper: fn(int, int, int, fn(f32)) -> int
            ) -> float {
    let mut idx_x = acc.roi.o_x + acc.rox + x;
    let mut idx_y = acc.roi.o_y + acc.roy + y;

    let lower_x = acc.roi.o_x;
    let lower_y = acc.roi.o_y;
    let upper_x = acc.roi.o_x + acc.roi.width;
    let upper_y = acc.roi.o_y + acc.roi.height;

    // 0 --- 1 --- 2
    // 3 --- 4 --- 5
    // 6 --- 7 --- 8

    // left
    if acc.region == 0 { idx_x = bh_lower(idx_x, lower_x, upper_x, return); }
    if acc.region == 3 { idx_x = bh_lower(idx_x, lower_x, upper_x, return); }
    if acc.region == 6 { idx_x = bh_lower(idx_x, lower_x, upper_x, return); }

    // right
    if acc.region == 2 { idx_x = bh_upper(idx_x, lower_x, upper_x, return); }
    if acc.region == 5 { idx_x = bh_upper(idx_x, lower_x, upper_x, return); }
    if acc.region == 8 { idx_x = bh_upper(idx_x, lower_x, upper_x, return); }

    // top
    if acc.region == 0 { idx_y = bh_lower(idx_y, lower_y, upper_y, return); }
    if acc.region == 1 { idx_y = bh_lower(idx_y, lower_y, upper_y, return); }
    if acc.region == 2 { idx_y = bh_lower(idx_y, lower_y, upper_y, return); }

    // bottom
    if acc.region == 6 { idx_y = bh_upper(idx_y, lower_y, upper_y, return); }
    if acc.region == 7 { idx_y = bh_upper(idx_y, lower_y, upper_y, return); }
    if acc.region == 8 { idx_y = bh_upper(idx_y, lower_y, upper_y, return); }

    // all in
    if acc.region == 10 {
        idx_x = bh_lower(idx_x, lower_x, upper_x, return);
        idx_x = bh_upper(idx_x, lower_x, upper_x, return);
        idx_y = bh_lower(idx_y, lower_y, upper_y, return);
        idx_y = bh_upper(idx_y, lower_y, upper_y, return);
    }

    acc.img.data(idx_y*acc.img.stride + idx_x)
}


// nearest multiple of num
fn round_up(num : int, multiple : int) -> int {
    if multiple == 0 { return(num) }

    let rem = num % multiple;
    if rem == 0 { num } else { num + multiple - rem }
}

fn benchmark(body: fn() -> ()) -> () {
    let mut times = ~[7:i64];
    for i in $range(0, 7) {
        let start = thorin_get_micro_time();
        @body();
        times(i) = thorin_get_micro_time()-start;
    }
    sort(7, times as &[i64]);
    thorin_print_micro_time(times(3));
}

fn sort(num : int, mut arr : &[i64]) -> () {
    // insertion sort
    for i in range(1, num) {
        let x = arr(i);
        let mut j = i;
        while j > 0 && arr(j-1) > x {
            arr(j) = arr(j-1);
            j = j - 1;
        }
        arr(j) = x;
    }
}

// structs for images and accessors
fn get_acc(img : Img, region : int) -> Acc {
    Acc { img : img, roi : RoI { o_x : 0, o_y : 0, width : img.width, height : img.height }, rox : 0, roy : 0, region : region }
}
struct Img {
    data : &[float],
    width : int,
    height : int,
    stride : int,
}
struct RoI {
    o_x : int,
    o_y : int,
    width : int,
    height : int
}
struct Acc {
    img : Img,
    roi : RoI,
    rox : int,
    roy : int,
    region : int,
}
struct Mask3 {
    data : [[float * 3] * 3],
    size_x : int,
    size_y : int,
}
struct Mask3Sep {
    data : [float * 3],
    size : int,
}
struct Mask5 {
    data : [[float * 5] * 5],
    size_x : int,
    size_y : int,
}
struct Mask5Sep {
    data : [float * 5],
    size : int,
}
